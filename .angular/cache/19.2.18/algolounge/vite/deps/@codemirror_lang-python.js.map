{
  "version": 3,
  "sources": ["../../../../../../node_modules/@lezer/lr/dist/index.js", "../../../../../../node_modules/@lezer/python/dist/index.js", "../../../../../../node_modules/@codemirror/lang-python/dist/index.js"],
  "sourcesContent": ["import { Parser, NodeProp, NodeSet, NodeType, DefaultBufferLength, Tree, IterMode } from '@lezer/common';\n\n/**\nA parse stack. These are used internally by the parser to track\nparsing progress. They also provide some properties and methods\nthat external code such as a tokenizer can use to get information\nabout the parse state.\n*/\nclass Stack {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  The parse that this stack is part of @internal\n  */\n  p,\n  /**\n  Holds state, input pos, buffer index triplets for all but the\n  top state @internal\n  */\n  stack,\n  /**\n  The current parse state @internal\n  */\n  state,\n  // The position at which the next reduce should take place. This\n  // can be less than `this.pos` when skipped expressions have been\n  // added to the stack (which should be moved outside of the next\n  // reduction)\n  /**\n  @internal\n  */\n  reducePos,\n  /**\n  The input position up to which this stack has parsed.\n  */\n  pos,\n  /**\n  The dynamic score of the stack, including dynamic precedence\n  and error-recovery penalties\n  @internal\n  */\n  score,\n  // The output buffer. Holds (type, start, end, size) quads\n  // representing nodes created by the parser, where `size` is\n  // amount of buffer array entries covered by this node.\n  /**\n  @internal\n  */\n  buffer,\n  // The base offset of the buffer. When stacks are split, the split\n  // instance shared the buffer history with its parent up to\n  // `bufferBase`, which is the absolute offset (including the\n  // offset of previous splits) into the buffer at which this stack\n  // starts writing.\n  /**\n  @internal\n  */\n  bufferBase,\n  /**\n  @internal\n  */\n  curContext,\n  /**\n  @internal\n  */\n  lookAhead = 0,\n  // A parent stack from which this was split off, if any. This is\n  // set up so that it always points to a stack that has some\n  // additional buffer content, never to a stack with an equal\n  // `bufferBase`.\n  /**\n  @internal\n  */\n  parent) {\n    this.p = p;\n    this.stack = stack;\n    this.state = state;\n    this.reducePos = reducePos;\n    this.pos = pos;\n    this.score = score;\n    this.buffer = buffer;\n    this.bufferBase = bufferBase;\n    this.curContext = curContext;\n    this.lookAhead = lookAhead;\n    this.parent = parent;\n  }\n  /**\n  @internal\n  */\n  toString() {\n    return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n  }\n  // Start an empty stack\n  /**\n  @internal\n  */\n  static start(p, state, pos = 0) {\n    let cx = p.parser.context;\n    return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);\n  }\n  /**\n  The stack's current [context](#lr.ContextTracker) value, if\n  any. Its type will depend on the context tracker's type\n  parameter, or it will be `null` if there is no context\n  tracker.\n  */\n  get context() {\n    return this.curContext ? this.curContext.context : null;\n  }\n  // Push a state onto the stack, tracking its start position as well\n  // as the buffer base at that point.\n  /**\n  @internal\n  */\n  pushState(state, start) {\n    this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n    this.state = state;\n  }\n  // Apply a reduce action\n  /**\n  @internal\n  */\n  reduce(action) {\n    var _a;\n    let depth = action >> 19 /* Action.ReduceDepthShift */,\n      type = action & 65535 /* Action.ValueMask */;\n    let {\n      parser\n    } = this.p;\n    let lookaheadRecord = this.reducePos < this.pos - 25 /* Lookahead.Margin */;\n    if (lookaheadRecord) this.setLookAhead(this.pos);\n    let dPrec = parser.dynamicPrecedence(type);\n    if (dPrec) this.score += dPrec;\n    if (depth == 0) {\n      this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n      // Zero-depth reductions are a special caseâ€”they add stuff to\n      // the stack without popping anything off.\n      if (type < parser.minRepeatTerm) this.storeNode(type, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true);\n      this.reduceContext(type, this.reducePos);\n      return;\n    }\n    // Find the base index into `this.stack`, content after which will\n    // be dropped. Note that with `StayFlag` reductions we need to\n    // consume two extra frames (the dummy parent node for the skipped\n    // expression and the state that we'll be staying in, which should\n    // be moved to `this.state`).\n    let base = this.stack.length - (depth - 1) * 3 - (action & 262144 /* Action.StayFlag */ ? 6 : 0);\n    let start = base ? this.stack[base - 2] : this.p.ranges[0].from,\n      size = this.reducePos - start;\n    // This is a kludge to try and detect overly deep left-associative\n    // trees, which will not increase the parse stack depth and thus\n    // won't be caught by the regular stack-depth limit check.\n    if (size >= 2000 /* Recover.MinBigReduction */ && !((_a = this.p.parser.nodeSet.types[type]) === null || _a === void 0 ? void 0 : _a.isAnonymous)) {\n      if (start == this.p.lastBigReductionStart) {\n        this.p.bigReductionCount++;\n        this.p.lastBigReductionSize = size;\n      } else if (this.p.lastBigReductionSize < size) {\n        this.p.bigReductionCount = 1;\n        this.p.lastBigReductionStart = start;\n        this.p.lastBigReductionSize = size;\n      }\n    }\n    let bufferBase = base ? this.stack[base - 1] : 0,\n      count = this.bufferBase + this.buffer.length - bufferBase;\n    // Store normal terms or `R -> R R` repeat reductions\n    if (type < parser.minRepeatTerm || action & 131072 /* Action.RepeatFlag */) {\n      let pos = parser.stateFlag(this.state, 1 /* StateFlag.Skipped */) ? this.pos : this.reducePos;\n      this.storeNode(type, start, pos, count + 4, true);\n    }\n    if (action & 262144 /* Action.StayFlag */) {\n      this.state = this.stack[base];\n    } else {\n      let baseStateID = this.stack[base - 3];\n      this.state = parser.getGoto(baseStateID, type, true);\n    }\n    while (this.stack.length > base) this.stack.pop();\n    this.reduceContext(type, start);\n  }\n  // Shift a value into the buffer\n  /**\n  @internal\n  */\n  storeNode(term, start, end, size = 4, mustSink = false) {\n    if (term == 0 /* Term.Err */ && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {\n      // Try to omit/merge adjacent error nodes\n      let cur = this,\n        top = this.buffer.length;\n      if (top == 0 && cur.parent) {\n        top = cur.bufferBase - cur.parent.bufferBase;\n        cur = cur.parent;\n      }\n      if (top > 0 && cur.buffer[top - 4] == 0 /* Term.Err */ && cur.buffer[top - 1] > -1) {\n        if (start == end) return;\n        if (cur.buffer[top - 2] >= start) {\n          cur.buffer[top - 2] = end;\n          return;\n        }\n      }\n    }\n    if (!mustSink || this.pos == end) {\n      // Simple case, just append\n      this.buffer.push(term, start, end, size);\n    } else {\n      // There may be skipped nodes that have to be moved forward\n      let index = this.buffer.length;\n      if (index > 0 && this.buffer[index - 4] != 0 /* Term.Err */) {\n        let mustMove = false;\n        for (let scan = index; scan > 0 && this.buffer[scan - 2] > end; scan -= 4) {\n          if (this.buffer[scan - 1] >= 0) {\n            mustMove = true;\n            break;\n          }\n        }\n        if (mustMove) while (index > 0 && this.buffer[index - 2] > end) {\n          // Move this record forward\n          this.buffer[index] = this.buffer[index - 4];\n          this.buffer[index + 1] = this.buffer[index - 3];\n          this.buffer[index + 2] = this.buffer[index - 2];\n          this.buffer[index + 3] = this.buffer[index - 1];\n          index -= 4;\n          if (size > 4) size -= 4;\n        }\n      }\n      this.buffer[index] = term;\n      this.buffer[index + 1] = start;\n      this.buffer[index + 2] = end;\n      this.buffer[index + 3] = size;\n    }\n  }\n  // Apply a shift action\n  /**\n  @internal\n  */\n  shift(action, type, start, end) {\n    if (action & 131072 /* Action.GotoFlag */) {\n      this.pushState(action & 65535 /* Action.ValueMask */, this.pos);\n    } else if ((action & 262144 /* Action.StayFlag */) == 0) {\n      // Regular shift\n      let nextState = action,\n        {\n          parser\n        } = this.p;\n      if (end > this.pos || type <= parser.maxNode) {\n        this.pos = end;\n        if (!parser.stateFlag(nextState, 1 /* StateFlag.Skipped */)) this.reducePos = end;\n      }\n      this.pushState(nextState, start);\n      this.shiftContext(type, start);\n      if (type <= parser.maxNode) this.buffer.push(type, start, end, 4);\n    } else {\n      // Shift-and-stay, which means this is a skipped token\n      this.pos = end;\n      this.shiftContext(type, start);\n      if (type <= this.p.parser.maxNode) this.buffer.push(type, start, end, 4);\n    }\n  }\n  // Apply an action\n  /**\n  @internal\n  */\n  apply(action, next, nextStart, nextEnd) {\n    if (action & 65536 /* Action.ReduceFlag */) this.reduce(action);else this.shift(action, next, nextStart, nextEnd);\n  }\n  // Add a prebuilt (reused) node into the buffer.\n  /**\n  @internal\n  */\n  useNode(value, next) {\n    let index = this.p.reused.length - 1;\n    if (index < 0 || this.p.reused[index] != value) {\n      this.p.reused.push(value);\n      index++;\n    }\n    let start = this.pos;\n    this.reducePos = this.pos = start + value.length;\n    this.pushState(next, start);\n    this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);\n    if (this.curContext) this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));\n  }\n  // Split the stack. Due to the buffer sharing and the fact\n  // that `this.stack` tends to stay quite shallow, this isn't very\n  // expensive.\n  /**\n  @internal\n  */\n  split() {\n    let parent = this;\n    let off = parent.buffer.length;\n    // Because the top of the buffer (after this.pos) may be mutated\n    // to reorder reductions and skipped tokens, and shared buffers\n    // should be immutable, this copies any outstanding skipped tokens\n    // to the new buffer, and puts the base pointer before them.\n    while (off > 0 && parent.buffer[off - 2] > parent.reducePos) off -= 4;\n    let buffer = parent.buffer.slice(off),\n      base = parent.bufferBase + off;\n    // Make sure parent points to an actual parent with content, if there is such a parent.\n    while (parent && base == parent.bufferBase) parent = parent.parent;\n    return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);\n  }\n  // Try to recover from an error by 'deleting' (ignoring) one token.\n  /**\n  @internal\n  */\n  recoverByDelete(next, nextEnd) {\n    let isNode = next <= this.p.parser.maxNode;\n    if (isNode) this.storeNode(next, this.pos, nextEnd, 4);\n    this.storeNode(0 /* Term.Err */, this.pos, nextEnd, isNode ? 8 : 4);\n    this.pos = this.reducePos = nextEnd;\n    this.score -= 190 /* Recover.Delete */;\n  }\n  /**\n  Check if the given term would be able to be shifted (optionally\n  after some reductions) on this stack. This can be useful for\n  external tokenizers that want to make sure they only provide a\n  given token when it applies.\n  */\n  canShift(term) {\n    for (let sim = new SimulatedStack(this);;) {\n      let action = this.p.parser.stateSlot(sim.state, 4 /* ParseState.DefaultReduce */) || this.p.parser.hasAction(sim.state, term);\n      if (action == 0) return false;\n      if ((action & 65536 /* Action.ReduceFlag */) == 0) return true;\n      sim.reduce(action);\n    }\n  }\n  // Apply up to Recover.MaxNext recovery actions that conceptually\n  // inserts some missing token or rule.\n  /**\n  @internal\n  */\n  recoverByInsert(next) {\n    if (this.stack.length >= 300 /* Recover.MaxInsertStackDepth */) return [];\n    let nextStates = this.p.parser.nextStates(this.state);\n    if (nextStates.length > 4 /* Recover.MaxNext */ << 1 || this.stack.length >= 120 /* Recover.DampenInsertStackDepth */) {\n      let best = [];\n      for (let i = 0, s; i < nextStates.length; i += 2) {\n        if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next)) best.push(nextStates[i], s);\n      }\n      if (this.stack.length < 120 /* Recover.DampenInsertStackDepth */) for (let i = 0; best.length < 4 /* Recover.MaxNext */ << 1 && i < nextStates.length; i += 2) {\n        let s = nextStates[i + 1];\n        if (!best.some((v, i) => i & 1 && v == s)) best.push(nextStates[i], s);\n      }\n      nextStates = best;\n    }\n    let result = [];\n    for (let i = 0; i < nextStates.length && result.length < 4 /* Recover.MaxNext */; i += 2) {\n      let s = nextStates[i + 1];\n      if (s == this.state) continue;\n      let stack = this.split();\n      stack.pushState(s, this.pos);\n      stack.storeNode(0 /* Term.Err */, stack.pos, stack.pos, 4, true);\n      stack.shiftContext(nextStates[i], this.pos);\n      stack.reducePos = this.pos;\n      stack.score -= 200 /* Recover.Insert */;\n      result.push(stack);\n    }\n    return result;\n  }\n  // Force a reduce, if possible. Return false if that can't\n  // be done.\n  /**\n  @internal\n  */\n  forceReduce() {\n    let {\n      parser\n    } = this.p;\n    let reduce = parser.stateSlot(this.state, 5 /* ParseState.ForcedReduce */);\n    if ((reduce & 65536 /* Action.ReduceFlag */) == 0) return false;\n    if (!parser.validAction(this.state, reduce)) {\n      let depth = reduce >> 19 /* Action.ReduceDepthShift */,\n        term = reduce & 65535 /* Action.ValueMask */;\n      let target = this.stack.length - depth * 3;\n      if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0) {\n        let backup = this.findForcedReduction();\n        if (backup == null) return false;\n        reduce = backup;\n      }\n      this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);\n      this.score -= 100 /* Recover.Reduce */;\n    }\n    this.reducePos = this.pos;\n    this.reduce(reduce);\n    return true;\n  }\n  /**\n  Try to scan through the automaton to find some kind of reduction\n  that can be applied. Used when the regular ForcedReduce field\n  isn't a valid action. @internal\n  */\n  findForcedReduction() {\n    let {\n        parser\n      } = this.p,\n      seen = [];\n    let explore = (state, depth) => {\n      if (seen.includes(state)) return;\n      seen.push(state);\n      return parser.allActions(state, action => {\n        if (action & (262144 /* Action.StayFlag */ | 131072 /* Action.GotoFlag */)) ;else if (action & 65536 /* Action.ReduceFlag */) {\n          let rDepth = (action >> 19 /* Action.ReduceDepthShift */) - depth;\n          if (rDepth > 1) {\n            let term = action & 65535 /* Action.ValueMask */,\n              target = this.stack.length - rDepth * 3;\n            if (target >= 0 && parser.getGoto(this.stack[target], term, false) >= 0) return rDepth << 19 /* Action.ReduceDepthShift */ | 65536 /* Action.ReduceFlag */ | term;\n          }\n        } else {\n          let found = explore(action, depth + 1);\n          if (found != null) return found;\n        }\n      });\n    };\n    return explore(this.state, 0);\n  }\n  /**\n  @internal\n  */\n  forceAll() {\n    while (!this.p.parser.stateFlag(this.state, 2 /* StateFlag.Accepting */)) {\n      if (!this.forceReduce()) {\n        this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);\n        break;\n      }\n    }\n    return this;\n  }\n  /**\n  Check whether this state has no further actions (assumed to be a direct descendant of the\n  top state, since any other states must be able to continue\n  somehow). @internal\n  */\n  get deadEnd() {\n    if (this.stack.length != 3) return false;\n    let {\n      parser\n    } = this.p;\n    return parser.data[parser.stateSlot(this.state, 1 /* ParseState.Actions */)] == 65535 /* Seq.End */ && !parser.stateSlot(this.state, 4 /* ParseState.DefaultReduce */);\n  }\n  /**\n  Restart the stack (put it back in its start state). Only safe\n  when this.stack.length == 3 (state is directly below the top\n  state). @internal\n  */\n  restart() {\n    this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);\n    this.state = this.stack[0];\n    this.stack.length = 0;\n  }\n  /**\n  @internal\n  */\n  sameState(other) {\n    if (this.state != other.state || this.stack.length != other.stack.length) return false;\n    for (let i = 0; i < this.stack.length; i += 3) if (this.stack[i] != other.stack[i]) return false;\n    return true;\n  }\n  /**\n  Get the parser used by this stack.\n  */\n  get parser() {\n    return this.p.parser;\n  }\n  /**\n  Test whether a given dialect (by numeric ID, as exported from\n  the terms file) is enabled.\n  */\n  dialectEnabled(dialectID) {\n    return this.p.parser.dialect.flags[dialectID];\n  }\n  shiftContext(term, start) {\n    if (this.curContext) this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));\n  }\n  reduceContext(term, start) {\n    if (this.curContext) this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));\n  }\n  /**\n  @internal\n  */\n  emitContext() {\n    let last = this.buffer.length - 1;\n    if (last < 0 || this.buffer[last] != -3) this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);\n  }\n  /**\n  @internal\n  */\n  emitLookAhead() {\n    let last = this.buffer.length - 1;\n    if (last < 0 || this.buffer[last] != -4) this.buffer.push(this.lookAhead, this.pos, this.pos, -4);\n  }\n  updateContext(context) {\n    if (context != this.curContext.context) {\n      let newCx = new StackContext(this.curContext.tracker, context);\n      if (newCx.hash != this.curContext.hash) this.emitContext();\n      this.curContext = newCx;\n    }\n  }\n  /**\n  @internal\n  */\n  setLookAhead(lookAhead) {\n    if (lookAhead > this.lookAhead) {\n      this.emitLookAhead();\n      this.lookAhead = lookAhead;\n    }\n  }\n  /**\n  @internal\n  */\n  close() {\n    if (this.curContext && this.curContext.tracker.strict) this.emitContext();\n    if (this.lookAhead > 0) this.emitLookAhead();\n  }\n}\nclass StackContext {\n  constructor(tracker, context) {\n    this.tracker = tracker;\n    this.context = context;\n    this.hash = tracker.strict ? tracker.hash(context) : 0;\n  }\n}\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n  constructor(start) {\n    this.start = start;\n    this.state = start.state;\n    this.stack = start.stack;\n    this.base = this.stack.length;\n  }\n  reduce(action) {\n    let term = action & 65535 /* Action.ValueMask */,\n      depth = action >> 19 /* Action.ReduceDepthShift */;\n    if (depth == 0) {\n      if (this.stack == this.start.stack) this.stack = this.stack.slice();\n      this.stack.push(this.state, 0, 0);\n      this.base += 3;\n    } else {\n      this.base -= (depth - 1) * 3;\n    }\n    let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);\n    this.state = goto;\n  }\n}\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor {\n  constructor(stack, pos, index) {\n    this.stack = stack;\n    this.pos = pos;\n    this.index = index;\n    this.buffer = stack.buffer;\n    if (this.index == 0) this.maybeNext();\n  }\n  static create(stack, pos = stack.bufferBase + stack.buffer.length) {\n    return new StackBufferCursor(stack, pos, pos - stack.bufferBase);\n  }\n  maybeNext() {\n    let next = this.stack.parent;\n    if (next != null) {\n      this.index = this.stack.bufferBase - next.bufferBase;\n      this.stack = next;\n      this.buffer = next.buffer;\n    }\n  }\n  get id() {\n    return this.buffer[this.index - 4];\n  }\n  get start() {\n    return this.buffer[this.index - 3];\n  }\n  get end() {\n    return this.buffer[this.index - 2];\n  }\n  get size() {\n    return this.buffer[this.index - 1];\n  }\n  next() {\n    this.index -= 4;\n    this.pos -= 4;\n    if (this.index == 0) this.maybeNext();\n  }\n  fork() {\n    return new StackBufferCursor(this.stack, this.pos, this.index);\n  }\n}\n\n// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\nfunction decodeArray(input, Type = Uint16Array) {\n  if (typeof input != \"string\") return input;\n  let array = null;\n  for (let pos = 0, out = 0; pos < input.length;) {\n    let value = 0;\n    for (;;) {\n      let next = input.charCodeAt(pos++),\n        stop = false;\n      if (next == 126 /* Encode.BigValCode */) {\n        value = 65535 /* Encode.BigVal */;\n        break;\n      }\n      if (next >= 92 /* Encode.Gap2 */) next--;\n      if (next >= 34 /* Encode.Gap1 */) next--;\n      let digit = next - 32 /* Encode.Start */;\n      if (digit >= 46 /* Encode.Base */) {\n        digit -= 46 /* Encode.Base */;\n        stop = true;\n      }\n      value += digit;\n      if (stop) break;\n      value *= 46 /* Encode.Base */;\n    }\n    if (array) array[out++] = value;else array = new Type(value);\n  }\n  return array;\n}\nclass CachedToken {\n  constructor() {\n    this.start = -1;\n    this.value = -1;\n    this.end = -1;\n    this.extended = -1;\n    this.lookAhead = 0;\n    this.mask = 0;\n    this.context = 0;\n  }\n}\nconst nullToken = new CachedToken();\n/**\n[Tokenizers](#lr.ExternalTokenizer) interact with the input\nthrough this interface. It presents the input as a stream of\ncharacters, tracking lookahead and hiding the complexity of\n[ranges](#common.Parser.parse^ranges) from tokenizer code.\n*/\nclass InputStream {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  @internal\n  */\n  input,\n  /**\n  @internal\n  */\n  ranges) {\n    this.input = input;\n    this.ranges = ranges;\n    /**\n    @internal\n    */\n    this.chunk = \"\";\n    /**\n    @internal\n    */\n    this.chunkOff = 0;\n    /**\n    Backup chunk\n    */\n    this.chunk2 = \"\";\n    this.chunk2Pos = 0;\n    /**\n    The character code of the next code unit in the input, or -1\n    when the stream is at the end of the input.\n    */\n    this.next = -1;\n    /**\n    @internal\n    */\n    this.token = nullToken;\n    this.rangeIndex = 0;\n    this.pos = this.chunkPos = ranges[0].from;\n    this.range = ranges[0];\n    this.end = ranges[ranges.length - 1].to;\n    this.readNext();\n  }\n  /**\n  @internal\n  */\n  resolveOffset(offset, assoc) {\n    let range = this.range,\n      index = this.rangeIndex;\n    let pos = this.pos + offset;\n    while (pos < range.from) {\n      if (!index) return null;\n      let next = this.ranges[--index];\n      pos -= range.from - next.to;\n      range = next;\n    }\n    while (assoc < 0 ? pos > range.to : pos >= range.to) {\n      if (index == this.ranges.length - 1) return null;\n      let next = this.ranges[++index];\n      pos += next.from - range.to;\n      range = next;\n    }\n    return pos;\n  }\n  /**\n  @internal\n  */\n  clipPos(pos) {\n    if (pos >= this.range.from && pos < this.range.to) return pos;\n    for (let range of this.ranges) if (range.to > pos) return Math.max(pos, range.from);\n    return this.end;\n  }\n  /**\n  Look at a code unit near the stream position. `.peek(0)` equals\n  `.next`, `.peek(-1)` gives you the previous character, and so\n  on.\n  \n  Note that looking around during tokenizing creates dependencies\n  on potentially far-away content, which may reduce the\n  effectiveness incremental parsingâ€”when looking forwardâ€”or even\n  cause invalid reparses when looking backward more than 25 code\n  units, since the library does not track lookbehind.\n  */\n  peek(offset) {\n    let idx = this.chunkOff + offset,\n      pos,\n      result;\n    if (idx >= 0 && idx < this.chunk.length) {\n      pos = this.pos + offset;\n      result = this.chunk.charCodeAt(idx);\n    } else {\n      let resolved = this.resolveOffset(offset, 1);\n      if (resolved == null) return -1;\n      pos = resolved;\n      if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {\n        result = this.chunk2.charCodeAt(pos - this.chunk2Pos);\n      } else {\n        let i = this.rangeIndex,\n          range = this.range;\n        while (range.to <= pos) range = this.ranges[++i];\n        this.chunk2 = this.input.chunk(this.chunk2Pos = pos);\n        if (pos + this.chunk2.length > range.to) this.chunk2 = this.chunk2.slice(0, range.to - pos);\n        result = this.chunk2.charCodeAt(0);\n      }\n    }\n    if (pos >= this.token.lookAhead) this.token.lookAhead = pos + 1;\n    return result;\n  }\n  /**\n  Accept a token. By default, the end of the token is set to the\n  current stream position, but you can pass an offset (relative to\n  the stream position) to change that.\n  */\n  acceptToken(token, endOffset = 0) {\n    let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;\n    if (end == null || end < this.token.start) throw new RangeError(\"Token end out of bounds\");\n    this.token.value = token;\n    this.token.end = end;\n  }\n  /**\n  Accept a token ending at a specific given position.\n  */\n  acceptTokenTo(token, endPos) {\n    this.token.value = token;\n    this.token.end = endPos;\n  }\n  getChunk() {\n    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {\n      let {\n        chunk,\n        chunkPos\n      } = this;\n      this.chunk = this.chunk2;\n      this.chunkPos = this.chunk2Pos;\n      this.chunk2 = chunk;\n      this.chunk2Pos = chunkPos;\n      this.chunkOff = this.pos - this.chunkPos;\n    } else {\n      this.chunk2 = this.chunk;\n      this.chunk2Pos = this.chunkPos;\n      let nextChunk = this.input.chunk(this.pos);\n      let end = this.pos + nextChunk.length;\n      this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;\n      this.chunkPos = this.pos;\n      this.chunkOff = 0;\n    }\n  }\n  readNext() {\n    if (this.chunkOff >= this.chunk.length) {\n      this.getChunk();\n      if (this.chunkOff == this.chunk.length) return this.next = -1;\n    }\n    return this.next = this.chunk.charCodeAt(this.chunkOff);\n  }\n  /**\n  Move the stream forward N (defaults to 1) code units. Returns\n  the new value of [`next`](#lr.InputStream.next).\n  */\n  advance(n = 1) {\n    this.chunkOff += n;\n    while (this.pos + n >= this.range.to) {\n      if (this.rangeIndex == this.ranges.length - 1) return this.setDone();\n      n -= this.range.to - this.pos;\n      this.range = this.ranges[++this.rangeIndex];\n      this.pos = this.range.from;\n    }\n    this.pos += n;\n    if (this.pos >= this.token.lookAhead) this.token.lookAhead = this.pos + 1;\n    return this.readNext();\n  }\n  setDone() {\n    this.pos = this.chunkPos = this.end;\n    this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];\n    this.chunk = \"\";\n    return this.next = -1;\n  }\n  /**\n  @internal\n  */\n  reset(pos, token) {\n    if (token) {\n      this.token = token;\n      token.start = pos;\n      token.lookAhead = pos + 1;\n      token.value = token.extended = -1;\n    } else {\n      this.token = nullToken;\n    }\n    if (this.pos != pos) {\n      this.pos = pos;\n      if (pos == this.end) {\n        this.setDone();\n        return this;\n      }\n      while (pos < this.range.from) this.range = this.ranges[--this.rangeIndex];\n      while (pos >= this.range.to) this.range = this.ranges[++this.rangeIndex];\n      if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {\n        this.chunkOff = pos - this.chunkPos;\n      } else {\n        this.chunk = \"\";\n        this.chunkOff = 0;\n      }\n      this.readNext();\n    }\n    return this;\n  }\n  /**\n  @internal\n  */\n  read(from, to) {\n    if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length) return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);\n    if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length) return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);\n    if (from >= this.range.from && to <= this.range.to) return this.input.read(from, to);\n    let result = \"\";\n    for (let r of this.ranges) {\n      if (r.from >= to) break;\n      if (r.to > from) result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));\n    }\n    return result;\n  }\n}\n/**\n@internal\n*/\nclass TokenGroup {\n  constructor(data, id) {\n    this.data = data;\n    this.id = id;\n  }\n  token(input, stack) {\n    let {\n      parser\n    } = stack.p;\n    readToken(this.data, input, stack, this.id, parser.data, parser.tokenPrecTable);\n  }\n}\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/**\n@hide\n*/\nclass LocalTokenGroup {\n  constructor(data, precTable, elseToken) {\n    this.precTable = precTable;\n    this.elseToken = elseToken;\n    this.data = typeof data == \"string\" ? decodeArray(data) : data;\n  }\n  token(input, stack) {\n    let start = input.pos,\n      skipped = 0;\n    for (;;) {\n      let atEof = input.next < 0,\n        nextPos = input.resolveOffset(1, 1);\n      readToken(this.data, input, stack, 0, this.data, this.precTable);\n      if (input.token.value > -1) break;\n      if (this.elseToken == null) return;\n      if (!atEof) skipped++;\n      if (nextPos == null) break;\n      input.reset(nextPos, input.token);\n    }\n    if (skipped) {\n      input.reset(start, input.token);\n      input.acceptToken(this.elseToken, skipped);\n    }\n  }\n}\nLocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/**\n`@external tokens` declarations in the grammar should resolve to\nan instance of this class.\n*/\nclass ExternalTokenizer {\n  /**\n  Create a tokenizer. The first argument is the function that,\n  given an input stream, scans for the types of tokens it\n  recognizes at the stream's position, and calls\n  [`acceptToken`](#lr.InputStream.acceptToken) when it finds\n  one.\n  */\n  constructor(\n  /**\n  @internal\n  */\n  token, options = {}) {\n    this.token = token;\n    this.contextual = !!options.contextual;\n    this.fallback = !!options.fallback;\n    this.extend = !!options.extend;\n  }\n}\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `input.token` when it matches a token.\nfunction readToken(data, input, stack, group, precTable, precOffset) {\n  let state = 0,\n    groupMask = 1 << group,\n    {\n      dialect\n    } = stack.p.parser;\n  scan: for (;;) {\n    if ((groupMask & data[state]) == 0) break;\n    let accEnd = data[state + 1];\n    // Check whether this state can lead to a token in the current group\n    // Accept tokens in this state, possibly overwriting\n    // lower-precedence / shorter tokens\n    for (let i = state + 3; i < accEnd; i += 2) if ((data[i + 1] & groupMask) > 0) {\n      let term = data[i];\n      if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || overrides(term, input.token.value, precTable, precOffset))) {\n        input.acceptToken(term);\n        break;\n      }\n    }\n    let next = input.next,\n      low = 0,\n      high = data[state + 2];\n    // Special case for EOF\n    if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 /* Seq.End */) {\n      state = data[accEnd + high * 3 - 1];\n      continue scan;\n    }\n    // Do a binary search on the state's edges\n    for (; low < high;) {\n      let mid = low + high >> 1;\n      let index = accEnd + mid + (mid << 1);\n      let from = data[index],\n        to = data[index + 1] || 0x10000;\n      if (next < from) high = mid;else if (next >= to) low = mid + 1;else {\n        state = data[index + 2];\n        input.advance();\n        continue scan;\n      }\n    }\n    break;\n  }\n}\nfunction findOffset(data, start, term) {\n  for (let i = start, next; (next = data[i]) != 65535 /* Seq.End */; i++) if (next == term) return i - start;\n  return -1;\n}\nfunction overrides(token, prev, tableData, tableOffset) {\n  let iPrev = findOffset(tableData, tableOffset, prev);\n  return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;\n}\n\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && process.env && /\\bparse\\b/.test(process.env.LOG);\nlet stackIDs = null;\nfunction cutAt(tree, pos, side) {\n  let cursor = tree.cursor(IterMode.IncludeAnonymous);\n  cursor.moveTo(pos);\n  for (;;) {\n    if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos))) for (;;) {\n      if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError) return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Lookahead.Margin */)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Lookahead.Margin */));\n      if (side < 0 ? cursor.prevSibling() : cursor.nextSibling()) break;\n      if (!cursor.parent()) return side < 0 ? 0 : tree.length;\n    }\n  }\n}\nclass FragmentCursor {\n  constructor(fragments, nodeSet) {\n    this.fragments = fragments;\n    this.nodeSet = nodeSet;\n    this.i = 0;\n    this.fragment = null;\n    this.safeFrom = -1;\n    this.safeTo = -1;\n    this.trees = [];\n    this.start = [];\n    this.index = [];\n    this.nextFragment();\n  }\n  nextFragment() {\n    let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n    if (fr) {\n      this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;\n      this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;\n      while (this.trees.length) {\n        this.trees.pop();\n        this.start.pop();\n        this.index.pop();\n      }\n      this.trees.push(fr.tree);\n      this.start.push(-fr.offset);\n      this.index.push(0);\n      this.nextStart = this.safeFrom;\n    } else {\n      this.nextStart = 1e9;\n    }\n  }\n  // `pos` must be >= any previously given `pos` for this cursor\n  nodeAt(pos) {\n    if (pos < this.nextStart) return null;\n    while (this.fragment && this.safeTo <= pos) this.nextFragment();\n    if (!this.fragment) return null;\n    for (;;) {\n      let last = this.trees.length - 1;\n      if (last < 0) {\n        // End of tree\n        this.nextFragment();\n        return null;\n      }\n      let top = this.trees[last],\n        index = this.index[last];\n      if (index == top.children.length) {\n        this.trees.pop();\n        this.start.pop();\n        this.index.pop();\n        continue;\n      }\n      let next = top.children[index];\n      let start = this.start[last] + top.positions[index];\n      if (start > pos) {\n        this.nextStart = start;\n        return null;\n      }\n      if (next instanceof Tree) {\n        if (start == pos) {\n          if (start < this.safeFrom) return null;\n          let end = start + next.length;\n          if (end <= this.safeTo) {\n            let lookAhead = next.prop(NodeProp.lookAhead);\n            if (!lookAhead || end + lookAhead < this.fragment.to) return next;\n          }\n        }\n        this.index[last]++;\n        if (start + next.length >= Math.max(this.safeFrom, pos)) {\n          // Enter this node\n          this.trees.push(next);\n          this.start.push(start);\n          this.index.push(0);\n        }\n      } else {\n        this.index[last]++;\n        this.nextStart = start + next.length;\n      }\n    }\n  }\n}\nclass TokenCache {\n  constructor(parser, stream) {\n    this.stream = stream;\n    this.tokens = [];\n    this.mainToken = null;\n    this.actions = [];\n    this.tokens = parser.tokenizers.map(_ => new CachedToken());\n  }\n  getActions(stack) {\n    let actionIndex = 0;\n    let main = null;\n    let {\n        parser\n      } = stack.p,\n      {\n        tokenizers\n      } = parser;\n    let mask = parser.stateSlot(stack.state, 3 /* ParseState.TokenizerMask */);\n    let context = stack.curContext ? stack.curContext.hash : 0;\n    let lookAhead = 0;\n    for (let i = 0; i < tokenizers.length; i++) {\n      if ((1 << i & mask) == 0) continue;\n      let tokenizer = tokenizers[i],\n        token = this.tokens[i];\n      if (main && !tokenizer.fallback) continue;\n      if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n        this.updateCachedToken(token, tokenizer, stack);\n        token.mask = mask;\n        token.context = context;\n      }\n      if (token.lookAhead > token.end + 25 /* Lookahead.Margin */) lookAhead = Math.max(token.lookAhead, lookAhead);\n      if (token.value != 0 /* Term.Err */) {\n        let startIndex = actionIndex;\n        if (token.extended > -1) actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n        actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n        if (!tokenizer.extend) {\n          main = token;\n          if (actionIndex > startIndex) break;\n        }\n      }\n    }\n    while (this.actions.length > actionIndex) this.actions.pop();\n    if (lookAhead) stack.setLookAhead(lookAhead);\n    if (!main && stack.pos == this.stream.end) {\n      main = new CachedToken();\n      main.value = stack.p.parser.eofTerm;\n      main.start = main.end = stack.pos;\n      actionIndex = this.addActions(stack, main.value, main.end, actionIndex);\n    }\n    this.mainToken = main;\n    return this.actions;\n  }\n  getMainToken(stack) {\n    if (this.mainToken) return this.mainToken;\n    let main = new CachedToken(),\n      {\n        pos,\n        p\n      } = stack;\n    main.start = pos;\n    main.end = Math.min(pos + 1, p.stream.end);\n    main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Term.Err */;\n    return main;\n  }\n  updateCachedToken(token, tokenizer, stack) {\n    let start = this.stream.clipPos(stack.pos);\n    tokenizer.token(this.stream.reset(start, token), stack);\n    if (token.value > -1) {\n      let {\n        parser\n      } = stack.p;\n      for (let i = 0; i < parser.specialized.length; i++) if (parser.specialized[i] == token.value) {\n        let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);\n        if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n          if ((result & 1) == 0 /* Specialize.Specialize */) token.value = result >> 1;else token.extended = result >> 1;\n          break;\n        }\n      }\n    } else {\n      token.value = 0 /* Term.Err */;\n      token.end = this.stream.clipPos(start + 1);\n    }\n  }\n  putAction(action, token, end, index) {\n    // Don't add duplicate actions\n    for (let i = 0; i < index; i += 3) if (this.actions[i] == action) return index;\n    this.actions[index++] = action;\n    this.actions[index++] = token;\n    this.actions[index++] = end;\n    return index;\n  }\n  addActions(stack, token, end, index) {\n    let {\n        state\n      } = stack,\n      {\n        parser\n      } = stack.p,\n      {\n        data\n      } = parser;\n    for (let set = 0; set < 2; set++) {\n      for (let i = parser.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */);; i += 3) {\n        if (data[i] == 65535 /* Seq.End */) {\n          if (data[i + 1] == 1 /* Seq.Next */) {\n            i = pair(data, i + 2);\n          } else {\n            if (index == 0 && data[i + 1] == 2 /* Seq.Other */) index = this.putAction(pair(data, i + 2), token, end, index);\n            break;\n          }\n        }\n        if (data[i] == token) index = this.putAction(pair(data, i + 1), token, end, index);\n      }\n    }\n    return index;\n  }\n}\nclass Parse {\n  constructor(parser, input, fragments, ranges) {\n    this.parser = parser;\n    this.input = input;\n    this.ranges = ranges;\n    this.recovering = 0;\n    this.nextStackID = 0x2654; // â™”, â™•, â™–, â™—, â™˜, â™™, â™ , â™¡, â™¢, â™£, â™¤, â™¥, â™¦, â™§\n    this.minStackPos = 0;\n    this.reused = [];\n    this.stoppedAt = null;\n    this.lastBigReductionStart = -1;\n    this.lastBigReductionSize = 0;\n    this.bigReductionCount = 0;\n    this.stream = new InputStream(input, ranges);\n    this.tokens = new TokenCache(parser, this.stream);\n    this.topTerm = parser.top[1];\n    let {\n      from\n    } = ranges[0];\n    this.stacks = [Stack.start(this, parser.top[0], from)];\n    this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4 ? new FragmentCursor(fragments, parser.nodeSet) : null;\n  }\n  get parsedPos() {\n    return this.minStackPos;\n  }\n  // Move the parser forward. This will process all parse stacks at\n  // `this.pos` and try to advance them to a further position. If no\n  // stack for such a position is found, it'll start error-recovery.\n  //\n  // When the parse is finished, this will return a syntax tree. When\n  // not, it returns `null`.\n  advance() {\n    let stacks = this.stacks,\n      pos = this.minStackPos;\n    // This will hold stacks beyond `pos`.\n    let newStacks = this.stacks = [];\n    let stopped, stoppedTokens;\n    // If a large amount of reductions happened with the same start\n    // position, force the stack out of that production in order to\n    // avoid creating a tree too deep to recurse through.\n    // (This is an ugly kludge, because unfortunately there is no\n    // straightforward, cheap way to check for this happening, due to\n    // the history of reductions only being available in an\n    // expensive-to-access format in the stack buffers.)\n    if (this.bigReductionCount > 300 /* Rec.MaxLeftAssociativeReductionCount */ && stacks.length == 1) {\n      let [s] = stacks;\n      while (s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart) {}\n      this.bigReductionCount = this.lastBigReductionSize = 0;\n    }\n    // Keep advancing any stacks at `pos` until they either move\n    // forward or can't be advanced. Gather stacks that can't be\n    // advanced further in `stopped`.\n    for (let i = 0; i < stacks.length; i++) {\n      let stack = stacks[i];\n      for (;;) {\n        this.tokens.mainToken = null;\n        if (stack.pos > pos) {\n          newStacks.push(stack);\n        } else if (this.advanceStack(stack, newStacks, stacks)) {\n          continue;\n        } else {\n          if (!stopped) {\n            stopped = [];\n            stoppedTokens = [];\n          }\n          stopped.push(stack);\n          let tok = this.tokens.getMainToken(stack);\n          stoppedTokens.push(tok.value, tok.end);\n        }\n        break;\n      }\n    }\n    if (!newStacks.length) {\n      let finished = stopped && findFinished(stopped);\n      if (finished) {\n        if (verbose) console.log(\"Finish with \" + this.stackID(finished));\n        return this.stackToTree(finished);\n      }\n      if (this.parser.strict) {\n        if (verbose && stopped) console.log(\"Stuck with token \" + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : \"none\"));\n        throw new SyntaxError(\"No parse at \" + pos);\n      }\n      if (!this.recovering) this.recovering = 5 /* Rec.Distance */;\n    }\n    if (this.recovering && stopped) {\n      let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);\n      if (finished) {\n        if (verbose) console.log(\"Force-finish \" + this.stackID(finished));\n        return this.stackToTree(finished.forceAll());\n      }\n    }\n    if (this.recovering) {\n      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* Rec.MaxRemainingPerStep */;\n      if (newStacks.length > maxRemaining) {\n        newStacks.sort((a, b) => b.score - a.score);\n        while (newStacks.length > maxRemaining) newStacks.pop();\n      }\n      if (newStacks.some(s => s.reducePos > pos)) this.recovering--;\n    } else if (newStacks.length > 1) {\n      // Prune stacks that are in the same state, or that have been\n      // running without splitting for a while, to avoid getting stuck\n      // with multiple successful stacks running endlessly on.\n      outer: for (let i = 0; i < newStacks.length - 1; i++) {\n        let stack = newStacks[i];\n        for (let j = i + 1; j < newStacks.length; j++) {\n          let other = newStacks[j];\n          if (stack.sameState(other) || stack.buffer.length > 500 /* Rec.MinBufferLengthPrune */ && other.buffer.length > 500 /* Rec.MinBufferLengthPrune */) {\n            if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {\n              newStacks.splice(j--, 1);\n            } else {\n              newStacks.splice(i--, 1);\n              continue outer;\n            }\n          }\n        }\n      }\n      if (newStacks.length > 12 /* Rec.MaxStackCount */) newStacks.splice(12 /* Rec.MaxStackCount */, newStacks.length - 12 /* Rec.MaxStackCount */);\n    }\n    this.minStackPos = newStacks[0].pos;\n    for (let i = 1; i < newStacks.length; i++) if (newStacks[i].pos < this.minStackPos) this.minStackPos = newStacks[i].pos;\n    return null;\n  }\n  stopAt(pos) {\n    if (this.stoppedAt != null && this.stoppedAt < pos) throw new RangeError(\"Can't move stoppedAt forward\");\n    this.stoppedAt = pos;\n  }\n  // Returns an updated version of the given stack, or null if the\n  // stack can't advance normally. When `split` and `stacks` are\n  // given, stacks split off by ambiguous operations will be pushed to\n  // `split`, or added to `stacks` if they move `pos` forward.\n  advanceStack(stack, stacks, split) {\n    let start = stack.pos,\n      {\n        parser\n      } = this;\n    let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n    if (this.stoppedAt != null && start > this.stoppedAt) return stack.forceReduce() ? stack : null;\n    if (this.fragments) {\n      let strictCx = stack.curContext && stack.curContext.tracker.strict,\n        cxHash = strictCx ? stack.curContext.hash : 0;\n      for (let cached = this.fragments.nodeAt(start); cached;) {\n        let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n        if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {\n          stack.useNode(cached, match);\n          if (verbose) console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);\n          return true;\n        }\n        if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0) break;\n        let inner = cached.children[0];\n        if (inner instanceof Tree && cached.positions[0] == 0) cached = inner;else break;\n      }\n    }\n    let defaultReduce = parser.stateSlot(stack.state, 4 /* ParseState.DefaultReduce */);\n    if (defaultReduce > 0) {\n      stack.reduce(defaultReduce);\n      if (verbose) console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* Action.ValueMask */)})`);\n      return true;\n    }\n    if (stack.stack.length >= 8400 /* Rec.CutDepth */) {\n      while (stack.stack.length > 6000 /* Rec.CutTo */ && stack.forceReduce()) {}\n    }\n    let actions = this.tokens.getActions(stack);\n    for (let i = 0; i < actions.length;) {\n      let action = actions[i++],\n        term = actions[i++],\n        end = actions[i++];\n      let last = i == actions.length || !split;\n      let localStack = last ? stack : stack.split();\n      let main = this.tokens.mainToken;\n      localStack.apply(action, term, main ? main.start : localStack.pos, end);\n      if (verbose) console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* Action.ReduceFlag */) == 0 ? \"shift\" : `reduce of ${parser.getName(action & 65535 /* Action.ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`);\n      if (last) return true;else if (localStack.pos > start) stacks.push(localStack);else split.push(localStack);\n    }\n    return false;\n  }\n  // Advance a given stack forward as far as it will go. Returns the\n  // (possibly updated) stack if it got stuck, or null if it moved\n  // forward and was given to `pushStackDedup`.\n  advanceFully(stack, newStacks) {\n    let pos = stack.pos;\n    for (;;) {\n      if (!this.advanceStack(stack, null, null)) return false;\n      if (stack.pos > pos) {\n        pushStackDedup(stack, newStacks);\n        return true;\n      }\n    }\n  }\n  runRecovery(stacks, tokens, newStacks) {\n    let finished = null,\n      restarted = false;\n    for (let i = 0; i < stacks.length; i++) {\n      let stack = stacks[i],\n        token = tokens[i << 1],\n        tokenEnd = tokens[(i << 1) + 1];\n      let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n      if (stack.deadEnd) {\n        if (restarted) continue;\n        restarted = true;\n        stack.restart();\n        if (verbose) console.log(base + this.stackID(stack) + \" (restarted)\");\n        let done = this.advanceFully(stack, newStacks);\n        if (done) continue;\n      }\n      let force = stack.split(),\n        forceBase = base;\n      for (let j = 0; force.forceReduce() && j < 10 /* Rec.ForceReduceLimit */; j++) {\n        if (verbose) console.log(forceBase + this.stackID(force) + \" (via force-reduce)\");\n        let done = this.advanceFully(force, newStacks);\n        if (done) break;\n        if (verbose) forceBase = this.stackID(force) + \" -> \";\n      }\n      for (let insert of stack.recoverByInsert(token)) {\n        if (verbose) console.log(base + this.stackID(insert) + \" (via recover-insert)\");\n        this.advanceFully(insert, newStacks);\n      }\n      if (this.stream.end > stack.pos) {\n        if (tokenEnd == stack.pos) {\n          tokenEnd++;\n          token = 0 /* Term.Err */;\n        }\n        stack.recoverByDelete(token, tokenEnd);\n        if (verbose) console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);\n        pushStackDedup(stack, newStacks);\n      } else if (!finished || finished.score < stack.score) {\n        finished = stack;\n      }\n    }\n    return finished;\n  }\n  // Convert the stack's buffer to a syntax tree.\n  stackToTree(stack) {\n    stack.close();\n    return Tree.build({\n      buffer: StackBufferCursor.create(stack),\n      nodeSet: this.parser.nodeSet,\n      topID: this.topTerm,\n      maxBufferLength: this.parser.bufferLength,\n      reused: this.reused,\n      start: this.ranges[0].from,\n      length: stack.pos - this.ranges[0].from,\n      minRepeatType: this.parser.minRepeatTerm\n    });\n  }\n  stackID(stack) {\n    let id = (stackIDs || (stackIDs = new WeakMap())).get(stack);\n    if (!id) stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));\n    return id + stack;\n  }\n}\nfunction pushStackDedup(stack, newStacks) {\n  for (let i = 0; i < newStacks.length; i++) {\n    let other = newStacks[i];\n    if (other.pos == stack.pos && other.sameState(stack)) {\n      if (newStacks[i].score < stack.score) newStacks[i] = stack;\n      return;\n    }\n  }\n  newStacks.push(stack);\n}\nclass Dialect {\n  constructor(source, flags, disabled) {\n    this.source = source;\n    this.flags = flags;\n    this.disabled = disabled;\n  }\n  allows(term) {\n    return !this.disabled || this.disabled[term] == 0;\n  }\n}\nconst id = x => x;\n/**\nContext trackers are used to track stateful context (such as\nindentation in the Python grammar, or parent elements in the XML\ngrammar) needed by external tokenizers. You declare them in a\ngrammar file as `@context exportName from \"module\"`.\n\nContext values should be immutable, and can be updated (replaced)\non shift or reduce actions.\n\nThe export used in a `@context` declaration should be of this\ntype.\n*/\nclass ContextTracker {\n  /**\n  Define a context tracker.\n  */\n  constructor(spec) {\n    this.start = spec.start;\n    this.shift = spec.shift || id;\n    this.reduce = spec.reduce || id;\n    this.reuse = spec.reuse || id;\n    this.hash = spec.hash || (() => 0);\n    this.strict = spec.strict !== false;\n  }\n}\n/**\nHolds the parse tables for a given grammar, as generated by\n`lezer-generator`, and provides [methods](#common.Parser) to parse\ncontent with.\n*/\nclass LRParser extends Parser {\n  /**\n  @internal\n  */\n  constructor(spec) {\n    super();\n    /**\n    @internal\n    */\n    this.wrappers = [];\n    if (spec.version != 14 /* File.Version */) throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14 /* File.Version */})`);\n    let nodeNames = spec.nodeNames.split(\" \");\n    this.minRepeatTerm = nodeNames.length;\n    for (let i = 0; i < spec.repeatNodeCount; i++) nodeNames.push(\"\");\n    let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);\n    let nodeProps = [];\n    for (let i = 0; i < nodeNames.length; i++) nodeProps.push([]);\n    function setProp(nodeID, prop, value) {\n      nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);\n    }\n    if (spec.nodeProps) for (let propSpec of spec.nodeProps) {\n      let prop = propSpec[0];\n      if (typeof prop == \"string\") prop = NodeProp[prop];\n      for (let i = 1; i < propSpec.length;) {\n        let next = propSpec[i++];\n        if (next >= 0) {\n          setProp(next, prop, propSpec[i++]);\n        } else {\n          let value = propSpec[i + -next];\n          for (let j = -next; j > 0; j--) setProp(propSpec[i++], prop, value);\n          i++;\n        }\n      }\n    }\n    this.nodeSet = new NodeSet(nodeNames.map((name, i) => NodeType.define({\n      name: i >= this.minRepeatTerm ? undefined : name,\n      id: i,\n      props: nodeProps[i],\n      top: topTerms.indexOf(i) > -1,\n      error: i == 0,\n      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n    })));\n    if (spec.propSources) this.nodeSet = this.nodeSet.extend(...spec.propSources);\n    this.strict = false;\n    this.bufferLength = DefaultBufferLength;\n    let tokenArray = decodeArray(spec.tokenData);\n    this.context = spec.context;\n    this.specializerSpecs = spec.specialized || [];\n    this.specialized = new Uint16Array(this.specializerSpecs.length);\n    for (let i = 0; i < this.specializerSpecs.length; i++) this.specialized[i] = this.specializerSpecs[i].term;\n    this.specializers = this.specializerSpecs.map(getSpecializer);\n    this.states = decodeArray(spec.states, Uint32Array);\n    this.data = decodeArray(spec.stateData);\n    this.goto = decodeArray(spec.goto);\n    this.maxTerm = spec.maxTerm;\n    this.tokenizers = spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value);\n    this.topRules = spec.topRules;\n    this.dialects = spec.dialects || {};\n    this.dynamicPrecedences = spec.dynamicPrecedences || null;\n    this.tokenPrecTable = spec.tokenPrec;\n    this.termNames = spec.termNames || null;\n    this.maxNode = this.nodeSet.types.length - 1;\n    this.dialect = this.parseDialect();\n    this.top = this.topRules[Object.keys(this.topRules)[0]];\n  }\n  createParse(input, fragments, ranges) {\n    let parse = new Parse(this, input, fragments, ranges);\n    for (let w of this.wrappers) parse = w(parse, input, fragments, ranges);\n    return parse;\n  }\n  /**\n  Get a goto table entry @internal\n  */\n  getGoto(state, term, loose = false) {\n    let table = this.goto;\n    if (term >= table[0]) return -1;\n    for (let pos = table[term + 1];;) {\n      let groupTag = table[pos++],\n        last = groupTag & 1;\n      let target = table[pos++];\n      if (last && loose) return target;\n      for (let end = pos + (groupTag >> 1); pos < end; pos++) if (table[pos] == state) return target;\n      if (last) return -1;\n    }\n  }\n  /**\n  Check if this state has an action for a given terminal @internal\n  */\n  hasAction(state, terminal) {\n    let data = this.data;\n    for (let set = 0; set < 2; set++) {\n      for (let i = this.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */), next;; i += 3) {\n        if ((next = data[i]) == 65535 /* Seq.End */) {\n          if (data[i + 1] == 1 /* Seq.Next */) next = data[i = pair(data, i + 2)];else if (data[i + 1] == 2 /* Seq.Other */) return pair(data, i + 2);else break;\n        }\n        if (next == terminal || next == 0 /* Term.Err */) return pair(data, i + 1);\n      }\n    }\n    return 0;\n  }\n  /**\n  @internal\n  */\n  stateSlot(state, slot) {\n    return this.states[state * 6 /* ParseState.Size */ + slot];\n  }\n  /**\n  @internal\n  */\n  stateFlag(state, flag) {\n    return (this.stateSlot(state, 0 /* ParseState.Flags */) & flag) > 0;\n  }\n  /**\n  @internal\n  */\n  validAction(state, action) {\n    return !!this.allActions(state, a => a == action ? true : null);\n  }\n  /**\n  @internal\n  */\n  allActions(state, action) {\n    let deflt = this.stateSlot(state, 4 /* ParseState.DefaultReduce */);\n    let result = deflt ? action(deflt) : undefined;\n    for (let i = this.stateSlot(state, 1 /* ParseState.Actions */); result == null; i += 3) {\n      if (this.data[i] == 65535 /* Seq.End */) {\n        if (this.data[i + 1] == 1 /* Seq.Next */) i = pair(this.data, i + 2);else break;\n      }\n      result = action(pair(this.data, i + 1));\n    }\n    return result;\n  }\n  /**\n  Get the states that can follow this one through shift actions or\n  goto jumps. @internal\n  */\n  nextStates(state) {\n    let result = [];\n    for (let i = this.stateSlot(state, 1 /* ParseState.Actions */);; i += 3) {\n      if (this.data[i] == 65535 /* Seq.End */) {\n        if (this.data[i + 1] == 1 /* Seq.Next */) i = pair(this.data, i + 2);else break;\n      }\n      if ((this.data[i + 2] & 65536 /* Action.ReduceFlag */ >> 16) == 0) {\n        let value = this.data[i + 1];\n        if (!result.some((v, i) => i & 1 && v == value)) result.push(this.data[i], value);\n      }\n    }\n    return result;\n  }\n  /**\n  Configure the parser. Returns a new parser instance that has the\n  given settings modified. Settings not provided in `config` are\n  kept from the original parser.\n  */\n  configure(config) {\n    // Hideous reflection-based kludge to make it easy to create a\n    // slightly modified copy of a parser.\n    let copy = Object.assign(Object.create(LRParser.prototype), this);\n    if (config.props) copy.nodeSet = this.nodeSet.extend(...config.props);\n    if (config.top) {\n      let info = this.topRules[config.top];\n      if (!info) throw new RangeError(`Invalid top rule name ${config.top}`);\n      copy.top = info;\n    }\n    if (config.tokenizers) copy.tokenizers = this.tokenizers.map(t => {\n      let found = config.tokenizers.find(r => r.from == t);\n      return found ? found.to : t;\n    });\n    if (config.specializers) {\n      copy.specializers = this.specializers.slice();\n      copy.specializerSpecs = this.specializerSpecs.map((s, i) => {\n        let found = config.specializers.find(r => r.from == s.external);\n        if (!found) return s;\n        let spec = Object.assign(Object.assign({}, s), {\n          external: found.to\n        });\n        copy.specializers[i] = getSpecializer(spec);\n        return spec;\n      });\n    }\n    if (config.contextTracker) copy.context = config.contextTracker;\n    if (config.dialect) copy.dialect = this.parseDialect(config.dialect);\n    if (config.strict != null) copy.strict = config.strict;\n    if (config.wrap) copy.wrappers = copy.wrappers.concat(config.wrap);\n    if (config.bufferLength != null) copy.bufferLength = config.bufferLength;\n    return copy;\n  }\n  /**\n  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)\n  are registered for this parser.\n  */\n  hasWrappers() {\n    return this.wrappers.length > 0;\n  }\n  /**\n  Returns the name associated with a given term. This will only\n  work for all terms when the parser was generated with the\n  `--names` option. By default, only the names of tagged terms are\n  stored.\n  */\n  getName(term) {\n    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);\n  }\n  /**\n  The eof term id is always allocated directly after the node\n  types. @internal\n  */\n  get eofTerm() {\n    return this.maxNode + 1;\n  }\n  /**\n  The type of top node produced by the parser.\n  */\n  get topNode() {\n    return this.nodeSet.types[this.top[1]];\n  }\n  /**\n  @internal\n  */\n  dynamicPrecedence(term) {\n    let prec = this.dynamicPrecedences;\n    return prec == null ? 0 : prec[term] || 0;\n  }\n  /**\n  @internal\n  */\n  parseDialect(dialect) {\n    let values = Object.keys(this.dialects),\n      flags = values.map(() => false);\n    if (dialect) for (let part of dialect.split(\" \")) {\n      let id = values.indexOf(part);\n      if (id >= 0) flags[id] = true;\n    }\n    let disabled = null;\n    for (let i = 0; i < values.length; i++) if (!flags[i]) {\n      for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* Seq.End */;) (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;\n    }\n    return new Dialect(dialect, flags, disabled);\n  }\n  /**\n  Used by the output of the parser generator. Not available to\n  user code. @hide\n  */\n  static deserialize(spec) {\n    return new LRParser(spec);\n  }\n}\nfunction pair(data, off) {\n  return data[off] | data[off + 1] << 16;\n}\nfunction findFinished(stacks) {\n  let best = null;\n  for (let stack of stacks) {\n    let stopped = stack.p.stoppedAt;\n    if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(stack.state, 2 /* StateFlag.Accepting */) && (!best || best.score < stack.score)) best = stack;\n  }\n  return best;\n}\nfunction getSpecializer(spec) {\n  if (spec.external) {\n    let mask = spec.extend ? 1 /* Specialize.Extend */ : 0 /* Specialize.Specialize */;\n    return (value, stack) => spec.external(value, stack) << 1 | mask;\n  }\n  return spec.get;\n}\nexport { ContextTracker, ExternalTokenizer, InputStream, LRParser, LocalTokenGroup, Stack };", "import { ExternalTokenizer, ContextTracker, LRParser } from '@lezer/lr';\nimport { styleTags, tags } from '@lezer/highlight';\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst printKeyword = 1,\n  indent = 194,\n  dedent = 195,\n  newline$1 = 196,\n  blankLineStart = 197,\n  newlineBracketed = 198,\n  eof = 199,\n  stringContent = 200,\n  Escape = 2,\n  replacementStart = 3,\n  stringEnd = 201,\n  ParenL = 24,\n  ParenthesizedExpression = 25,\n  TupleExpression = 49,\n  ComprehensionExpression = 50,\n  BracketL = 55,\n  ArrayExpression = 56,\n  ArrayComprehensionExpression = 57,\n  BraceL = 59,\n  DictionaryExpression = 60,\n  DictionaryComprehensionExpression = 61,\n  SetExpression = 62,\n  SetComprehensionExpression = 63,\n  ArgList = 65,\n  subscript = 238,\n  String$1 = 71,\n  stringStart = 241,\n  stringStartD = 242,\n  stringStartL = 243,\n  stringStartLD = 244,\n  stringStartR = 245,\n  stringStartRD = 246,\n  stringStartRL = 247,\n  stringStartRLD = 248,\n  FormatString = 72,\n  stringStartF = 249,\n  stringStartFD = 250,\n  stringStartFL = 251,\n  stringStartFLD = 252,\n  stringStartFR = 253,\n  stringStartFRD = 254,\n  stringStartFRL = 255,\n  stringStartFRLD = 256,\n  FormatReplacement = 73,\n  nestedFormatReplacement = 77,\n  importList = 263,\n  TypeParamList = 112,\n  ParamList = 130,\n  SequencePattern = 151,\n  MappingPattern = 152,\n  PatternArgList = 155;\nconst newline = 10,\n  carriageReturn = 13,\n  space = 32,\n  tab = 9,\n  hash = 35,\n  parenOpen = 40,\n  dot = 46,\n  braceOpen = 123,\n  braceClose = 125,\n  singleQuote = 39,\n  doubleQuote = 34,\n  backslash = 92,\n  letter_o = 111,\n  letter_x = 120,\n  letter_N = 78,\n  letter_u = 117,\n  letter_U = 85;\nconst bracketed = new Set([ParenthesizedExpression, TupleExpression, ComprehensionExpression, importList, ArgList, ParamList, ArrayExpression, ArrayComprehensionExpression, subscript, SetExpression, SetComprehensionExpression, FormatString, FormatReplacement, nestedFormatReplacement, DictionaryExpression, DictionaryComprehensionExpression, SequencePattern, MappingPattern, PatternArgList, TypeParamList]);\nfunction isLineBreak(ch) {\n  return ch == newline || ch == carriageReturn;\n}\nfunction isHex(ch) {\n  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;\n}\nconst newlines = new ExternalTokenizer((input, stack) => {\n  let prev;\n  if (input.next < 0) {\n    input.acceptToken(eof);\n  } else if (stack.context.flags & cx_Bracketed) {\n    if (isLineBreak(input.next)) input.acceptToken(newlineBracketed, 1);\n  } else if (((prev = input.peek(-1)) < 0 || isLineBreak(prev)) && stack.canShift(blankLineStart)) {\n    let spaces = 0;\n    while (input.next == space || input.next == tab) {\n      input.advance();\n      spaces++;\n    }\n    if (input.next == newline || input.next == carriageReturn || input.next == hash) input.acceptToken(blankLineStart, -spaces);\n  } else if (isLineBreak(input.next)) {\n    input.acceptToken(newline$1, 1);\n  }\n}, {\n  contextual: true\n});\nconst indentation = new ExternalTokenizer((input, stack) => {\n  let context = stack.context;\n  if (context.flags) return;\n  let prev = input.peek(-1);\n  if (prev == newline || prev == carriageReturn) {\n    let depth = 0,\n      chars = 0;\n    for (;;) {\n      if (input.next == space) depth++;else if (input.next == tab) depth += 8 - depth % 8;else break;\n      input.advance();\n      chars++;\n    }\n    if (depth != context.indent && input.next != newline && input.next != carriageReturn && input.next != hash) {\n      if (depth < context.indent) input.acceptToken(dedent, -chars);else input.acceptToken(indent);\n    }\n  }\n});\n\n// Flags used in Context objects\nconst cx_Bracketed = 1,\n  cx_String = 2,\n  cx_DoubleQuote = 4,\n  cx_Long = 8,\n  cx_Raw = 16,\n  cx_Format = 32;\nfunction Context(parent, indent, flags) {\n  this.parent = parent;\n  this.indent = indent;\n  this.flags = flags;\n  this.hash = (parent ? parent.hash + parent.hash << 8 : 0) + indent + (indent << 4) + flags + (flags << 6);\n}\nconst topIndent = new Context(null, 0, 0);\nfunction countIndent(space) {\n  let depth = 0;\n  for (let i = 0; i < space.length; i++) depth += space.charCodeAt(i) == tab ? 8 - depth % 8 : 1;\n  return depth;\n}\nconst stringFlags = new Map([[stringStart, 0], [stringStartD, cx_DoubleQuote], [stringStartL, cx_Long], [stringStartLD, cx_Long | cx_DoubleQuote], [stringStartR, cx_Raw], [stringStartRD, cx_Raw | cx_DoubleQuote], [stringStartRL, cx_Raw | cx_Long], [stringStartRLD, cx_Raw | cx_Long | cx_DoubleQuote], [stringStartF, cx_Format], [stringStartFD, cx_Format | cx_DoubleQuote], [stringStartFL, cx_Format | cx_Long], [stringStartFLD, cx_Format | cx_Long | cx_DoubleQuote], [stringStartFR, cx_Format | cx_Raw], [stringStartFRD, cx_Format | cx_Raw | cx_DoubleQuote], [stringStartFRL, cx_Format | cx_Raw | cx_Long], [stringStartFRLD, cx_Format | cx_Raw | cx_Long | cx_DoubleQuote]].map(([term, flags]) => [term, flags | cx_String]));\nconst trackIndent = new ContextTracker({\n  start: topIndent,\n  reduce(context, term, _, input) {\n    if (context.flags & cx_Bracketed && bracketed.has(term) || (term == String$1 || term == FormatString) && context.flags & cx_String) return context.parent;\n    return context;\n  },\n  shift(context, term, stack, input) {\n    if (term == indent) return new Context(context, countIndent(input.read(input.pos, stack.pos)), 0);\n    if (term == dedent) return context.parent;\n    if (term == ParenL || term == BracketL || term == BraceL || term == replacementStart) return new Context(context, 0, cx_Bracketed);\n    if (stringFlags.has(term)) return new Context(context, 0, stringFlags.get(term) | context.flags & cx_Bracketed);\n    return context;\n  },\n  hash(context) {\n    return context.hash;\n  }\n});\nconst legacyPrint = new ExternalTokenizer(input => {\n  for (let i = 0; i < 5; i++) {\n    if (input.next != \"print\".charCodeAt(i)) return;\n    input.advance();\n  }\n  if (/\\w/.test(String.fromCharCode(input.next))) return;\n  for (let off = 0;; off++) {\n    let next = input.peek(off);\n    if (next == space || next == tab) continue;\n    if (next != parenOpen && next != dot && next != newline && next != carriageReturn && next != hash) input.acceptToken(printKeyword);\n    return;\n  }\n});\nconst strings = new ExternalTokenizer((input, stack) => {\n  let {\n    flags\n  } = stack.context;\n  let quote = flags & cx_DoubleQuote ? doubleQuote : singleQuote;\n  let long = (flags & cx_Long) > 0;\n  let escapes = !(flags & cx_Raw);\n  let format = (flags & cx_Format) > 0;\n  let start = input.pos;\n  for (;;) {\n    if (input.next < 0) {\n      break;\n    } else if (format && input.next == braceOpen) {\n      if (input.peek(1) == braceOpen) {\n        input.advance(2);\n      } else {\n        if (input.pos == start) {\n          input.acceptToken(replacementStart, 1);\n          return;\n        }\n        break;\n      }\n    } else if (escapes && input.next == backslash) {\n      if (input.pos == start) {\n        input.advance();\n        let escaped = input.next;\n        if (escaped >= 0) {\n          input.advance();\n          skipEscape(input, escaped);\n        }\n        input.acceptToken(Escape);\n        return;\n      }\n      break;\n    } else if (input.next == backslash && !escapes && input.peek(1) > -1) {\n      // Raw strings still ignore escaped quotes, weirdly.\n      input.advance(2);\n    } else if (input.next == quote && (!long || input.peek(1) == quote && input.peek(2) == quote)) {\n      if (input.pos == start) {\n        input.acceptToken(stringEnd, long ? 3 : 1);\n        return;\n      }\n      break;\n    } else if (input.next == newline) {\n      if (long) {\n        input.advance();\n      } else if (input.pos == start) {\n        input.acceptToken(stringEnd);\n        return;\n      }\n      break;\n    } else {\n      input.advance();\n    }\n  }\n  if (input.pos > start) input.acceptToken(stringContent);\n});\nfunction skipEscape(input, ch) {\n  if (ch == letter_o) {\n    for (let i = 0; i < 2 && input.next >= 48 && input.next <= 55; i++) input.advance();\n  } else if (ch == letter_x) {\n    for (let i = 0; i < 2 && isHex(input.next); i++) input.advance();\n  } else if (ch == letter_u) {\n    for (let i = 0; i < 4 && isHex(input.next); i++) input.advance();\n  } else if (ch == letter_U) {\n    for (let i = 0; i < 8 && isHex(input.next); i++) input.advance();\n  } else if (ch == letter_N) {\n    if (input.next == braceOpen) {\n      input.advance();\n      while (input.next >= 0 && input.next != braceClose && input.next != singleQuote && input.next != doubleQuote && input.next != newline) input.advance();\n      if (input.next == braceClose) input.advance();\n    }\n  }\n}\nconst pythonHighlighting = styleTags({\n  \"async \\\"*\\\" \\\"**\\\" FormatConversion FormatSpec\": tags.modifier,\n  \"for while if elif else try except finally return raise break continue with pass assert await yield match case\": tags.controlKeyword,\n  \"in not and or is del\": tags.operatorKeyword,\n  \"from def class global nonlocal lambda\": tags.definitionKeyword,\n  import: tags.moduleKeyword,\n  \"with as print\": tags.keyword,\n  Boolean: tags.bool,\n  None: tags.null,\n  VariableName: tags.variableName,\n  \"CallExpression/VariableName\": tags.function(tags.variableName),\n  \"FunctionDefinition/VariableName\": tags.function(tags.definition(tags.variableName)),\n  \"ClassDefinition/VariableName\": tags.definition(tags.className),\n  PropertyName: tags.propertyName,\n  \"CallExpression/MemberExpression/PropertyName\": tags.function(tags.propertyName),\n  Comment: tags.lineComment,\n  Number: tags.number,\n  String: tags.string,\n  FormatString: tags.special(tags.string),\n  Escape: tags.escape,\n  UpdateOp: tags.updateOperator,\n  \"ArithOp!\": tags.arithmeticOperator,\n  BitOp: tags.bitwiseOperator,\n  CompareOp: tags.compareOperator,\n  AssignOp: tags.definitionOperator,\n  Ellipsis: tags.punctuation,\n  At: tags.meta,\n  \"( )\": tags.paren,\n  \"[ ]\": tags.squareBracket,\n  \"{ }\": tags.brace,\n  \".\": tags.derefOperator,\n  \", ;\": tags.separator\n});\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst spec_identifier = {\n  __proto__: null,\n  await: 44,\n  or: 54,\n  and: 56,\n  in: 60,\n  not: 62,\n  is: 64,\n  if: 70,\n  else: 72,\n  lambda: 76,\n  yield: 94,\n  from: 96,\n  async: 102,\n  for: 104,\n  None: 162,\n  True: 164,\n  False: 164,\n  del: 178,\n  pass: 182,\n  break: 186,\n  continue: 190,\n  return: 194,\n  raise: 202,\n  import: 206,\n  as: 208,\n  global: 212,\n  nonlocal: 214,\n  assert: 218,\n  type: 223,\n  elif: 236,\n  while: 240,\n  try: 246,\n  except: 248,\n  finally: 250,\n  with: 254,\n  def: 258,\n  class: 268,\n  match: 279,\n  case: 285\n};\nconst parser = LRParser.deserialize({\n  version: 14,\n  states: \"##jO`QeOOP$}OSOOO&WQtO'#HUOOQS'#Co'#CoOOQS'#Cp'#CpO'vQdO'#CnO*UQtO'#HTOOQS'#HU'#HUOOQS'#DU'#DUOOQS'#HT'#HTO*rQdO'#D_O+VQdO'#DfO+gQdO'#DjO+zOWO'#DuO,VOWO'#DvO.[QtO'#GuOOQS'#Gu'#GuO'vQdO'#GtO0ZQtO'#GtOOQS'#Eb'#EbO0rQdO'#EcOOQS'#Gs'#GsO0|QdO'#GrOOQV'#Gr'#GrO1XQdO'#FYOOQS'#G^'#G^O1^QdO'#FXOOQV'#IS'#ISOOQV'#Gq'#GqOOQV'#Fq'#FqQ`QeOOO'vQdO'#CqO1lQdO'#C}O1sQdO'#DRO2RQdO'#HYO2cQtO'#EVO'vQdO'#EWOOQS'#EY'#EYOOQS'#E['#E[OOQS'#E^'#E^O2wQdO'#E`O3_QdO'#EdO3rQdO'#EfO3zQtO'#EfO1XQdO'#EiO0rQdO'#ElO1XQdO'#EnO0rQdO'#EtO0rQdO'#EwO4VQdO'#EyO4^QdO'#FOO4iQdO'#EzO0rQdO'#FOO1XQdO'#FQO1XQdO'#FVO4nQdO'#F[P4uOdO'#GpPOOO)CBd)CBdOOQS'#Ce'#CeOOQS'#Cf'#CfOOQS'#Cg'#CgOOQS'#Ch'#ChOOQS'#Ci'#CiOOQS'#Cj'#CjOOQS'#Cl'#ClO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO5TQdO'#DoOOQS,5:Y,5:YO5hQdO'#HdOOQS,5:],5:]O5uQ!fO,5:]O5zQtO,59YO1lQdO,59bO1lQdO,59bO1lQdO,59bO8jQdO,59bO8oQdO,59bO8vQdO,59jO8}QdO'#HTO:TQdO'#HSOOQS'#HS'#HSOOQS'#D['#D[O:lQdO,59aO'vQdO,59aO:zQdO,59aOOQS,59y,59yO;PQdO,5:RO'vQdO,5:ROOQS,5:Q,5:QO;_QdO,5:QO;dQdO,5:XO'vQdO,5:XO'vQdO,5:VOOQS,5:U,5:UO;uQdO,5:UO;zQdO,5:WOOOW'#Fy'#FyO<POWO,5:aOOQS,5:a,5:aO<[QdO'#HwOOOW'#Dw'#DwOOOW'#Fz'#FzO<lOWO,5:bOOQS,5:b,5:bOOQS'#F}'#F}O<zQtO,5:iO?lQtO,5=`O@VQ#xO,5=`O@vQtO,5=`OOQS,5:},5:}OA_QeO'#GWOBqQdO,5;^OOQV,5=^,5=^OB|QtO'#IPOCkQdO,5;tOOQS-E:[-E:[OOQV,5;s,5;sO4dQdO'#FQOOQV-E9o-E9oOCsQtO,59]OEzQtO,59iOFeQdO'#HVOFpQdO'#HVO1XQdO'#HVOF{QdO'#DTOGTQdO,59mOGYQdO'#HZO'vQdO'#HZO0rQdO,5=tOOQS,5=t,5=tO0rQdO'#EROOQS'#ES'#ESOGwQdO'#GPOHXQdO,58|OHXQdO,58|O*xQdO,5:oOHgQtO'#H]OOQS,5:r,5:rOOQS,5:z,5:zOHzQdO,5;OOI]QdO'#IOO1XQdO'#H}OOQS,5;Q,5;QOOQS'#GT'#GTOIqQtO,5;QOJPQdO,5;QOJUQdO'#IQOOQS,5;T,5;TOJdQdO'#H|OOQS,5;W,5;WOJuQdO,5;YO4iQdO,5;`O4iQdO,5;cOJ}QtO'#ITO'vQdO'#ITOKXQdO,5;eO4VQdO,5;eO0rQdO,5;jO1XQdO,5;lOK^QeO'#EuOLjQgO,5;fO!!kQdO'#IUO4iQdO,5;jO!!vQdO,5;lO!#OQdO,5;qO!#ZQtO,5;vO'vQdO,5;vPOOO,5=[,5=[P!#bOSO,5=[P!#jOdO,5=[O!&bQtO1G.jO!&iQtO1G.jO!)YQtO1G.jO!)dQtO1G.jO!+}QtO1G.jO!,bQtO1G.jO!,uQdO'#HcO!-TQtO'#GuO0rQdO'#HcO!-_QdO'#HbOOQS,5:Z,5:ZO!-gQdO,5:ZO!-lQdO'#HeO!-wQdO'#HeO!.[QdO,5>OOOQS'#Ds'#DsOOQS1G/w1G/wOOQS1G.|1G.|O!/[QtO1G.|O!/cQtO1G.|O1lQdO1G.|O!0OQdO1G/UOOQS'#DZ'#DZO0rQdO,59tOOQS1G.{1G.{O!0VQdO1G/eO!0gQdO1G/eO!0oQdO1G/fO'vQdO'#H[O!0tQdO'#H[O!0yQtO1G.{O!1ZQdO,59iO!2aQdO,5=zO!2qQdO,5=zO!2yQdO1G/mO!3OQtO1G/mOOQS1G/l1G/lO!3`QdO,5=uO!4VQdO,5=uO0rQdO1G/qO!4tQdO1G/sO!4yQtO1G/sO!5ZQtO1G/qOOQS1G/p1G/pOOQS1G/r1G/rOOOW-E9w-E9wOOQS1G/{1G/{O!5kQdO'#HxO0rQdO'#HxO!5|QdO,5>cOOOW-E9x-E9xOOQS1G/|1G/|OOQS-E9{-E9{O!6[Q#xO1G2zO!6{QtO1G2zO'vQdO,5<jOOQS,5<j,5<jOOQS-E9|-E9|OOQS,5<r,5<rOOQS-E:U-E:UOOQV1G0x1G0xO1XQdO'#GRO!7dQtO,5>kOOQS1G1`1G1`O!8RQdO1G1`OOQS'#DV'#DVO0rQdO,5=qOOQS,5=q,5=qO!8WQdO'#FrO!8cQdO,59oO!8kQdO1G/XO!8uQtO,5=uOOQS1G3`1G3`OOQS,5:m,5:mO!9fQdO'#GtOOQS,5<k,5<kOOQS-E9}-E9}O!9wQdO1G.hOOQS1G0Z1G0ZO!:VQdO,5=wO!:gQdO,5=wO0rQdO1G0jO0rQdO1G0jO!:xQdO,5>jO!;ZQdO,5>jO1XQdO,5>jO!;lQdO,5>iOOQS-E:R-E:RO!;qQdO1G0lO!;|QdO1G0lO!<RQdO,5>lO!<aQdO,5>lO!<oQdO,5>hO!=VQdO,5>hO!=hQdO'#EpO0rQdO1G0tO!=sQdO1G0tO!=xQgO1G0zO!AvQgO1G0}O!EqQdO,5>oO!E{QdO,5>oO!FTQtO,5>oO0rQdO1G1PO!F_QdO1G1PO4iQdO1G1UO!!vQdO1G1WOOQV,5;a,5;aO!FdQfO,5;aO!FiQgO1G1QO!JjQdO'#GZO4iQdO1G1QO4iQdO1G1QO!JzQdO,5>pO!KXQdO,5>pO1XQdO,5>pOOQV1G1U1G1UO!KaQdO'#FSO!KrQ!fO1G1WO!KzQdO1G1WOOQV1G1]1G1]O4iQdO1G1]O!LPQdO1G1]O!LXQdO'#F^OOQV1G1b1G1bO!#ZQtO1G1bPOOO1G2v1G2vP!L^OSO1G2vOOQS,5=},5=}OOQS'#Dp'#DpO0rQdO,5=}O!LfQdO,5=|O!LyQdO,5=|OOQS1G/u1G/uO!MRQdO,5>PO!McQdO,5>PO!MkQdO,5>PO!NOQdO,5>PO!N`QdO,5>POOQS1G3j1G3jOOQS7+$h7+$hO!8kQdO7+$pO#!RQdO1G.|O#!YQdO1G.|OOQS1G/`1G/`OOQS,5<`,5<`O'vQdO,5<`OOQS7+%P7+%PO#!aQdO7+%POOQS-E9r-E9rOOQS7+%Q7+%QO#!qQdO,5=vO'vQdO,5=vOOQS7+$g7+$gO#!vQdO7+%PO##OQdO7+%QO##TQdO1G3fOOQS7+%X7+%XO##eQdO1G3fO##mQdO7+%XOOQS,5<_,5<_O'vQdO,5<_O##rQdO1G3aOOQS-E9q-E9qO#$iQdO7+%]OOQS7+%_7+%_O#$wQdO1G3aO#%fQdO7+%_O#%kQdO1G3gO#%{QdO1G3gO#&TQdO7+%]O#&YQdO,5>dO#&sQdO,5>dO#&sQdO,5>dOOQS'#Dx'#DxO#'UO&jO'#DzO#'aO`O'#HyOOOW1G3}1G3}O#'fQdO1G3}O#'nQdO1G3}O#'yQ#xO7+(fO#(jQtO1G2UP#)TQdO'#GOOOQS,5<m,5<mOOQS-E:P-E:POOQS7+&z7+&zOOQS1G3]1G3]OOQS,5<^,5<^OOQS-E9p-E9pOOQS7+$s7+$sO#)bQdO,5=`O#){QdO,5=`O#*^QtO,5<aO#*qQdO1G3cOOQS-E9s-E9sOOQS7+&U7+&UO#+RQdO7+&UO#+aQdO,5<nO#+uQdO1G4UOOQS-E:Q-E:QO#,WQdO1G4UOOQS1G4T1G4TOOQS7+&W7+&WO#,iQdO7+&WOOQS,5<p,5<pO#,tQdO1G4WOOQS-E:S-E:SOOQS,5<l,5<lO#-SQdO1G4SOOQS-E:O-E:OO1XQdO'#EqO#-jQdO'#EqO#-uQdO'#IRO#-}QdO,5;[OOQS7+&`7+&`O0rQdO7+&`O#.SQgO7+&fO!JmQdO'#GXO4iQdO7+&fO4iQdO7+&iO#2QQtO,5<tO'vQdO,5<tO#2[QdO1G4ZOOQS-E:W-E:WO#2fQdO1G4ZO4iQdO7+&kO0rQdO7+&kOOQV7+&p7+&pO!KrQ!fO7+&rO!KzQdO7+&rO`QeO1G0{OOQV-E:X-E:XO4iQdO7+&lO4iQdO7+&lOOQV,5<u,5<uO#2nQdO,5<uO!JmQdO,5<uOOQV7+&l7+&lO#2yQgO7+&lO#6tQdO,5<vO#7PQdO1G4[OOQS-E:Y-E:YO#7^QdO1G4[O#7fQdO'#IWO#7tQdO'#IWO1XQdO'#IWOOQS'#IW'#IWO#8PQdO'#IVOOQS,5;n,5;nO#8XQdO,5;nO0rQdO'#FUOOQV7+&r7+&rO4iQdO7+&rOOQV7+&w7+&wO4iQdO7+&wO#8^QfO,5;xOOQV7+&|7+&|POOO7+(b7+(bO#8cQdO1G3iOOQS,5<c,5<cO#8qQdO1G3hOOQS-E9u-E9uO#9UQdO,5<dO#9aQdO,5<dO#9tQdO1G3kOOQS-E9v-E9vO#:UQdO1G3kO#:^QdO1G3kO#:nQdO1G3kO#:UQdO1G3kOOQS<<H[<<H[O#:yQtO1G1zOOQS<<Hk<<HkP#;WQdO'#FtO8vQdO1G3bO#;eQdO1G3bO#;jQdO<<HkOOQS<<Hl<<HlO#;zQdO7+)QOOQS<<Hs<<HsO#<[QtO1G1yP#<{QdO'#FsO#=YQdO7+)RO#=jQdO7+)RO#=rQdO<<HwO#=wQdO7+({OOQS<<Hy<<HyO#>nQdO,5<bO'vQdO,5<bOOQS-E9t-E9tOOQS<<Hw<<HwOOQS,5<g,5<gO0rQdO,5<gO#>sQdO1G4OOOQS-E9y-E9yO#?^QdO1G4OO<[QdO'#H{OOOO'#D{'#D{OOOO'#F|'#F|O#?oO&jO,5:fOOOW,5>e,5>eOOOW7+)i7+)iO#?zQdO7+)iO#@SQdO1G2zO#@mQdO1G2zP'vQdO'#FuO0rQdO<<IpO1XQdO1G2YP1XQdO'#GSO#AOQdO7+)pO#AaQdO7+)pOOQS<<Ir<<IrP1XQdO'#GUP0rQdO'#GQOOQS,5;],5;]O#ArQdO,5>mO#BQQdO,5>mOOQS1G0v1G0vOOQS<<Iz<<IzOOQV-E:V-E:VO4iQdO<<JQOOQV,5<s,5<sO4iQdO,5<sOOQV<<JQ<<JQOOQV<<JT<<JTO#BYQtO1G2`P#BdQdO'#GYO#BkQdO7+)uO#BuQgO<<JVO4iQdO<<JVOOQV<<J^<<J^O4iQdO<<J^O!KrQ!fO<<J^O#FpQgO7+&gOOQV<<JW<<JWO#FzQgO<<JWOOQV1G2a1G2aO1XQdO1G2aO#JuQdO1G2aO4iQdO<<JWO1XQdO1G2bP0rQdO'#G[O#KQQdO7+)vO#K_QdO7+)vOOQS'#FT'#FTO0rQdO,5>rO#KgQdO,5>rO#KrQdO,5>rO#K}QdO,5>qO#L`QdO,5>qOOQS1G1Y1G1YOOQS,5;p,5;pOOQV<<Jc<<JcO#LhQdO1G1dOOQS7+)T7+)TP#LmQdO'#FwO#L}QdO1G2OO#MbQdO1G2OO#MrQdO1G2OP#M}QdO'#FxO#N[QdO7+)VO#NlQdO7+)VO#NlQdO7+)VO#NtQdO7+)VO$ UQdO7+(|O8vQdO7+(|OOQSAN>VAN>VO$ oQdO<<LmOOQSAN>cAN>cO0rQdO1G1|O$!PQtO1G1|P$!ZQdO'#FvOOQS1G2R1G2RP$!hQdO'#F{O$!uQdO7+)jO$#`QdO,5>gOOOO-E9z-E9zOOOW<<MT<<MTO$#nQdO7+(fOOQSAN?[AN?[OOQS7+'t7+'tO$$XQdO<<M[OOQS,5<q,5<qO$$jQdO1G4XOOQS-E:T-E:TOOQVAN?lAN?lOOQV1G2_1G2_O4iQdOAN?qO$$xQgOAN?qOOQVAN?xAN?xO4iQdOAN?xOOQV<<JR<<JRO4iQdOAN?rO4iQdO7+'{OOQV7+'{7+'{O1XQdO7+'{OOQVAN?rAN?rOOQS7+'|7+'|O$(sQdO<<MbOOQS1G4^1G4^O0rQdO1G4^OOQS,5<w,5<wO$)QQdO1G4]OOQS-E:Z-E:ZOOQU'#G_'#G_O$)cQfO7+'OO$)nQdO'#F_O$*uQdO7+'jO$+VQdO7+'jOOQS7+'j7+'jO$+bQdO<<LqO$+rQdO<<LqO$+rQdO<<LqO$+zQdO'#H^OOQS<<Lh<<LhO$,UQdO<<LhOOQS7+'h7+'hOOQS'#D|'#D|OOOO1G4R1G4RO$,oQdO1G4RO$,wQdO1G4RP!=hQdO'#GVOOQVG25]G25]O4iQdOG25]OOQVG25dG25dOOQVG25^G25^OOQV<<Kg<<KgO4iQdO<<KgOOQS7+)x7+)xP$-SQdO'#G]OOQU-E:]-E:]OOQV<<Jj<<JjO$-vQtO'#FaOOQS'#Fc'#FcO$.WQdO'#FbO$.xQdO'#FbOOQS'#Fb'#FbO$.}QdO'#IYO$)nQdO'#FiO$)nQdO'#FiO$/fQdO'#FjO$)nQdO'#FkO$/mQdO'#IZOOQS'#IZ'#IZO$0[QdO,5;yOOQS<<KU<<KUO$0dQdO<<KUO$0tQdOANB]O$1UQdOANB]O$1^QdO'#H_OOQS'#H_'#H_O1sQdO'#DcO$1wQdO,5=xOOQSANBSANBSOOOO7+)m7+)mO$2`QdO7+)mOOQVLD*wLD*wOOQVANARANARO5uQ!fO'#GaO$2hQtO,5<SO$)nQdO'#FmOOQS,5<W,5<WOOQS'#Fd'#FdO$3YQdO,5;|O$3_QdO,5;|OOQS'#Fg'#FgO$)nQdO'#G`O$4PQdO,5<QO$4kQdO,5>tO$4{QdO,5>tO1XQdO,5<PO$5^QdO,5<TO$5cQdO,5<TO$)nQdO'#I[O$5hQdO'#I[O$5mQdO,5<UOOQS,5<V,5<VO0rQdO'#FpOOQU1G1e1G1eO4iQdO1G1eOOQSAN@pAN@pO$5rQdOG27wO$6SQdO,59}OOQS1G3d1G3dOOOO<<MX<<MXOOQS,5<{,5<{OOQS-E:_-E:_O$6XQtO'#FaO$6`QdO'#I]O$6nQdO'#I]O$6vQdO,5<XOOQS1G1h1G1hO$6{QdO1G1hO$7QQdO,5<zOOQS-E:^-E:^O$7lQdO,5=OO$8TQdO1G4`OOQS-E:b-E:bOOQS1G1k1G1kOOQS1G1o1G1oO$8eQdO,5>vO$)nQdO,5>vOOQS1G1p1G1pOOQS,5<[,5<[OOQU7+'P7+'PO$+zQdO1G/iO$)nQdO,5<YO$8sQdO,5>wO$8zQdO,5>wOOQS1G1s1G1sOOQS7+'S7+'SP$)nQdO'#GdO$9SQdO1G4bO$9^QdO1G4bO$9fQdO1G4bOOQS7+%T7+%TO$9tQdO1G1tO$:SQtO'#FaO$:ZQdO,5<}OOQS,5<},5<}O$:iQdO1G4cOOQS-E:a-E:aO$)nQdO,5<|O$:pQdO,5<|O$:uQdO7+)|OOQS-E:`-E:`O$;PQdO7+)|O$)nQdO,5<ZP$)nQdO'#GcO$;XQdO1G2hO$)nQdO1G2hP$;gQdO'#GbO$;nQdO<<MhO$;xQdO1G1uO$<WQdO7+(SO8vQdO'#C}O8vQdO,59bO8vQdO,59bO8vQdO,59bO$<fQtO,5=`O8vQdO1G.|O0rQdO1G/XO0rQdO7+$pP$<yQdO'#GOO'vQdO'#GtO$=WQdO,59bO$=]QdO,59bO$=dQdO,59mO$=iQdO1G/UO1sQdO'#DRO8vQdO,59j\",\n  stateData: \"$>S~O%cOS%^OSSOS%]PQ~OPdOVaOfoOhYOopOs!POvqO!PrO!Q{O!T!SO!U!RO!XZO!][O!h`O!r`O!s`O!t`O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO#l!QO#o!TO#s!UO#u!VO#z!WO#}hO$P!XO%oRO%pRO%tSO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O~O%]!YO~OV!aO_!aOa!bOh!iO!X!kO!f!mO%j![O%k!]O%l!^O%m!_O%n!_O%o!`O%p!`O%q!aO%r!aO%s!aO~Ok%xXl%xXm%xXn%xXo%xXp%xXs%xXz%xX{%xX!x%xX#g%xX%[%xX%_%xX%z%xXg%xX!T%xX!U%xX%{%xX!W%xX![%xX!Q%xX#[%xXt%xX!m%xX~P%SOfoOhYO!XZO!][O!h`O!r`O!s`O!t`O%oRO%pRO%tSO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O~Oz%wX{%wX#g%wX%[%wX%_%wX%z%wX~Ok!pOl!qOm!oOn!oOo!rOp!sOs!tO!x%wX~P)pOV!zOg!|Oo0cOv0qO!PrO~P'vOV#OOo0cOv0qO!W#PO~P'vOV#SOa#TOo0cOv0qO![#UO~P'vOQ#XO%`#XO%a#ZO~OQ#^OR#[O%`#^O%a#`O~OV%iX_%iXa%iXh%iXk%iXl%iXm%iXn%iXo%iXp%iXs%iXz%iX!X%iX!f%iX%j%iX%k%iX%l%iX%m%iX%n%iX%o%iX%p%iX%q%iX%r%iX%s%iXg%iX!T%iX!U%iX~O&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O{%iX!x%iX#g%iX%[%iX%_%iX%z%iX%{%iX!W%iX![%iX!Q%iX#[%iXt%iX!m%iX~P,eOz#dO{%hX!x%hX#g%hX%[%hX%_%hX%z%hX~Oo0cOv0qO~P'vO#g#gO%[#iO%_#iO~O%uWO~O!T#nO#u!VO#z!WO#}hO~OopO~P'vOV#sOa#tO%uWO{wP~OV#xOo0cOv0qO!Q#yO~P'vO{#{O!x$QO%z#|O#g!yX%[!yX%_!yX~OV#xOo0cOv0qO#g#SX%[#SX%_#SX~P'vOo0cOv0qO#g#WX%[#WX%_#WX~P'vOh$WO%uWO~O!f$YO!r$YO%uWO~OV$eO~P'vO!U$gO#s$hO#u$iO~O{$jO~OV$qO~P'vOS$sO%[$rO%_$rO%c$tO~OV$}Oa$}Og%POo0cOv0qO~P'vOo0cOv0qO{%SO~P'vO&Y%UO~Oa!bOh!iO!X!kO!f!mOVba_bakbalbambanbaobapbasbazba{ba!xba#gba%[ba%_ba%jba%kba%lba%mba%nba%oba%pba%qba%rba%sba%zbagba!Tba!Uba%{ba!Wba![ba!Qba#[batba!mba~On%ZO~Oo%ZO~P'vOo0cO~P'vOk0eOl0fOm0dOn0dOo0mOp0nOs0rOg%wX!T%wX!U%wX%{%wX!W%wX![%wX!Q%wX#[%wX!m%wX~P)pO%{%]Og%vXz%vX!T%vX!U%vX!W%vX{%vX~Og%_Oz%`O!T%dO!U%cO~Og%_O~Oz%gO!T%dO!U%cO!W&SX~O!W%kO~Oz%lO{%nO!T%dO!U%cO![%}X~O![%rO~O![%sO~OQ#XO%`#XO%a%uO~OV%wOo0cOv0qO!PrO~P'vOQ#^OR#[O%`#^O%a%zO~OV!qa_!qaa!qah!qak!qal!qam!qan!qao!qap!qas!qaz!qa{!qa!X!qa!f!qa!x!qa#g!qa%[!qa%_!qa%j!qa%k!qa%l!qa%m!qa%n!qa%o!qa%p!qa%q!qa%r!qa%s!qa%z!qag!qa!T!qa!U!qa%{!qa!W!qa![!qa!Q!qa#[!qat!qa!m!qa~P#yOz%|O{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~P%SOV&OOopOvqO{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~P'vOz%|O{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~OPdOVaOopOvqO!PrO!Q{O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO#g$zX%[$zX%_$zX~P'vO#g#gO%[&TO%_&TO~O!f&UOh&sX%[&sXz&sX#[&sX#g&sX%_&sX#Z&sXg&sX~Oh!iO%[&WO~Okealeameaneaoeapeaseazea{ea!xea#gea%[ea%_ea%zeagea!Tea!Uea%{ea!Wea![ea!Qea#[eatea!mea~P%SOsqazqa{qa#gqa%[qa%_qa%zqa~Ok!pOl!qOm!oOn!oOo!rOp!sO!xqa~PEcO%z&YOz%yX{%yX~O%uWOz%yX{%yX~Oz&]O{wX~O{&_O~Oz%lO#g%}X%[%}X%_%}Xg%}X{%}X![%}X!m%}X%z%}X~OV0lOo0cOv0qO!PrO~P'vO%z#|O#gUa%[Ua%_Ua~Oz&hO#g&PX%[&PX%_&PXn&PX~P%SOz&kO!Q&jO#g#Wa%[#Wa%_#Wa~Oz&lO#[&nO#g&rX%[&rX%_&rXg&rX~O!f$YO!r$YO#Z&qO%uWO~O#Z&qO~Oz&sO#g&tX%[&tX%_&tX~Oz&uO#g&pX%[&pX%_&pX{&pX~O!X&wO%z&xO~Oz&|On&wX~P%SOn'PO~OPdOVaOopOvqO!PrO!Q{O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO%['UO~P'vOt'YO#p'WO#q'XOP#naV#naf#nah#nao#nas#nav#na!P#na!Q#na!T#na!U#na!X#na!]#na!h#na!r#na!s#na!t#na!{#na!}#na#P#na#R#na#T#na#X#na#Z#na#^#na#_#na#a#na#c#na#l#na#o#na#s#na#u#na#z#na#}#na$P#na%X#na%o#na%p#na%t#na%u#na&Z#na&[#na&]#na&^#na&_#na&`#na&a#na&b#na&c#na&d#na&e#na&f#na&g#na&h#na&i#na&j#na%Z#na%_#na~Oz'ZO#[']O{&xX~Oh'_O!X&wO~Oh!iO{$jO!X&wO~O{'eO~P%SO%['hO%_'hO~OS'iO%['hO%_'hO~OV!aO_!aOa!bOh!iO!X!kO!f!mO%l!^O%m!_O%n!_O%o!`O%p!`O%q!aO%r!aO%s!aOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~O%k!]O~P!#uO%kWi~P!#uOV!aO_!aOa!bOh!iO!X!kO!f!mO%o!`O%p!`O%q!aO%r!aO%s!aOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%kWi%lWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~O%m!_O%n!_O~P!&pO%mWi%nWi~P!&pOa!bOh!iO!X!kO!f!mOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%kWi%lWi%mWi%nWi%oWi%pWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~OV!aO_!aO%q!aO%r!aO%s!aO~P!)nOVWi_Wi%qWi%rWi%sWi~P!)nO!T%dO!U%cOg&VXz&VX~O%z'kO%{'kO~P,eOz'mOg&UX~Og'oO~Oz'pO{'rO!W&XX~Oo0cOv0qOz'pO{'sO!W&XX~P'vO!W'uO~Om!oOn!oOo!rOp!sOkjisjizji{ji!xji#gji%[ji%_ji%zji~Ol!qO~P!.aOlji~P!.aOk0eOl0fOm0dOn0dOo0mOp0nO~Ot'wO~P!/jOV'|Og'}Oo0cOv0qO~P'vOg'}Oz(OO~Og(QO~O!U(SO~Og(TOz(OO!T%dO!U%cO~P%SOk0eOl0fOm0dOn0dOo0mOp0nOgqa!Tqa!Uqa%{qa!Wqa![qa!Qqa#[qatqa!mqa~PEcOV'|Oo0cOv0qO!W&Sa~P'vOz(WO!W&Sa~O!W(XO~Oz(WO!T%dO!U%cO!W&Sa~P%SOV(]Oo0cOv0qO![%}a#g%}a%[%}a%_%}ag%}a{%}a!m%}a%z%}a~P'vOz(^O![%}a#g%}a%[%}a%_%}ag%}a{%}a!m%}a%z%}a~O![(aO~Oz(^O!T%dO!U%cO![%}a~P%SOz(dO!T%dO!U%cO![&Ta~P%SOz(gO{&lX![&lX!m&lX%z&lX~O{(kO![(mO!m(nO%z(jO~OV&OOopOvqO{%hi!x%hi#g%hi%[%hi%_%hi%z%hi~P'vOz(pO{%hi!x%hi#g%hi%[%hi%_%hi%z%hi~O!f&UOh&sa%[&saz&sa#[&sa#g&sa%_&sa#Z&sag&sa~O%[(uO~OV#sOa#tO%uWO~Oz&]O{wa~OopOvqO~P'vOz(^O#g%}a%[%}a%_%}ag%}a{%}a![%}a!m%}a%z%}a~P%SOz(zO#g%hX%[%hX%_%hX%z%hX~O%z#|O#gUi%[Ui%_Ui~O#g&Pa%[&Pa%_&Pan&Pa~P'vOz(}O#g&Pa%[&Pa%_&Pan&Pa~O%uWO#g&ra%[&ra%_&rag&ra~Oz)SO#g&ra%[&ra%_&rag&ra~Og)VO~OV)WOh$WO%uWO~O#Z)XO~O%uWO#g&ta%[&ta%_&ta~Oz)ZO#g&ta%[&ta%_&ta~Oo0cOv0qO#g&pa%[&pa%_&pa{&pa~P'vOz)^O#g&pa%[&pa%_&pa{&pa~OV)`Oa)`O%uWO~O%z)eO~Ot)hO#j)gOP#hiV#hif#hih#hio#his#hiv#hi!P#hi!Q#hi!T#hi!U#hi!X#hi!]#hi!h#hi!r#hi!s#hi!t#hi!{#hi!}#hi#P#hi#R#hi#T#hi#X#hi#Z#hi#^#hi#_#hi#a#hi#c#hi#l#hi#o#hi#s#hi#u#hi#z#hi#}#hi$P#hi%X#hi%o#hi%p#hi%t#hi%u#hi&Z#hi&[#hi&]#hi&^#hi&_#hi&`#hi&a#hi&b#hi&c#hi&d#hi&e#hi&f#hi&g#hi&h#hi&i#hi&j#hi%Z#hi%_#hi~Ot)iOP#kiV#kif#kih#kio#kis#kiv#ki!P#ki!Q#ki!T#ki!U#ki!X#ki!]#ki!h#ki!r#ki!s#ki!t#ki!{#ki!}#ki#P#ki#R#ki#T#ki#X#ki#Z#ki#^#ki#_#ki#a#ki#c#ki#l#ki#o#ki#s#ki#u#ki#z#ki#}#ki$P#ki%X#ki%o#ki%p#ki%t#ki%u#ki&Z#ki&[#ki&]#ki&^#ki&_#ki&`#ki&a#ki&b#ki&c#ki&d#ki&e#ki&f#ki&g#ki&h#ki&i#ki&j#ki%Z#ki%_#ki~OV)kOn&wa~P'vOz)lOn&wa~Oz)lOn&wa~P%SOn)pO~O%Y)tO~Ot)wO#p'WO#q)vOP#niV#nif#nih#nio#nis#niv#ni!P#ni!Q#ni!T#ni!U#ni!X#ni!]#ni!h#ni!r#ni!s#ni!t#ni!{#ni!}#ni#P#ni#R#ni#T#ni#X#ni#Z#ni#^#ni#_#ni#a#ni#c#ni#l#ni#o#ni#s#ni#u#ni#z#ni#}#ni$P#ni%X#ni%o#ni%p#ni%t#ni%u#ni&Z#ni&[#ni&]#ni&^#ni&_#ni&`#ni&a#ni&b#ni&c#ni&d#ni&e#ni&f#ni&g#ni&h#ni&i#ni&j#ni%Z#ni%_#ni~OV)zOo0cOv0qO{$jO~P'vOo0cOv0qO{&xa~P'vOz*OO{&xa~OV*SOa*TOg*WO%q*UO%uWO~O{$jO&{*YO~Oh'_O~Oh!iO{$jO~O%[*_O~O%[*aO%_*aO~OV$}Oa$}Oo0cOv0qOg&Ua~P'vOz*dOg&Ua~Oo0cOv0qO{*gO!W&Xa~P'vOz*hO!W&Xa~Oo0cOv0qOz*hO{*kO!W&Xa~P'vOo0cOv0qOz*hO!W&Xa~P'vOz*hO{*kO!W&Xa~Om0dOn0dOo0mOp0nOgjikjisjizji!Tji!Uji%{ji!Wji{ji![ji#gji%[ji%_ji!Qji#[jitji!mji%zji~Ol0fO~P!NkOlji~P!NkOV'|Og*pOo0cOv0qO~P'vOn*rO~Og*pOz*tO~Og*uO~OV'|Oo0cOv0qO!W&Si~P'vOz*vO!W&Si~O!W*wO~OV(]Oo0cOv0qO![%}i#g%}i%[%}i%_%}ig%}i{%}i!m%}i%z%}i~P'vOz*zO!T%dO!U%cO![&Ti~Oz*}O![%}i#g%}i%[%}i%_%}ig%}i{%}i!m%}i%z%}i~O![+OO~Oa+QOo0cOv0qO![&Ti~P'vOz*zO![&Ti~O![+SO~OV+UOo0cOv0qO{&la![&la!m&la%z&la~P'vOz+VO{&la![&la!m&la%z&la~O!]+YO&n+[O![!nX~O![+^O~O{(kO![+_O~O{(kO![+_O!m+`O~OV&OOopOvqO{%hq!x%hq#g%hq%[%hq%_%hq%z%hq~P'vOz$ri{$ri!x$ri#g$ri%[$ri%_$ri%z$ri~P%SOV&OOopOvqO~P'vOV&OOo0cOv0qO#g%ha%[%ha%_%ha%z%ha~P'vOz+aO#g%ha%[%ha%_%ha%z%ha~Oz$ia#g$ia%[$ia%_$ian$ia~P%SO#g&Pi%[&Pi%_&Pin&Pi~P'vOz+dO#g#Wq%[#Wq%_#Wq~O#[+eOz$va#g$va%[$va%_$vag$va~O%uWO#g&ri%[&ri%_&rig&ri~Oz+gO#g&ri%[&ri%_&rig&ri~OV+iOh$WO%uWO~O%uWO#g&ti%[&ti%_&ti~Oo0cOv0qO#g&pi%[&pi%_&pi{&pi~P'vO{#{Oz#eX!W#eX~Oz+mO!W&uX~O!W+oO~Ot+rO#j)gOP#hqV#hqf#hqh#hqo#hqs#hqv#hq!P#hq!Q#hq!T#hq!U#hq!X#hq!]#hq!h#hq!r#hq!s#hq!t#hq!{#hq!}#hq#P#hq#R#hq#T#hq#X#hq#Z#hq#^#hq#_#hq#a#hq#c#hq#l#hq#o#hq#s#hq#u#hq#z#hq#}#hq$P#hq%X#hq%o#hq%p#hq%t#hq%u#hq&Z#hq&[#hq&]#hq&^#hq&_#hq&`#hq&a#hq&b#hq&c#hq&d#hq&e#hq&f#hq&g#hq&h#hq&i#hq&j#hq%Z#hq%_#hq~On$|az$|a~P%SOV)kOn&wi~P'vOz+yOn&wi~Oz,TO{$jO#[,TO~O#q,VOP#nqV#nqf#nqh#nqo#nqs#nqv#nq!P#nq!Q#nq!T#nq!U#nq!X#nq!]#nq!h#nq!r#nq!s#nq!t#nq!{#nq!}#nq#P#nq#R#nq#T#nq#X#nq#Z#nq#^#nq#_#nq#a#nq#c#nq#l#nq#o#nq#s#nq#u#nq#z#nq#}#nq$P#nq%X#nq%o#nq%p#nq%t#nq%u#nq&Z#nq&[#nq&]#nq&^#nq&_#nq&`#nq&a#nq&b#nq&c#nq&d#nq&e#nq&f#nq&g#nq&h#nq&i#nq&j#nq%Z#nq%_#nq~O#[,WOz%Oa{%Oa~Oo0cOv0qO{&xi~P'vOz,YO{&xi~O{#{O%z,[Og&zXz&zX~O%uWOg&zXz&zX~Oz,`Og&yX~Og,bO~O%Y,eO~O!T%dO!U%cOg&Viz&Vi~OV$}Oa$}Oo0cOv0qOg&Ui~P'vO{,hOz$la!W$la~Oo0cOv0qO{,iOz$la!W$la~P'vOo0cOv0qO{*gO!W&Xi~P'vOz,lO!W&Xi~Oo0cOv0qOz,lO!W&Xi~P'vOz,lO{,oO!W&Xi~Og$hiz$hi!W$hi~P%SOV'|Oo0cOv0qO~P'vOn,qO~OV'|Og,rOo0cOv0qO~P'vOV'|Oo0cOv0qO!W&Sq~P'vOz$gi![$gi#g$gi%[$gi%_$gig$gi{$gi!m$gi%z$gi~P%SOV(]Oo0cOv0qO~P'vOa+QOo0cOv0qO![&Tq~P'vOz,sO![&Tq~O![,tO~OV(]Oo0cOv0qO![%}q#g%}q%[%}q%_%}qg%}q{%}q!m%}q%z%}q~P'vO{,uO~OV+UOo0cOv0qO{&li![&li!m&li%z&li~P'vOz,zO{&li![&li!m&li%z&li~O!]+YO&n+[O![!na~O{(kO![,}O~OV&OOo0cOv0qO#g%hi%[%hi%_%hi%z%hi~P'vOz-OO#g%hi%[%hi%_%hi%z%hi~O%uWO#g&rq%[&rq%_&rqg&rq~Oz-RO#g&rq%[&rq%_&rqg&rq~OV)`Oa)`O%uWO!W&ua~Oz-TO!W&ua~On$|iz$|i~P%SOV)kO~P'vOV)kOn&wq~P'vOt-XOP#myV#myf#myh#myo#mys#myv#my!P#my!Q#my!T#my!U#my!X#my!]#my!h#my!r#my!s#my!t#my!{#my!}#my#P#my#R#my#T#my#X#my#Z#my#^#my#_#my#a#my#c#my#l#my#o#my#s#my#u#my#z#my#}#my$P#my%X#my%o#my%p#my%t#my%u#my&Z#my&[#my&]#my&^#my&_#my&`#my&a#my&b#my&c#my&d#my&e#my&f#my&g#my&h#my&i#my&j#my%Z#my%_#my~O%Z-]O%_-]O~P`O#q-^OP#nyV#nyf#nyh#nyo#nys#nyv#ny!P#ny!Q#ny!T#ny!U#ny!X#ny!]#ny!h#ny!r#ny!s#ny!t#ny!{#ny!}#ny#P#ny#R#ny#T#ny#X#ny#Z#ny#^#ny#_#ny#a#ny#c#ny#l#ny#o#ny#s#ny#u#ny#z#ny#}#ny$P#ny%X#ny%o#ny%p#ny%t#ny%u#ny&Z#ny&[#ny&]#ny&^#ny&_#ny&`#ny&a#ny&b#ny&c#ny&d#ny&e#ny&f#ny&g#ny&h#ny&i#ny&j#ny%Z#ny%_#ny~Oz-aO{$jO#[-aO~Oo0cOv0qO{&xq~P'vOz-dO{&xq~O%z,[Og&zaz&za~O{#{Og&zaz&za~OV*SOa*TO%q*UO%uWOg&ya~Oz-hOg&ya~O$S-lO~OV$}Oa$}Oo0cOv0qO~P'vOo0cOv0qO{-mOz$li!W$li~P'vOo0cOv0qOz$li!W$li~P'vO{-mOz$li!W$li~Oo0cOv0qO{*gO~P'vOo0cOv0qO{*gO!W&Xq~P'vOz-pO!W&Xq~Oo0cOv0qOz-pO!W&Xq~P'vOs-sO!T%dO!U%cOg&Oq!W&Oq![&Oqz&Oq~P!/jOa+QOo0cOv0qO![&Ty~P'vOz$ji![$ji~P%SOa+QOo0cOv0qO~P'vOV+UOo0cOv0qO~P'vOV+UOo0cOv0qO{&lq![&lq!m&lq%z&lq~P'vO{(kO![-xO!m-yO%z-wO~OV&OOo0cOv0qO#g%hq%[%hq%_%hq%z%hq~P'vO%uWO#g&ry%[&ry%_&ryg&ry~OV)`Oa)`O%uWO!W&ui~Ot-}OP#m!RV#m!Rf#m!Rh#m!Ro#m!Rs#m!Rv#m!R!P#m!R!Q#m!R!T#m!R!U#m!R!X#m!R!]#m!R!h#m!R!r#m!R!s#m!R!t#m!R!{#m!R!}#m!R#P#m!R#R#m!R#T#m!R#X#m!R#Z#m!R#^#m!R#_#m!R#a#m!R#c#m!R#l#m!R#o#m!R#s#m!R#u#m!R#z#m!R#}#m!R$P#m!R%X#m!R%o#m!R%p#m!R%t#m!R%u#m!R&Z#m!R&[#m!R&]#m!R&^#m!R&_#m!R&`#m!R&a#m!R&b#m!R&c#m!R&d#m!R&e#m!R&f#m!R&g#m!R&h#m!R&i#m!R&j#m!R%Z#m!R%_#m!R~Oo0cOv0qO{&xy~P'vOV*SOa*TO%q*UO%uWOg&yi~O$S-lO%Z.VO%_.VO~OV.aOh._O!X.^O!].`O!h.YO!s.[O!t.[O%p.XO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O~Oo0cOv0qOz$lq!W$lq~P'vO{.fOz$lq!W$lq~Oo0cOv0qO{*gO!W&Xy~P'vOz.gO!W&Xy~Oo0cOv.kO~P'vOs-sO!T%dO!U%cOg&Oy!W&Oy![&Oyz&Oy~P!/jO{(kO![.nO~O{(kO![.nO!m.oO~OV*SOa*TO%q*UO%uWO~Oh.tO!f.rOz$TX#[$TX%j$TXg$TX~Os$TX{$TX!W$TX![$TX~P$-bO%o.vO%p.vOs$UXz$UX{$UX#[$UX%j$UX!W$UXg$UX![$UX~O!h.xO~Oz.|O#[/OO%j.yOs&|X{&|X!W&|Xg&|X~Oa/RO~P$)zOh.tOs&}Xz&}X{&}X#[&}X%j&}X!W&}Xg&}X![&}X~Os/VO{$jO~Oo0cOv0qOz$ly!W$ly~P'vOo0cOv0qO{*gO!W&X!R~P'vOz/ZO!W&X!R~Og&RXs&RX!T&RX!U&RX!W&RX![&RXz&RX~P!/jOs-sO!T%dO!U%cOg&Qa!W&Qa![&Qaz&Qa~O{(kO![/^O~O!f.rOh$[as$[az$[a{$[a#[$[a%j$[a!W$[ag$[a![$[a~O!h/eO~O%o.vO%p.vOs$Uaz$Ua{$Ua#[$Ua%j$Ua!W$Uag$Ua![$Ua~O%j.yOs$Yaz$Ya{$Ya#[$Ya!W$Yag$Ya![$Ya~Os&|a{&|a!W&|ag&|a~P$)nOz/jOs&|a{&|a!W&|ag&|a~O!W/mO~Og/mO~O{/oO~O![/pO~Oo0cOv0qO{*gO!W&X!Z~P'vO{/sO~O%z/tO~P$-bOz/uO#[/OO%j.yOg'PX~Oz/uOg'PX~Og/wO~O!h/xO~O#[/OOs%Saz%Sa{%Sa%j%Sa!W%Sag%Sa![%Sa~O#[/OO%j.yOs%Waz%Wa{%Wa!W%Wag%Wa~Os&|i{&|i!W&|ig&|i~P$)nOz/zO#[/OO%j.yO!['Oa~Og'Pa~P$)nOz0SOg'Pa~Oa0UO!['Oi~P$)zOz0WO!['Oi~Oz0WO#[/OO%j.yO!['Oi~O#[/OO%j.yOg$biz$bi~O%z0ZO~P$-bO#[/OO%j.yOg%Vaz%Va~Og'Pi~P$)nO{0^O~Oa0UO!['Oq~P$)zOz0`O!['Oq~O#[/OO%j.yOz%Ui![%Ui~Oa0UO~P$)zOa0UO!['Oy~P$)zO#[/OO%j.yOg$ciz$ci~O#[/OO%j.yOz%Uq![%Uq~Oz+aO#g%ha%[%ha%_%ha%z%ha~P%SOV&OOo0cOv0qO~P'vOn0hO~Oo0hO~P'vO{0iO~Ot0jO~P!/jO&]&Z&j&h&i&g&f&d&e&c&b&`&a&_&^&[%u~\",\n  goto: \"!=j'QPPPPPP'RP'Z*s+[+t,_,y-fP.SP'Z.r.r'ZPPP'Z2[PPPPPP2[5PPP5PP7b7k=sPP=v>h>kPP'Z'ZPP>zPP'Z'ZPP'Z'Z'Z'Z'Z?O?w'ZP?zP@QDXGuGyPG|HWH['ZPPPH_Hk'RP'R'RP'RP'RP'RP'RP'R'R'RP'RPP'RPP'RP'RPHqH}IVPI^IdPI^PI^I^PPPI^PKrPK{LVL]KrPI^LfPI^PLmLsPLwM]MzNeLwLwNkNxLwLwLwLw! ^! d! g! l! o! y!!P!!]!!o!!u!#P!#V!#s!#y!$P!$Z!$a!$g!$y!%T!%Z!%a!%k!%q!%w!%}!&T!&Z!&e!&k!&u!&{!'U!'[!'k!'s!'}!(UPPPPPPPPPPP!([!(_!(e!(n!(x!)TPPPPPPPPPPPP!-u!/Z!3^!6oPP!6w!7W!7a!8Y!8P!8c!8i!8l!8o!8r!8z!9jPPPPPPPPPPPPPPPPP!9m!9q!9wP!:]!:a!:m!:v!;S!;j!;m!;p!;v!;|!<S!<VP!<_!<h!=d!=g]eOn#g$j)t,P'}`OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0r{!cQ#c#p$R$d$p%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g}!dQ#c#p$R$d$p$u%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!P!eQ#c#p$R$d$p$u$v%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!R!fQ#c#p$R$d$p$u$v$w%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!T!gQ#c#p$R$d$p$u$v$w$x%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!V!hQ#c#p$R$d$p$u$v$w$x$y%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!Z!hQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g'}TOTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0r&eVOYZ[dnprxy}!P!Q!U!i!k!o!p!q!s!t#[#d#g#y#{#}$Q$h$j$}%S%Z%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0n0r%oXOYZ[dnrxy}!P!Q!U!i!k#[#d#g#y#{#}$Q$h$j$}%S%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,s,u,w,y,z-O-d-f-m-p.f.g/V/Z0i0j0kQ#vqQ/[.kR0o0q't`OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rh#jhz{$W$Z&l&q)S)X+f+g-RW#rq&].k0qQ$]|Q$a!OQ$n!VQ$o!WW$|!i'm*d,gS&[#s#tQ'S$iQ(s&UQ)U&nU)Y&s)Z+jW)a&w+m-T-{Q*Q']W*R'_,`-h.TQ+l)`S,_*S*TQ-Q+eQ-_,TQ-c,WQ.R-al.W-l.^._.a.z.|/R/j/o/t/y0U0Z0^Q/S.`Q/a.tQ/l/OU0P/u0S0[X0V/z0W0_0`R&Z#r!_!wYZ!P!Q!k%S%`%g'p'r's(O(W)g*g*h*k*q*t*v,h,i,k,l,o-m-p.f.g/ZR%^!vQ!{YQ%x#[Q&d#}Q&g$QR,{+YT.j-s/s!Y!jQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0gQ&X#kQ'c$oR*^'dR'l$|Q%V!mR/_.r'|_OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rS#a_#b!P.[-l.^._.`.a.t.z.|/R/j/o/t/u/y/z0S0U0W0Z0[0^0_0`'|_OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rT#a_#bT#^^#_R(o%xa(l%x(n(o+`,{-y-z.oT+[(k+]R-z,{Q$PsQ+l)aQ,^*RR-e,_X#}s$O$P&fQ&y$aQ'a$nQ'd$oR)s'SQ)b&wV-S+m-T-{ZgOn$j)t,PXkOn)t,PQ$k!TQ&z$bQ&{$cQ'^$mQ'b$oQ)q'RQ)x'WQ){'XQ)|'YQ*Z'`S*]'c'dQ+s)gQ+u)hQ+v)iQ+z)oS+|)r*[Q,Q)vQ,R)wS,S)y)zQ,d*^Q-V+rQ-W+tQ-Y+{S-Z+},OQ-`,UQ-b,VQ-|-XQ.O-[Q.P-^Q.Q-_Q.p-}Q.q.RQ/W.dR/r/XWkOn)t,PR#mjQ'`$nS)r'S'aR,O)sQ,]*RR-f,^Q*['`Q+})rR-[,OZiOjn)t,PQ'f$pR*`'gT-j,e-ku.c-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^t.c-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^Q/S.`X0V/z0W0_0`!P.Z-l.^._.`.a.t.z.|/R/j/o/t/u/y/z0S0U0W0Z0[0^0_0`Q.w.YR/f.xg.z.].{/b/i/n/|0O0Q0]0a0bu.b-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^X.u.W.b/a0PR/c.tV0R/u0S0[R/X.dQnOS#on,PR,P)tQ&^#uR(x&^S%m#R#wS(_%m(bT(b%p&`Q%a!yQ%h!}W(P%a%h(U(YQ(U%eR(Y%jQ&i$RR)O&iQ(e%qQ*{(`T+R(e*{Q'n%OR*e'nS'q%R%SY*i'q*j,m-q.hU*j'r's'tU,m*k*l*mS-q,n,oR.h-rQ#Y]R%t#YQ#_^R%y#_Q(h%vS+W(h+XR+X(iQ+](kR,|+]Q#b_R%{#bQ#ebQ%}#cW&Q#e%}({+bQ({&cR+b0gQ$OsS&e$O&fR&f$PQ&v$_R)_&vQ&V#jR(t&VQ&m$VS)T&m+hR+h)UQ$Z{R&p$ZQ&t$]R)[&tQ+n)bR-U+nQ#hfR&S#hQ)f&zR+q)fQ&}$dS)m&})nR)n'OQ'V$kR)u'VQ'[$lS*P'[,ZR,Z*QQ,a*VR-i,aWjOn)t,PR#ljQ-k,eR.U-kd.{.]/b/i/n/|0O0Q0]0a0bR/h.{U.s.W/a0PR/`.sQ/{/nS0X/{0YR0Y/|S/v/b/cR0T/vQ.}.]R/k.}R!ZPXmOn)t,PWlOn)t,PR'T$jYfOn$j)t,PR&R#g[sOn#g$j)t,PR&d#}&dQOYZ[dnprxy}!P!Q!U!i!k!o!p!q!s!t#[#d#g#y#{#}$Q$h$j$}%S%Z%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0n0rQ!nTQ#caQ#poU$Rt%c(SS$d!R$gQ$p!XQ$u!cQ$v!dQ$w!eQ$x!fQ$y!gQ$z!hQ%e!zQ%j#OQ%p#SQ%q#TQ&`#xQ'O$eQ'g$qQ(q&OU(|&h(}+cW)j&|)l+x+yQ*o'|Q*x(]Q+w)kQ,v+QR0g0lQ!yYQ!}ZQ$b!PQ$c!QQ%R!kQ't%S^'{%`%g(O(W*q*t*v^*f'p*h,k,l-p.g/ZQ*l'rQ*m'sQ+t)gQ,j*gQ,n*kQ-n,hQ-o,iQ-r,oQ.e-mR/Y.f[bOn#g$j)t,P!^!vYZ!P!Q!k%S%`%g'p'r's(O(W)g*g*h*k*q*t*v,h,i,k,l,o-m-p.f.g/ZQ#R[Q#fdS#wrxQ$UyW$_}$Q'P)pS$l!U$hW${!i'm*d,gS%v#[+Y`&P#d%|(p(r(z+a-O0kQ&a#yQ&b#{Q&c#}Q'j$}Q'z%^W([%l(^*y*}Q(`%nQ(i%wQ(v&ZS(y&_0iQ)P&jQ)Q&kU)]&u)^+kQ)d&xQ)y'WY)}'Z*O,X,Y-dQ*b'lS*n'w0jW+P(d*z,s,wW+T(g+V,y,zQ+p)eQ,U)zQ,c*YQ,x+UQ-P+dQ-e,]Q-v,uQ.S-fR/q/VhUOn#d#g$j%|&_'w(p(r)t,P%U!uYZ[drxy}!P!Q!U!i!k#[#y#{#}$Q$h$}%S%^%`%g%l%n%w&Z&j&k&u&x'P'W'Z'l'm'p'r's(O(W(^(d(g(z)^)e)g)p)z*O*Y*d*g*h*k*q*t*v*y*z*}+U+V+Y+a+d+k,X,Y,],g,h,i,k,l,o,s,u,w,y,z-O-d-f-m-p.f.g/V/Z0i0j0kQ#qpW%W!o!s0d0nQ%X!pQ%Y!qQ%[!tQ%f0cS'v%Z0hQ'x0eQ'y0fQ,p*rQ-u,qS.i-s/sR0p0rU#uq.k0qR(w&][cOn#g$j)t,PZ!xY#[#}$Q+YQ#W[Q#zrR$TxQ%b!yQ%i!}Q%o#RQ'j${Q(V%eQ(Z%jQ(c%pQ(f%qQ*|(`Q,f*bQ-t,pQ.m-uR/].lQ$StQ(R%cR*s(SQ.l-sR/}/sR#QZR#V[R%Q!iQ%O!iV*c'm*d,g!Z!lQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0gR%T!kT#]^#_Q%x#[R,{+YQ(m%xS+_(n(oQ,}+`Q-x,{S.n-y-zR/^.oT+Z(k+]Q$`}Q&g$QQ)o'PR+{)pQ$XzQ)W&qR+i)XQ$XzQ&o$WQ)W&qR+i)XQ#khW$Vz$W&q)XQ$[{Q&r$ZZ)R&l)S+f+g-RR$^|R)c&wXlOn)t,PQ$f!RR'Q$gQ$m!UR'R$hR*X'_Q*V'_V-g,`-h.TQ.d-lQ/P.^R/Q._U.]-l.^._Q/U.aQ/b.tQ/g.zU/i.|/j/yQ/n/RQ/|/oQ0O/tU0Q/u0S0[Q0]0UQ0a0ZR0b0^R/T.`R/d.t\",\n  nodeNames: \"âš  print Escape { Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatSelfDoc FormatConversion FormatSpec FormatReplacement FormatSelfDoc ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert TypeDefinition type TypeParamList TypeParam StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At MatchStatement match MatchBody MatchClause case CapturePattern LiteralPattern ArithOp ArithOp AsPattern OrPattern LogicOp AttributePattern SequencePattern MappingPattern StarPattern ClassPattern PatternArgList KeywordPattern KeywordPattern Guard\",\n  maxTerm: 277,\n  context: trackIndent,\n  nodeProps: [[\"isolate\", -5, 4, 71, 72, 73, 77, \"\"], [\"group\", -15, 6, 85, 87, 88, 90, 92, 94, 96, 98, 99, 100, 102, 105, 108, 110, \"Statement Statement\", -22, 8, 18, 21, 25, 40, 49, 50, 56, 57, 60, 61, 62, 63, 64, 67, 70, 71, 72, 79, 80, 81, 82, \"Expression\", -10, 114, 116, 119, 121, 122, 126, 128, 133, 135, 138, \"Statement\", -9, 143, 144, 147, 148, 150, 151, 152, 153, 154, \"Pattern\"], [\"openedBy\", 23, \"(\", 54, \"[\", 58, \"{\"], [\"closedBy\", 24, \")\", 55, \"]\", 59, \"}\"]],\n  propSources: [pythonHighlighting],\n  skippedNodes: [0, 4],\n  repeatNodeCount: 34,\n  tokenData: \"!2|~R!`OX%TXY%oY[%T[]%o]p%Tpq%oqr'ars)Yst*xtu%Tuv,dvw-hwx.Uxy/tyz0[z{0r{|2S|}2p}!O3W!O!P4_!P!Q:Z!Q!R;k!R![>_![!]Do!]!^Es!^!_FZ!_!`Gk!`!aHX!a!b%T!b!cIf!c!dJU!d!eK^!e!hJU!h!i!#f!i!tJU!t!u!,|!u!wJU!w!x!.t!x!}JU!}#O!0S#O#P&o#P#Q!0j#Q#R!1Q#R#SJU#S#T%T#T#UJU#U#VK^#V#YJU#Y#Z!#f#Z#fJU#f#g!,|#g#iJU#i#j!.t#j#oJU#o#p!1n#p#q!1s#q#r!2a#r#s!2f#s$g%T$g;'SJU;'S;=`KW<%lOJU`%YT&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T`%lP;=`<%l%To%v]&n`%c_OX%TXY%oY[%T[]%o]p%Tpq%oq#O%T#O#P&o#P#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To&tX&n`OY%TYZ%oZ]%T]^%o^#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc'f[&n`O!_%T!_!`([!`#T%T#T#U(r#U#f%T#f#g(r#g#h(r#h#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc(cTmR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc(yT!mR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk)aV&n`&[ZOr%Trs)vs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk){V&n`Or%Trs*bs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk*iT&n`&^ZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To+PZS_&n`OY*xYZ%TZ]*x]^%T^#o*x#o#p+r#p#q*x#q#r+r#r;'S*x;'S;=`,^<%lO*x_+wTS_OY+rZ]+r^;'S+r;'S;=`,W<%lO+r_,ZP;=`<%l+ro,aP;=`<%l*xj,kV%rQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj-XT!xY&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj-oV%lQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk.]V&n`&ZZOw%Twx.rx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk.wV&n`Ow%Twx/^x#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk/eT&n`&]ZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk/{ThZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc0cTgR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk0yXVZ&n`Oz%Tz{1f{!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk1mVaR&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk2ZV%oZ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc2wTzR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To3_W%pZ&n`O!_%T!_!`-Q!`!a3w!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Td4OT&{S&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk4fX!fQ&n`O!O%T!O!P5R!P!Q%T!Q![6T![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk5WV&n`O!O%T!O!P5m!P#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk5tT!rZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti6[a!hX&n`O!Q%T!Q![6T![!g%T!g!h7a!h!l%T!l!m9s!m#R%T#R#S6T#S#X%T#X#Y7a#Y#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti7fZ&n`O{%T{|8X|}%T}!O8X!O!Q%T!Q![8s![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti8^V&n`O!Q%T!Q![8s![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti8z]!hX&n`O!Q%T!Q![8s![!l%T!l!m9s!m#R%T#R#S8s#S#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti9zT!hX&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk:bX%qR&n`O!P%T!P!Q:}!Q!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj;UV%sQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti;ro!hX&n`O!O%T!O!P=s!P!Q%T!Q![>_![!d%T!d!e?q!e!g%T!g!h7a!h!l%T!l!m9s!m!q%T!q!rA]!r!z%T!z!{Bq!{#R%T#R#S>_#S#U%T#U#V?q#V#X%T#X#Y7a#Y#^%T#^#_9s#_#c%T#c#dA]#d#l%T#l#mBq#m#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti=xV&n`O!Q%T!Q![6T![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti>fc!hX&n`O!O%T!O!P=s!P!Q%T!Q![>_![!g%T!g!h7a!h!l%T!l!m9s!m#R%T#R#S>_#S#X%T#X#Y7a#Y#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti?vY&n`O!Q%T!Q!R@f!R!S@f!S#R%T#R#S@f#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti@mY!hX&n`O!Q%T!Q!R@f!R!S@f!S#R%T#R#S@f#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiAbX&n`O!Q%T!Q!YA}!Y#R%T#R#SA}#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiBUX!hX&n`O!Q%T!Q!YA}!Y#R%T#R#SA}#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiBv]&n`O!Q%T!Q![Co![!c%T!c!iCo!i#R%T#R#SCo#S#T%T#T#ZCo#Z#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiCv]!hX&n`O!Q%T!Q![Co![!c%T!c!iCo!i#R%T#R#SCo#S#T%T#T#ZCo#Z#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%ToDvV{_&n`O!_%T!_!`E]!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TcEdT%{R&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkEzT#gZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkFbXmR&n`O!^%T!^!_F}!_!`([!`!a([!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TjGUV%mQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkGrV%zZ&n`O!_%T!_!`([!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkH`WmR&n`O!_%T!_!`([!`!aHx!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TjIPV%nQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkIoV_Q#}P&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%ToJ_]&n`&YS%uZO!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUoKZP;=`<%lJUoKge&n`&YS%uZOr%Trs)Ysw%Twx.Ux!Q%T!Q![JU![!c%T!c!tJU!t!uLx!u!}JU!}#R%T#R#SJU#S#T%T#T#fJU#f#gLx#g#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUoMRa&n`&YS%uZOr%TrsNWsw%Twx! vx!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUkN_V&n`&`ZOr%TrsNts#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkNyV&n`Or%Trs! `s#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk! gT&n`&bZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk! }V&n`&_ZOw%Twx!!dx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!!iV&n`Ow%Twx!#Ox#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!#VT&n`&aZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!#oe&n`&YS%uZOr%Trs!%Qsw%Twx!&px!Q%T!Q![JU![!c%T!c!tJU!t!u!(`!u!}JU!}#R%T#R#SJU#S#T%T#T#fJU#f#g!(`#g#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!%XV&n`&dZOr%Trs!%ns#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!%sV&n`Or%Trs!&Ys#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!&aT&n`&fZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!&wV&n`&cZOw%Twx!'^x#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!'cV&n`Ow%Twx!'xx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!(PT&n`&eZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!(ia&n`&YS%uZOr%Trs!)nsw%Twx!+^x!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!)uV&n`&hZOr%Trs!*[s#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!*aV&n`Or%Trs!*vs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!*}T&n`&jZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!+eV&n`&gZOw%Twx!+zx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!,PV&n`Ow%Twx!,fx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!,mT&n`&iZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!-Vi&n`&YS%uZOr%TrsNWsw%Twx! vx!Q%T!Q![JU![!c%T!c!dJU!d!eLx!e!hJU!h!i!(`!i!}JU!}#R%T#R#SJU#S#T%T#T#UJU#U#VLx#V#YJU#Y#Z!(`#Z#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUo!.}a&n`&YS%uZOr%Trs)Ysw%Twx.Ux!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!0ZT!XZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc!0qT!WR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj!1XV%kQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T~!1sO!]~k!1zV%jR&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T~!2fO![~i!2mT%tX&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T\",\n  tokenizers: [legacyPrint, indentation, newlines, strings, 0, 1, 2, 3, 4],\n  topRules: {\n    \"Script\": [0, 5]\n  },\n  specialized: [{\n    term: 221,\n    get: value => spec_identifier[value] || -1\n  }],\n  tokenPrec: 7668\n});\nexport { parser };", "import { parser } from '@lezer/python';\nimport { syntaxTree, LRLanguage, indentNodeProp, delimitedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\nimport { NodeWeakMap, IterMode } from '@lezer/common';\nimport { snippetCompletion, ifNotIn, completeFromList } from '@codemirror/autocomplete';\nconst cache = /*@__PURE__*/new NodeWeakMap();\nconst ScopeNodes = /*@__PURE__*/new Set([\"Script\", \"Body\", \"FunctionDefinition\", \"ClassDefinition\", \"LambdaExpression\", \"ForStatement\", \"MatchClause\"]);\nfunction defID(type) {\n  return (node, def, outer) => {\n    if (outer) return false;\n    let id = node.node.getChild(\"VariableName\");\n    if (id) def(id, type);\n    return true;\n  };\n}\nconst gatherCompletions = {\n  FunctionDefinition: /*@__PURE__*/defID(\"function\"),\n  ClassDefinition: /*@__PURE__*/defID(\"class\"),\n  ForStatement(node, def, outer) {\n    if (outer) for (let child = node.node.firstChild; child; child = child.nextSibling) {\n      if (child.name == \"VariableName\") def(child, \"variable\");else if (child.name == \"in\") break;\n    }\n  },\n  ImportStatement(_node, def) {\n    var _a, _b;\n    let {\n      node\n    } = _node;\n    let isFrom = ((_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.name) == \"from\";\n    for (let ch = node.getChild(\"import\"); ch; ch = ch.nextSibling) {\n      if (ch.name == \"VariableName\" && ((_b = ch.nextSibling) === null || _b === void 0 ? void 0 : _b.name) != \"as\") def(ch, isFrom ? \"variable\" : \"namespace\");\n    }\n  },\n  AssignStatement(node, def) {\n    for (let child = node.node.firstChild; child; child = child.nextSibling) {\n      if (child.name == \"VariableName\") def(child, \"variable\");else if (child.name == \":\" || child.name == \"AssignOp\") break;\n    }\n  },\n  ParamList(node, def) {\n    for (let prev = null, child = node.node.firstChild; child; child = child.nextSibling) {\n      if (child.name == \"VariableName\" && (!prev || !/\\*|AssignOp/.test(prev.name))) def(child, \"variable\");\n      prev = child;\n    }\n  },\n  CapturePattern: /*@__PURE__*/defID(\"variable\"),\n  AsPattern: /*@__PURE__*/defID(\"variable\"),\n  __proto__: null\n};\nfunction getScope(doc, node) {\n  let cached = cache.get(node);\n  if (cached) return cached;\n  let completions = [],\n    top = true;\n  function def(node, type) {\n    let name = doc.sliceString(node.from, node.to);\n    completions.push({\n      label: name,\n      type\n    });\n  }\n  node.cursor(IterMode.IncludeAnonymous).iterate(node => {\n    if (node.name) {\n      let gather = gatherCompletions[node.name];\n      if (gather && gather(node, def, top) || !top && ScopeNodes.has(node.name)) return false;\n      top = false;\n    } else if (node.to - node.from > 8192) {\n      // Allow caching for bigger internal nodes\n      for (let c of getScope(doc, node.node)) completions.push(c);\n      return false;\n    }\n  });\n  cache.set(node, completions);\n  return completions;\n}\nconst Identifier = /^[\\w\\xa1-\\uffff][\\w\\d\\xa1-\\uffff]*$/;\nconst dontComplete = [\"String\", \"FormatString\", \"Comment\", \"PropertyName\"];\n/**\nCompletion source that looks up locally defined names in\nPython code.\n*/\nfunction localCompletionSource(context) {\n  let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n  if (dontComplete.indexOf(inner.name) > -1) return null;\n  let isWord = inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n  if (!isWord && !context.explicit) return null;\n  let options = [];\n  for (let pos = inner; pos; pos = pos.parent) {\n    if (ScopeNodes.has(pos.name)) options = options.concat(getScope(context.state.doc, pos));\n  }\n  return {\n    options,\n    from: isWord ? inner.from : context.pos,\n    validFor: Identifier\n  };\n}\nconst globals = /*@__PURE__*/[\"__annotations__\", \"__builtins__\", \"__debug__\", \"__doc__\", \"__import__\", \"__name__\", \"__loader__\", \"__package__\", \"__spec__\", \"False\", \"None\", \"True\"].map(n => ({\n  label: n,\n  type: \"constant\"\n})).concat(/*@__PURE__*/[\"ArithmeticError\", \"AssertionError\", \"AttributeError\", \"BaseException\", \"BlockingIOError\", \"BrokenPipeError\", \"BufferError\", \"BytesWarning\", \"ChildProcessError\", \"ConnectionAbortedError\", \"ConnectionError\", \"ConnectionRefusedError\", \"ConnectionResetError\", \"DeprecationWarning\", \"EOFError\", \"Ellipsis\", \"EncodingWarning\", \"EnvironmentError\", \"Exception\", \"FileExistsError\", \"FileNotFoundError\", \"FloatingPointError\", \"FutureWarning\", \"GeneratorExit\", \"IOError\", \"ImportError\", \"ImportWarning\", \"IndentationError\", \"IndexError\", \"InterruptedError\", \"IsADirectoryError\", \"KeyError\", \"KeyboardInterrupt\", \"LookupError\", \"MemoryError\", \"ModuleNotFoundError\", \"NameError\", \"NotADirectoryError\", \"NotImplemented\", \"NotImplementedError\", \"OSError\", \"OverflowError\", \"PendingDeprecationWarning\", \"PermissionError\", \"ProcessLookupError\", \"RecursionError\", \"ReferenceError\", \"ResourceWarning\", \"RuntimeError\", \"RuntimeWarning\", \"StopAsyncIteration\", \"StopIteration\", \"SyntaxError\", \"SyntaxWarning\", \"SystemError\", \"SystemExit\", \"TabError\", \"TimeoutError\", \"TypeError\", \"UnboundLocalError\", \"UnicodeDecodeError\", \"UnicodeEncodeError\", \"UnicodeError\", \"UnicodeTranslateError\", \"UnicodeWarning\", \"UserWarning\", \"ValueError\", \"Warning\", \"ZeroDivisionError\"].map(n => ({\n  label: n,\n  type: \"type\"\n}))).concat(/*@__PURE__*/[\"bool\", \"bytearray\", \"bytes\", \"classmethod\", \"complex\", \"float\", \"frozenset\", \"int\", \"list\", \"map\", \"memoryview\", \"object\", \"range\", \"set\", \"staticmethod\", \"str\", \"super\", \"tuple\", \"type\"].map(n => ({\n  label: n,\n  type: \"class\"\n}))).concat(/*@__PURE__*/[\"abs\", \"aiter\", \"all\", \"anext\", \"any\", \"ascii\", \"bin\", \"breakpoint\", \"callable\", \"chr\", \"compile\", \"delattr\", \"dict\", \"dir\", \"divmod\", \"enumerate\", \"eval\", \"exec\", \"exit\", \"filter\", \"format\", \"getattr\", \"globals\", \"hasattr\", \"hash\", \"help\", \"hex\", \"id\", \"input\", \"isinstance\", \"issubclass\", \"iter\", \"len\", \"license\", \"locals\", \"max\", \"min\", \"next\", \"oct\", \"open\", \"ord\", \"pow\", \"print\", \"property\", \"quit\", \"repr\", \"reversed\", \"round\", \"setattr\", \"slice\", \"sorted\", \"sum\", \"vars\", \"zip\"].map(n => ({\n  label: n,\n  type: \"function\"\n})));\nconst snippets = [/*@__PURE__*/snippetCompletion(\"def ${name}(${params}):\\n\\t${}\", {\n  label: \"def\",\n  detail: \"function\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"for ${name} in ${collection}:\\n\\t${}\", {\n  label: \"for\",\n  detail: \"loop\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"while ${}:\\n\\t${}\", {\n  label: \"while\",\n  detail: \"loop\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"try:\\n\\t${}\\nexcept ${error}:\\n\\t${}\", {\n  label: \"try\",\n  detail: \"/ except block\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"if ${}:\\n\\t\\n\", {\n  label: \"if\",\n  detail: \"block\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"if ${}:\\n\\t${}\\nelse:\\n\\t${}\", {\n  label: \"if\",\n  detail: \"/ else block\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"class ${name}:\\n\\tdef __init__(self, ${params}):\\n\\t\\t\\t${}\", {\n  label: \"class\",\n  detail: \"definition\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"import ${module}\", {\n  label: \"import\",\n  detail: \"statement\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"from ${module} import ${names}\", {\n  label: \"from\",\n  detail: \"import\",\n  type: \"keyword\"\n})];\n/**\nAutocompletion for built-in Python globals and keywords.\n*/\nconst globalCompletion = /*@__PURE__*/ifNotIn(dontComplete, /*@__PURE__*/completeFromList(/*@__PURE__*/globals.concat(snippets)));\nfunction innerBody(context) {\n  let {\n    node,\n    pos\n  } = context;\n  let lineIndent = context.lineIndent(pos, -1);\n  let found = null;\n  for (;;) {\n    let before = node.childBefore(pos);\n    if (!before) {\n      break;\n    } else if (before.name == \"Comment\") {\n      pos = before.from;\n    } else if (before.name == \"Body\" || before.name == \"MatchBody\") {\n      if (context.baseIndentFor(before) + context.unit <= lineIndent) found = before;\n      node = before;\n    } else if (before.name == \"MatchClause\") {\n      node = before;\n    } else if (before.type.is(\"Statement\")) {\n      node = before;\n    } else {\n      break;\n    }\n  }\n  return found;\n}\nfunction indentBody(context, node) {\n  let base = context.baseIndentFor(node);\n  let line = context.lineAt(context.pos, -1),\n    to = line.from + line.text.length;\n  // Don't consider blank, deindented lines at the end of the\n  // block part of the block\n  if (/^\\s*($|#)/.test(line.text) && context.node.to < to + 100 && !/\\S/.test(context.state.sliceDoc(to, context.node.to)) && context.lineIndent(context.pos, -1) <= base) return null;\n  // A normally deindenting keyword that appears at a higher\n  // indentation than the block should probably be handled by the next\n  // level\n  if (/^\\s*(else:|elif |except |finally:|case\\s+[^=:]+:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base) return null;\n  return base + context.unit;\n}\n/**\nA language provider based on the [Lezer Python\nparser](https://github.com/lezer-parser/python), extended with\nhighlighting and indentation information.\n*/\nconst pythonLanguage = /*@__PURE__*/LRLanguage.define({\n  name: \"python\",\n  parser: /*@__PURE__*/parser.configure({\n    props: [/*@__PURE__*/indentNodeProp.add({\n      Body: context => {\n        var _a;\n        let body = /^\\s*(#|$)/.test(context.textAfter) && innerBody(context) || context.node;\n        return (_a = indentBody(context, body)) !== null && _a !== void 0 ? _a : context.continue();\n      },\n      MatchBody: context => {\n        var _a;\n        let inner = innerBody(context);\n        return (_a = indentBody(context, inner || context.node)) !== null && _a !== void 0 ? _a : context.continue();\n      },\n      IfStatement: cx => /^\\s*(else:|elif )/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n      \"ForStatement WhileStatement\": cx => /^\\s*else:/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n      TryStatement: cx => /^\\s*(except[ :]|finally:|else:)/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n      MatchStatement: cx => {\n        if (/^\\s*case /.test(cx.textAfter)) return cx.baseIndent + cx.unit;\n        return cx.continue();\n      },\n      \"TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression\": /*@__PURE__*/delimitedIndent({\n        closing: \")\"\n      }),\n      \"DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression\": /*@__PURE__*/delimitedIndent({\n        closing: \"}\"\n      }),\n      \"ArrayExpression ArrayComprehensionExpression\": /*@__PURE__*/delimitedIndent({\n        closing: \"]\"\n      }),\n      MemberExpression: cx => cx.baseIndent + cx.unit,\n      \"String FormatString\": () => null,\n      Script: context => {\n        var _a;\n        let inner = innerBody(context);\n        return (_a = inner && indentBody(context, inner)) !== null && _a !== void 0 ? _a : context.continue();\n      }\n    }), /*@__PURE__*/foldNodeProp.add({\n      \"ArrayExpression DictionaryExpression SetExpression TupleExpression\": foldInside,\n      Body: (node, state) => ({\n        from: node.from + 1,\n        to: node.to - (node.to == state.doc.length ? 0 : 1)\n      }),\n      \"String FormatString\": (node, state) => ({\n        from: state.doc.lineAt(node.from).to,\n        to: node.to\n      })\n    })]\n  }),\n  languageData: {\n    closeBrackets: {\n      brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"'''\", '\"\"\"'],\n      stringPrefixes: [\"f\", \"fr\", \"rf\", \"r\", \"u\", \"b\", \"br\", \"rb\", \"F\", \"FR\", \"RF\", \"R\", \"U\", \"B\", \"BR\", \"RB\"]\n    },\n    commentTokens: {\n      line: \"#\"\n    },\n    // Indent logic logic are triggered upon below input patterns\n    indentOnInput: /^\\s*([\\}\\]\\)]|else:|elif |except |finally:|case\\s+[^:]*:?)$/\n  }\n});\n/**\nPython language support.\n*/\nfunction python() {\n  return new LanguageSupport(pythonLanguage, [pythonLanguage.data.of({\n    autocomplete: localCompletionSource\n  }), pythonLanguage.data.of({\n    autocomplete: globalCompletion\n  })]);\n}\nexport { globalCompletion, localCompletionSource, python, pythonLanguage };"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA,IAAM,QAAN,MAAM,OAAM;AAAA;AAAA;AAAA;AAAA,EAIV,YAIA,GAKA,OAIA,OAQA,WAIA,KAMA,OAOA,QASA,YAIA,YAIA,YAAY,GAQZ,QAAQ;AACN,SAAK,IAAI;AACT,SAAK,QAAQ;AACb,SAAK,QAAQ;AACb,SAAK,YAAY;AACjB,SAAK,MAAM;AACX,SAAK,QAAQ;AACb,SAAK,SAAS;AACd,SAAK,aAAa;AAClB,SAAK,aAAa;AAClB,SAAK,YAAY;AACjB,SAAK,SAAS;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAIA,WAAW;AACT,WAAO,IAAI,KAAK,MAAM,OAAO,CAAC,GAAG,MAAM,IAAI,KAAK,CAAC,EAAE,OAAO,KAAK,KAAK,CAAC,KAAK,KAAK,GAAG,GAAG,KAAK,QAAQ,MAAM,KAAK,QAAQ,EAAE;AAAA,EACzH;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG;AAC9B,QAAI,KAAK,EAAE,OAAO;AAClB,WAAO,IAAI,OAAM,GAAG,CAAC,GAAG,OAAO,KAAK,KAAK,GAAG,CAAC,GAAG,GAAG,KAAK,IAAI,aAAa,IAAI,GAAG,KAAK,IAAI,MAAM,GAAG,IAAI;AAAA,EACxG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAI,UAAU;AACZ,WAAO,KAAK,aAAa,KAAK,WAAW,UAAU;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAU,OAAO,OAAO;AACtB,SAAK,MAAM,KAAK,KAAK,OAAO,OAAO,KAAK,aAAa,KAAK,OAAO,MAAM;AACvE,SAAK,QAAQ;AAAA,EACf;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,QAAQ;AACb,QAAI;AACJ,QAAI,QAAQ,UAAU,IACpB,OAAO,SAAS;AAClB,QAAI;AAAA,MACF,QAAAA;AAAA,IACF,IAAI,KAAK;AACT,QAAI,kBAAkB,KAAK,YAAY,KAAK,MAAM;AAClD,QAAI,gBAAiB,MAAK,aAAa,KAAK,GAAG;AAC/C,QAAI,QAAQA,QAAO,kBAAkB,IAAI;AACzC,QAAI,MAAO,MAAK,SAAS;AACzB,QAAI,SAAS,GAAG;AACd,WAAK,UAAUA,QAAO,QAAQ,KAAK,OAAO,MAAM,IAAI,GAAG,KAAK,SAAS;AAGrE,UAAI,OAAOA,QAAO,cAAe,MAAK,UAAU,MAAM,KAAK,WAAW,KAAK,WAAW,kBAAkB,IAAI,GAAG,IAAI;AACnH,WAAK,cAAc,MAAM,KAAK,SAAS;AACvC;AAAA,IACF;AAMA,QAAI,OAAO,KAAK,MAAM,UAAU,QAAQ,KAAK,KAAK,SAAS,SAA+B,IAAI;AAC9F,QAAI,QAAQ,OAAO,KAAK,MAAM,OAAO,CAAC,IAAI,KAAK,EAAE,OAAO,CAAC,EAAE,MACzD,OAAO,KAAK,YAAY;AAI1B,QAAI,QAAQ,OAAsC,GAAG,KAAK,KAAK,EAAE,OAAO,QAAQ,MAAM,IAAI,OAAO,QAAQ,OAAO,SAAS,SAAS,GAAG,cAAc;AACjJ,UAAI,SAAS,KAAK,EAAE,uBAAuB;AACzC,aAAK,EAAE;AACP,aAAK,EAAE,uBAAuB;AAAA,MAChC,WAAW,KAAK,EAAE,uBAAuB,MAAM;AAC7C,aAAK,EAAE,oBAAoB;AAC3B,aAAK,EAAE,wBAAwB;AAC/B,aAAK,EAAE,uBAAuB;AAAA,MAChC;AAAA,IACF;AACA,QAAI,aAAa,OAAO,KAAK,MAAM,OAAO,CAAC,IAAI,GAC7C,QAAQ,KAAK,aAAa,KAAK,OAAO,SAAS;AAEjD,QAAI,OAAOA,QAAO,iBAAiB,SAAS,QAAgC;AAC1E,UAAI,MAAMA,QAAO;AAAA,QAAU,KAAK;AAAA,QAAO;AAAA;AAAA,MAAyB,IAAI,KAAK,MAAM,KAAK;AACpF,WAAK,UAAU,MAAM,OAAO,KAAK,QAAQ,GAAG,IAAI;AAAA,IAClD;AACA,QAAI,SAAS,QAA8B;AACzC,WAAK,QAAQ,KAAK,MAAM,IAAI;AAAA,IAC9B,OAAO;AACL,UAAI,cAAc,KAAK,MAAM,OAAO,CAAC;AACrC,WAAK,QAAQA,QAAO,QAAQ,aAAa,MAAM,IAAI;AAAA,IACrD;AACA,WAAO,KAAK,MAAM,SAAS,KAAM,MAAK,MAAM,IAAI;AAChD,SAAK,cAAc,MAAM,KAAK;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU,MAAM,OAAO,KAAK,OAAO,GAAG,WAAW,OAAO;AACtD,QAAI,QAAQ,MAAqB,CAAC,KAAK,MAAM,UAAU,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC,IAAI,KAAK,OAAO,SAAS,KAAK,aAAa;AAEhI,UAAI,MAAM,MACR,MAAM,KAAK,OAAO;AACpB,UAAI,OAAO,KAAK,IAAI,QAAQ;AAC1B,cAAM,IAAI,aAAa,IAAI,OAAO;AAClC,cAAM,IAAI;AAAA,MACZ;AACA,UAAI,MAAM,KAAK,IAAI,OAAO,MAAM,CAAC,KAAK,KAAoB,IAAI,OAAO,MAAM,CAAC,IAAI,IAAI;AAClF,YAAI,SAAS,IAAK;AAClB,YAAI,IAAI,OAAO,MAAM,CAAC,KAAK,OAAO;AAChC,cAAI,OAAO,MAAM,CAAC,IAAI;AACtB;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,QAAI,CAAC,YAAY,KAAK,OAAO,KAAK;AAEhC,WAAK,OAAO,KAAK,MAAM,OAAO,KAAK,IAAI;AAAA,IACzC,OAAO;AAEL,UAAI,QAAQ,KAAK,OAAO;AACxB,UAAI,QAAQ,KAAK,KAAK,OAAO,QAAQ,CAAC,KAAK,GAAkB;AAC3D,YAAI,WAAW;AACf,iBAAS,OAAO,OAAO,OAAO,KAAK,KAAK,OAAO,OAAO,CAAC,IAAI,KAAK,QAAQ,GAAG;AACzE,cAAI,KAAK,OAAO,OAAO,CAAC,KAAK,GAAG;AAC9B,uBAAW;AACX;AAAA,UACF;AAAA,QACF;AACA,YAAI,SAAU,QAAO,QAAQ,KAAK,KAAK,OAAO,QAAQ,CAAC,IAAI,KAAK;AAE9D,eAAK,OAAO,KAAK,IAAI,KAAK,OAAO,QAAQ,CAAC;AAC1C,eAAK,OAAO,QAAQ,CAAC,IAAI,KAAK,OAAO,QAAQ,CAAC;AAC9C,eAAK,OAAO,QAAQ,CAAC,IAAI,KAAK,OAAO,QAAQ,CAAC;AAC9C,eAAK,OAAO,QAAQ,CAAC,IAAI,KAAK,OAAO,QAAQ,CAAC;AAC9C,mBAAS;AACT,cAAI,OAAO,EAAG,SAAQ;AAAA,QACxB;AAAA,MACF;AACA,WAAK,OAAO,KAAK,IAAI;AACrB,WAAK,OAAO,QAAQ,CAAC,IAAI;AACzB,WAAK,OAAO,QAAQ,CAAC,IAAI;AACzB,WAAK,OAAO,QAAQ,CAAC,IAAI;AAAA,IAC3B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAQ,MAAM,OAAO,KAAK;AAC9B,QAAI,SAAS,QAA8B;AACzC,WAAK,UAAU,SAAS,OAA8B,KAAK,GAAG;AAAA,IAChE,YAAY,SAAS,WAAiC,GAAG;AAEvD,UAAI,YAAY,QACd;AAAA,QACE,QAAAA;AAAA,MACF,IAAI,KAAK;AACX,UAAI,MAAM,KAAK,OAAO,QAAQA,QAAO,SAAS;AAC5C,aAAK,MAAM;AACX,YAAI,CAACA,QAAO;AAAA,UAAU;AAAA,UAAW;AAAA;AAAA,QAAyB,EAAG,MAAK,YAAY;AAAA,MAChF;AACA,WAAK,UAAU,WAAW,KAAK;AAC/B,WAAK,aAAa,MAAM,KAAK;AAC7B,UAAI,QAAQA,QAAO,QAAS,MAAK,OAAO,KAAK,MAAM,OAAO,KAAK,CAAC;AAAA,IAClE,OAAO;AAEL,WAAK,MAAM;AACX,WAAK,aAAa,MAAM,KAAK;AAC7B,UAAI,QAAQ,KAAK,EAAE,OAAO,QAAS,MAAK,OAAO,KAAK,MAAM,OAAO,KAAK,CAAC;AAAA,IACzE;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAQ,MAAM,WAAW,SAAS;AACtC,QAAI,SAAS,MAA+B,MAAK,OAAO,MAAM;AAAA,QAAO,MAAK,MAAM,QAAQ,MAAM,WAAW,OAAO;AAAA,EAClH;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ,OAAO,MAAM;AACnB,QAAI,QAAQ,KAAK,EAAE,OAAO,SAAS;AACnC,QAAI,QAAQ,KAAK,KAAK,EAAE,OAAO,KAAK,KAAK,OAAO;AAC9C,WAAK,EAAE,OAAO,KAAK,KAAK;AACxB;AAAA,IACF;AACA,QAAI,QAAQ,KAAK;AACjB,SAAK,YAAY,KAAK,MAAM,QAAQ,MAAM;AAC1C,SAAK,UAAU,MAAM,KAAK;AAC1B,SAAK,OAAO;AAAA,MAAK;AAAA,MAAO;AAAA,MAAO,KAAK;AAAA,MAAW;AAAA;AAAA,IAAgD;AAC/F,QAAI,KAAK,WAAY,MAAK,cAAc,KAAK,WAAW,QAAQ,MAAM,KAAK,WAAW,SAAS,OAAO,MAAM,KAAK,EAAE,OAAO,MAAM,KAAK,MAAM,MAAM,MAAM,CAAC,CAAC;AAAA,EAC3J;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAQ;AACN,QAAI,SAAS;AACb,QAAI,MAAM,OAAO,OAAO;AAKxB,WAAO,MAAM,KAAK,OAAO,OAAO,MAAM,CAAC,IAAI,OAAO,UAAW,QAAO;AACpE,QAAI,SAAS,OAAO,OAAO,MAAM,GAAG,GAClC,OAAO,OAAO,aAAa;AAE7B,WAAO,UAAU,QAAQ,OAAO,WAAY,UAAS,OAAO;AAC5D,WAAO,IAAI,OAAM,KAAK,GAAG,KAAK,MAAM,MAAM,GAAG,KAAK,OAAO,KAAK,WAAW,KAAK,KAAK,KAAK,OAAO,QAAQ,MAAM,KAAK,YAAY,KAAK,WAAW,MAAM;AAAA,EACtJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAgB,MAAM,SAAS;AAC7B,QAAI,SAAS,QAAQ,KAAK,EAAE,OAAO;AACnC,QAAI,OAAQ,MAAK,UAAU,MAAM,KAAK,KAAK,SAAS,CAAC;AACrD,SAAK,UAAU,GAAkB,KAAK,KAAK,SAAS,SAAS,IAAI,CAAC;AAClE,SAAK,MAAM,KAAK,YAAY;AAC5B,SAAK,SAAS;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,SAAS,MAAM;AACb,aAAS,MAAM,IAAI,eAAe,IAAI,OAAK;AACzC,UAAI,SAAS,KAAK,EAAE,OAAO;AAAA,QAAU,IAAI;AAAA,QAAO;AAAA;AAAA,MAAgC,KAAK,KAAK,EAAE,OAAO,UAAU,IAAI,OAAO,IAAI;AAC5H,UAAI,UAAU,EAAG,QAAO;AACxB,WAAK,SAAS,UAAkC,EAAG,QAAO;AAC1D,UAAI,OAAO,MAAM;AAAA,IACnB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,gBAAgB,MAAM;AACpB,QAAI,KAAK,MAAM,UAAU,IAAuC,QAAO,CAAC;AACxE,QAAI,aAAa,KAAK,EAAE,OAAO,WAAW,KAAK,KAAK;AACpD,QAAI,WAAW,SAAS,KAA2B,KAAK,KAAK,MAAM,UAAU,KAA0C;AACrH,UAAI,OAAO,CAAC;AACZ,eAAS,IAAI,GAAG,GAAG,IAAI,WAAW,QAAQ,KAAK,GAAG;AAChD,aAAK,IAAI,WAAW,IAAI,CAAC,MAAM,KAAK,SAAS,KAAK,EAAE,OAAO,UAAU,GAAG,IAAI,EAAG,MAAK,KAAK,WAAW,CAAC,GAAG,CAAC;AAAA,MAC3G;AACA,UAAI,KAAK,MAAM,SAAS,IAA0C,UAAS,IAAI,GAAG,KAAK,SAAS,KAA2B,KAAK,IAAI,WAAW,QAAQ,KAAK,GAAG;AAC7J,YAAI,IAAI,WAAW,IAAI,CAAC;AACxB,YAAI,CAAC,KAAK,KAAK,CAAC,GAAGC,OAAMA,KAAI,KAAK,KAAK,CAAC,EAAG,MAAK,KAAK,WAAW,CAAC,GAAG,CAAC;AAAA,MACvE;AACA,mBAAa;AAAA,IACf;AACA,QAAI,SAAS,CAAC;AACd,aAAS,IAAI,GAAG,IAAI,WAAW,UAAU,OAAO,SAAS,GAAyB,KAAK,GAAG;AACxF,UAAI,IAAI,WAAW,IAAI,CAAC;AACxB,UAAI,KAAK,KAAK,MAAO;AACrB,UAAI,QAAQ,KAAK,MAAM;AACvB,YAAM,UAAU,GAAG,KAAK,GAAG;AAC3B,YAAM,UAAU,GAAkB,MAAM,KAAK,MAAM,KAAK,GAAG,IAAI;AAC/D,YAAM,aAAa,WAAW,CAAC,GAAG,KAAK,GAAG;AAC1C,YAAM,YAAY,KAAK;AACvB,YAAM,SAAS;AACf,aAAO,KAAK,KAAK;AAAA,IACnB;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,cAAc;AACZ,QAAI;AAAA,MACF,QAAAD;AAAA,IACF,IAAI,KAAK;AACT,QAAI,SAASA,QAAO;AAAA,MAAU,KAAK;AAAA,MAAO;AAAA;AAAA,IAA+B;AACzE,SAAK,SAAS,UAAkC,EAAG,QAAO;AAC1D,QAAI,CAACA,QAAO,YAAY,KAAK,OAAO,MAAM,GAAG;AAC3C,UAAI,QAAQ,UAAU,IACpB,OAAO,SAAS;AAClB,UAAI,SAAS,KAAK,MAAM,SAAS,QAAQ;AACzC,UAAI,SAAS,KAAKA,QAAO,QAAQ,KAAK,MAAM,MAAM,GAAG,MAAM,KAAK,IAAI,GAAG;AACrE,YAAI,SAAS,KAAK,oBAAoB;AACtC,YAAI,UAAU,KAAM,QAAO;AAC3B,iBAAS;AAAA,MACX;AACA,WAAK,UAAU,GAAkB,KAAK,KAAK,KAAK,KAAK,GAAG,IAAI;AAC5D,WAAK,SAAS;AAAA,IAChB;AACA,SAAK,YAAY,KAAK;AACtB,SAAK,OAAO,MAAM;AAClB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,sBAAsB;AACpB,QAAI;AAAA,MACA,QAAAA;AAAA,IACF,IAAI,KAAK,GACT,OAAO,CAAC;AACV,QAAI,UAAU,CAAC,OAAO,UAAU;AAC9B,UAAI,KAAK,SAAS,KAAK,EAAG;AAC1B,WAAK,KAAK,KAAK;AACf,aAAOA,QAAO,WAAW,OAAO,YAAU;AACxC,YAAI,UAAU,SAA+B,QAA+B;AAAA,iBAAU,SAAS,OAA+B;AAC5H,cAAI,UAAU,UAAU,MAAoC;AAC5D,cAAI,SAAS,GAAG;AACd,gBAAI,OAAO,SAAS,OAClB,SAAS,KAAK,MAAM,SAAS,SAAS;AACxC,gBAAI,UAAU,KAAKA,QAAO,QAAQ,KAAK,MAAM,MAAM,GAAG,MAAM,KAAK,KAAK,EAAG,QAAO,UAAU,KAAmC,QAAgC;AAAA,UAC/J;AAAA,QACF,OAAO;AACL,cAAI,QAAQ,QAAQ,QAAQ,QAAQ,CAAC;AACrC,cAAI,SAAS,KAAM,QAAO;AAAA,QAC5B;AAAA,MACF,CAAC;AAAA,IACH;AACA,WAAO,QAAQ,KAAK,OAAO,CAAC;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA,EAIA,WAAW;AACT,WAAO,CAAC,KAAK,EAAE,OAAO;AAAA,MAAU,KAAK;AAAA,MAAO;AAAA;AAAA,IAA2B,GAAG;AACxE,UAAI,CAAC,KAAK,YAAY,GAAG;AACvB,aAAK,UAAU,GAAkB,KAAK,KAAK,KAAK,KAAK,GAAG,IAAI;AAC5D;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,UAAU;AACZ,QAAI,KAAK,MAAM,UAAU,EAAG,QAAO;AACnC,QAAI;AAAA,MACF,QAAAA;AAAA,IACF,IAAI,KAAK;AACT,WAAOA,QAAO,KAAKA,QAAO;AAAA,MAAU,KAAK;AAAA,MAAO;AAAA;AAAA,IAA0B,CAAC,KAAK,SAAuB,CAACA,QAAO;AAAA,MAAU,KAAK;AAAA,MAAO;AAAA;AAAA,IAAgC;AAAA,EACvK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAU;AACR,SAAK,UAAU,GAAkB,KAAK,KAAK,KAAK,KAAK,GAAG,IAAI;AAC5D,SAAK,QAAQ,KAAK,MAAM,CAAC;AACzB,SAAK,MAAM,SAAS;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA,EAIA,UAAU,OAAO;AACf,QAAI,KAAK,SAAS,MAAM,SAAS,KAAK,MAAM,UAAU,MAAM,MAAM,OAAQ,QAAO;AACjF,aAAS,IAAI,GAAG,IAAI,KAAK,MAAM,QAAQ,KAAK,EAAG,KAAI,KAAK,MAAM,CAAC,KAAK,MAAM,MAAM,CAAC,EAAG,QAAO;AAC3F,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,SAAS;AACX,WAAO,KAAK,EAAE;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,eAAe,WAAW;AACxB,WAAO,KAAK,EAAE,OAAO,QAAQ,MAAM,SAAS;AAAA,EAC9C;AAAA,EACA,aAAa,MAAM,OAAO;AACxB,QAAI,KAAK,WAAY,MAAK,cAAc,KAAK,WAAW,QAAQ,MAAM,KAAK,WAAW,SAAS,MAAM,MAAM,KAAK,EAAE,OAAO,MAAM,KAAK,CAAC,CAAC;AAAA,EACxI;AAAA,EACA,cAAc,MAAM,OAAO;AACzB,QAAI,KAAK,WAAY,MAAK,cAAc,KAAK,WAAW,QAAQ,OAAO,KAAK,WAAW,SAAS,MAAM,MAAM,KAAK,EAAE,OAAO,MAAM,KAAK,CAAC,CAAC;AAAA,EACzI;AAAA;AAAA;AAAA;AAAA,EAIA,cAAc;AACZ,QAAI,OAAO,KAAK,OAAO,SAAS;AAChC,QAAI,OAAO,KAAK,KAAK,OAAO,IAAI,KAAK,GAAI,MAAK,OAAO,KAAK,KAAK,WAAW,MAAM,KAAK,KAAK,KAAK,KAAK,EAAE;AAAA,EACxG;AAAA;AAAA;AAAA;AAAA,EAIA,gBAAgB;AACd,QAAI,OAAO,KAAK,OAAO,SAAS;AAChC,QAAI,OAAO,KAAK,KAAK,OAAO,IAAI,KAAK,GAAI,MAAK,OAAO,KAAK,KAAK,WAAW,KAAK,KAAK,KAAK,KAAK,EAAE;AAAA,EAClG;AAAA,EACA,cAAc,SAAS;AACrB,QAAI,WAAW,KAAK,WAAW,SAAS;AACtC,UAAI,QAAQ,IAAI,aAAa,KAAK,WAAW,SAAS,OAAO;AAC7D,UAAI,MAAM,QAAQ,KAAK,WAAW,KAAM,MAAK,YAAY;AACzD,WAAK,aAAa;AAAA,IACpB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,aAAa,WAAW;AACtB,QAAI,YAAY,KAAK,WAAW;AAC9B,WAAK,cAAc;AACnB,WAAK,YAAY;AAAA,IACnB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,QAAQ;AACN,QAAI,KAAK,cAAc,KAAK,WAAW,QAAQ,OAAQ,MAAK,YAAY;AACxE,QAAI,KAAK,YAAY,EAAG,MAAK,cAAc;AAAA,EAC7C;AACF;AACA,IAAM,eAAN,MAAmB;AAAA,EACjB,YAAY,SAAS,SAAS;AAC5B,SAAK,UAAU;AACf,SAAK,UAAU;AACf,SAAK,OAAO,QAAQ,SAAS,QAAQ,KAAK,OAAO,IAAI;AAAA,EACvD;AACF;AAGA,IAAM,iBAAN,MAAqB;AAAA,EACnB,YAAY,OAAO;AACjB,SAAK,QAAQ;AACb,SAAK,QAAQ,MAAM;AACnB,SAAK,QAAQ,MAAM;AACnB,SAAK,OAAO,KAAK,MAAM;AAAA,EACzB;AAAA,EACA,OAAO,QAAQ;AACb,QAAI,OAAO,SAAS,OAClB,QAAQ,UAAU;AACpB,QAAI,SAAS,GAAG;AACd,UAAI,KAAK,SAAS,KAAK,MAAM,MAAO,MAAK,QAAQ,KAAK,MAAM,MAAM;AAClE,WAAK,MAAM,KAAK,KAAK,OAAO,GAAG,CAAC;AAChC,WAAK,QAAQ;AAAA,IACf,OAAO;AACL,WAAK,SAAS,QAAQ,KAAK;AAAA,IAC7B;AACA,QAAI,OAAO,KAAK,MAAM,EAAE,OAAO,QAAQ,KAAK,MAAM,KAAK,OAAO,CAAC,GAAG,MAAM,IAAI;AAC5E,SAAK,QAAQ;AAAA,EACf;AACF;AAGA,IAAM,oBAAN,MAAM,mBAAkB;AAAA,EACtB,YAAY,OAAO,KAAK,OAAO;AAC7B,SAAK,QAAQ;AACb,SAAK,MAAM;AACX,SAAK,QAAQ;AACb,SAAK,SAAS,MAAM;AACpB,QAAI,KAAK,SAAS,EAAG,MAAK,UAAU;AAAA,EACtC;AAAA,EACA,OAAO,OAAO,OAAO,MAAM,MAAM,aAAa,MAAM,OAAO,QAAQ;AACjE,WAAO,IAAI,mBAAkB,OAAO,KAAK,MAAM,MAAM,UAAU;AAAA,EACjE;AAAA,EACA,YAAY;AACV,QAAI,OAAO,KAAK,MAAM;AACtB,QAAI,QAAQ,MAAM;AAChB,WAAK,QAAQ,KAAK,MAAM,aAAa,KAAK;AAC1C,WAAK,QAAQ;AACb,WAAK,SAAS,KAAK;AAAA,IACrB;AAAA,EACF;AAAA,EACA,IAAI,KAAK;AACP,WAAO,KAAK,OAAO,KAAK,QAAQ,CAAC;AAAA,EACnC;AAAA,EACA,IAAI,QAAQ;AACV,WAAO,KAAK,OAAO,KAAK,QAAQ,CAAC;AAAA,EACnC;AAAA,EACA,IAAI,MAAM;AACR,WAAO,KAAK,OAAO,KAAK,QAAQ,CAAC;AAAA,EACnC;AAAA,EACA,IAAI,OAAO;AACT,WAAO,KAAK,OAAO,KAAK,QAAQ,CAAC;AAAA,EACnC;AAAA,EACA,OAAO;AACL,SAAK,SAAS;AACd,SAAK,OAAO;AACZ,QAAI,KAAK,SAAS,EAAG,MAAK,UAAU;AAAA,EACtC;AAAA,EACA,OAAO;AACL,WAAO,IAAI,mBAAkB,KAAK,OAAO,KAAK,KAAK,KAAK,KAAK;AAAA,EAC/D;AACF;AAIA,SAAS,YAAY,OAAO,OAAO,aAAa;AAC9C,MAAI,OAAO,SAAS,SAAU,QAAO;AACrC,MAAI,QAAQ;AACZ,WAAS,MAAM,GAAG,MAAM,GAAG,MAAM,MAAM,UAAS;AAC9C,QAAI,QAAQ;AACZ,eAAS;AACP,UAAI,OAAO,MAAM,WAAW,KAAK,GAC/B,OAAO;AACT,UAAI,QAAQ,KAA6B;AACvC,gBAAQ;AACR;AAAA,MACF;AACA,UAAI,QAAQ,GAAsB;AAClC,UAAI,QAAQ,GAAsB;AAClC,UAAI,QAAQ,OAAO;AACnB,UAAI,SAAS,IAAsB;AACjC,iBAAS;AACT,eAAO;AAAA,MACT;AACA,eAAS;AACT,UAAI,KAAM;AACV,eAAS;AAAA,IACX;AACA,QAAI,MAAO,OAAM,KAAK,IAAI;AAAA,QAAW,SAAQ,IAAI,KAAK,KAAK;AAAA,EAC7D;AACA,SAAO;AACT;AACA,IAAM,cAAN,MAAkB;AAAA,EAChB,cAAc;AACZ,SAAK,QAAQ;AACb,SAAK,QAAQ;AACb,SAAK,MAAM;AACX,SAAK,WAAW;AAChB,SAAK,YAAY;AACjB,SAAK,OAAO;AACZ,SAAK,UAAU;AAAA,EACjB;AACF;AACA,IAAM,YAAY,IAAI,YAAY;AAOlC,IAAM,cAAN,MAAkB;AAAA;AAAA;AAAA;AAAA,EAIhB,YAIA,OAIA,QAAQ;AACN,SAAK,QAAQ;AACb,SAAK,SAAS;AAId,SAAK,QAAQ;AAIb,SAAK,WAAW;AAIhB,SAAK,SAAS;AACd,SAAK,YAAY;AAKjB,SAAK,OAAO;AAIZ,SAAK,QAAQ;AACb,SAAK,aAAa;AAClB,SAAK,MAAM,KAAK,WAAW,OAAO,CAAC,EAAE;AACrC,SAAK,QAAQ,OAAO,CAAC;AACrB,SAAK,MAAM,OAAO,OAAO,SAAS,CAAC,EAAE;AACrC,SAAK,SAAS;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAIA,cAAc,QAAQ,OAAO;AAC3B,QAAI,QAAQ,KAAK,OACf,QAAQ,KAAK;AACf,QAAI,MAAM,KAAK,MAAM;AACrB,WAAO,MAAM,MAAM,MAAM;AACvB,UAAI,CAAC,MAAO,QAAO;AACnB,UAAI,OAAO,KAAK,OAAO,EAAE,KAAK;AAC9B,aAAO,MAAM,OAAO,KAAK;AACzB,cAAQ;AAAA,IACV;AACA,WAAO,QAAQ,IAAI,MAAM,MAAM,KAAK,OAAO,MAAM,IAAI;AACnD,UAAI,SAAS,KAAK,OAAO,SAAS,EAAG,QAAO;AAC5C,UAAI,OAAO,KAAK,OAAO,EAAE,KAAK;AAC9B,aAAO,KAAK,OAAO,MAAM;AACzB,cAAQ;AAAA,IACV;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,QAAQ,KAAK;AACX,QAAI,OAAO,KAAK,MAAM,QAAQ,MAAM,KAAK,MAAM,GAAI,QAAO;AAC1D,aAAS,SAAS,KAAK,OAAQ,KAAI,MAAM,KAAK,IAAK,QAAO,KAAK,IAAI,KAAK,MAAM,IAAI;AAClF,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,KAAK,QAAQ;AACX,QAAI,MAAM,KAAK,WAAW,QACxB,KACA;AACF,QAAI,OAAO,KAAK,MAAM,KAAK,MAAM,QAAQ;AACvC,YAAM,KAAK,MAAM;AACjB,eAAS,KAAK,MAAM,WAAW,GAAG;AAAA,IACpC,OAAO;AACL,UAAI,WAAW,KAAK,cAAc,QAAQ,CAAC;AAC3C,UAAI,YAAY,KAAM,QAAO;AAC7B,YAAM;AACN,UAAI,OAAO,KAAK,aAAa,MAAM,KAAK,YAAY,KAAK,OAAO,QAAQ;AACtE,iBAAS,KAAK,OAAO,WAAW,MAAM,KAAK,SAAS;AAAA,MACtD,OAAO;AACL,YAAI,IAAI,KAAK,YACX,QAAQ,KAAK;AACf,eAAO,MAAM,MAAM,IAAK,SAAQ,KAAK,OAAO,EAAE,CAAC;AAC/C,aAAK,SAAS,KAAK,MAAM,MAAM,KAAK,YAAY,GAAG;AACnD,YAAI,MAAM,KAAK,OAAO,SAAS,MAAM,GAAI,MAAK,SAAS,KAAK,OAAO,MAAM,GAAG,MAAM,KAAK,GAAG;AAC1F,iBAAS,KAAK,OAAO,WAAW,CAAC;AAAA,MACnC;AAAA,IACF;AACA,QAAI,OAAO,KAAK,MAAM,UAAW,MAAK,MAAM,YAAY,MAAM;AAC9D,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY,OAAO,YAAY,GAAG;AAChC,QAAI,MAAM,YAAY,KAAK,cAAc,WAAW,EAAE,IAAI,KAAK;AAC/D,QAAI,OAAO,QAAQ,MAAM,KAAK,MAAM,MAAO,OAAM,IAAI,WAAW,yBAAyB;AACzF,SAAK,MAAM,QAAQ;AACnB,SAAK,MAAM,MAAM;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA,EAIA,cAAc,OAAO,QAAQ;AAC3B,SAAK,MAAM,QAAQ;AACnB,SAAK,MAAM,MAAM;AAAA,EACnB;AAAA,EACA,WAAW;AACT,QAAI,KAAK,OAAO,KAAK,aAAa,KAAK,MAAM,KAAK,YAAY,KAAK,OAAO,QAAQ;AAChF,UAAI;AAAA,QACF;AAAA,QACA;AAAA,MACF,IAAI;AACJ,WAAK,QAAQ,KAAK;AAClB,WAAK,WAAW,KAAK;AACrB,WAAK,SAAS;AACd,WAAK,YAAY;AACjB,WAAK,WAAW,KAAK,MAAM,KAAK;AAAA,IAClC,OAAO;AACL,WAAK,SAAS,KAAK;AACnB,WAAK,YAAY,KAAK;AACtB,UAAI,YAAY,KAAK,MAAM,MAAM,KAAK,GAAG;AACzC,UAAI,MAAM,KAAK,MAAM,UAAU;AAC/B,WAAK,QAAQ,MAAM,KAAK,MAAM,KAAK,UAAU,MAAM,GAAG,KAAK,MAAM,KAAK,KAAK,GAAG,IAAI;AAClF,WAAK,WAAW,KAAK;AACrB,WAAK,WAAW;AAAA,IAClB;AAAA,EACF;AAAA,EACA,WAAW;AACT,QAAI,KAAK,YAAY,KAAK,MAAM,QAAQ;AACtC,WAAK,SAAS;AACd,UAAI,KAAK,YAAY,KAAK,MAAM,OAAQ,QAAO,KAAK,OAAO;AAAA,IAC7D;AACA,WAAO,KAAK,OAAO,KAAK,MAAM,WAAW,KAAK,QAAQ;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ,IAAI,GAAG;AACb,SAAK,YAAY;AACjB,WAAO,KAAK,MAAM,KAAK,KAAK,MAAM,IAAI;AACpC,UAAI,KAAK,cAAc,KAAK,OAAO,SAAS,EAAG,QAAO,KAAK,QAAQ;AACnE,WAAK,KAAK,MAAM,KAAK,KAAK;AAC1B,WAAK,QAAQ,KAAK,OAAO,EAAE,KAAK,UAAU;AAC1C,WAAK,MAAM,KAAK,MAAM;AAAA,IACxB;AACA,SAAK,OAAO;AACZ,QAAI,KAAK,OAAO,KAAK,MAAM,UAAW,MAAK,MAAM,YAAY,KAAK,MAAM;AACxE,WAAO,KAAK,SAAS;AAAA,EACvB;AAAA,EACA,UAAU;AACR,SAAK,MAAM,KAAK,WAAW,KAAK;AAChC,SAAK,QAAQ,KAAK,OAAO,KAAK,aAAa,KAAK,OAAO,SAAS,CAAC;AACjE,SAAK,QAAQ;AACb,WAAO,KAAK,OAAO;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,KAAK,OAAO;AAChB,QAAI,OAAO;AACT,WAAK,QAAQ;AACb,YAAM,QAAQ;AACd,YAAM,YAAY,MAAM;AACxB,YAAM,QAAQ,MAAM,WAAW;AAAA,IACjC,OAAO;AACL,WAAK,QAAQ;AAAA,IACf;AACA,QAAI,KAAK,OAAO,KAAK;AACnB,WAAK,MAAM;AACX,UAAI,OAAO,KAAK,KAAK;AACnB,aAAK,QAAQ;AACb,eAAO;AAAA,MACT;AACA,aAAO,MAAM,KAAK,MAAM,KAAM,MAAK,QAAQ,KAAK,OAAO,EAAE,KAAK,UAAU;AACxE,aAAO,OAAO,KAAK,MAAM,GAAI,MAAK,QAAQ,KAAK,OAAO,EAAE,KAAK,UAAU;AACvE,UAAI,OAAO,KAAK,YAAY,MAAM,KAAK,WAAW,KAAK,MAAM,QAAQ;AACnE,aAAK,WAAW,MAAM,KAAK;AAAA,MAC7B,OAAO;AACL,aAAK,QAAQ;AACb,aAAK,WAAW;AAAA,MAClB;AACA,WAAK,SAAS;AAAA,IAChB;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,KAAK,MAAM,IAAI;AACb,QAAI,QAAQ,KAAK,YAAY,MAAM,KAAK,WAAW,KAAK,MAAM,OAAQ,QAAO,KAAK,MAAM,MAAM,OAAO,KAAK,UAAU,KAAK,KAAK,QAAQ;AACtI,QAAI,QAAQ,KAAK,aAAa,MAAM,KAAK,YAAY,KAAK,OAAO,OAAQ,QAAO,KAAK,OAAO,MAAM,OAAO,KAAK,WAAW,KAAK,KAAK,SAAS;AAC5I,QAAI,QAAQ,KAAK,MAAM,QAAQ,MAAM,KAAK,MAAM,GAAI,QAAO,KAAK,MAAM,KAAK,MAAM,EAAE;AACnF,QAAI,SAAS;AACb,aAAS,KAAK,KAAK,QAAQ;AACzB,UAAI,EAAE,QAAQ,GAAI;AAClB,UAAI,EAAE,KAAK,KAAM,WAAU,KAAK,MAAM,KAAK,KAAK,IAAI,EAAE,MAAM,IAAI,GAAG,KAAK,IAAI,EAAE,IAAI,EAAE,CAAC;AAAA,IACvF;AACA,WAAO;AAAA,EACT;AACF;AAIA,IAAM,aAAN,MAAiB;AAAA,EACf,YAAY,MAAME,KAAI;AACpB,SAAK,OAAO;AACZ,SAAK,KAAKA;AAAA,EACZ;AAAA,EACA,MAAM,OAAO,OAAO;AAClB,QAAI;AAAA,MACF,QAAAF;AAAA,IACF,IAAI,MAAM;AACV,cAAU,KAAK,MAAM,OAAO,OAAO,KAAK,IAAIA,QAAO,MAAMA,QAAO,cAAc;AAAA,EAChF;AACF;AACA,WAAW,UAAU,aAAa,WAAW,UAAU,WAAW,WAAW,UAAU,SAAS;AAIhG,IAAM,kBAAN,MAAsB;AAAA,EACpB,YAAY,MAAM,WAAW,WAAW;AACtC,SAAK,YAAY;AACjB,SAAK,YAAY;AACjB,SAAK,OAAO,OAAO,QAAQ,WAAW,YAAY,IAAI,IAAI;AAAA,EAC5D;AAAA,EACA,MAAM,OAAO,OAAO;AAClB,QAAI,QAAQ,MAAM,KAChB,UAAU;AACZ,eAAS;AACP,UAAI,QAAQ,MAAM,OAAO,GACvB,UAAU,MAAM,cAAc,GAAG,CAAC;AACpC,gBAAU,KAAK,MAAM,OAAO,OAAO,GAAG,KAAK,MAAM,KAAK,SAAS;AAC/D,UAAI,MAAM,MAAM,QAAQ,GAAI;AAC5B,UAAI,KAAK,aAAa,KAAM;AAC5B,UAAI,CAAC,MAAO;AACZ,UAAI,WAAW,KAAM;AACrB,YAAM,MAAM,SAAS,MAAM,KAAK;AAAA,IAClC;AACA,QAAI,SAAS;AACX,YAAM,MAAM,OAAO,MAAM,KAAK;AAC9B,YAAM,YAAY,KAAK,WAAW,OAAO;AAAA,IAC3C;AAAA,EACF;AACF;AACA,gBAAgB,UAAU,aAAa,WAAW,UAAU,WAAW,WAAW,UAAU,SAAS;AAKrG,IAAM,oBAAN,MAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQtB,YAIA,OAAO,UAAU,CAAC,GAAG;AACnB,SAAK,QAAQ;AACb,SAAK,aAAa,CAAC,CAAC,QAAQ;AAC5B,SAAK,WAAW,CAAC,CAAC,QAAQ;AAC1B,SAAK,SAAS,CAAC,CAAC,QAAQ;AAAA,EAC1B;AACF;AAqBA,SAAS,UAAU,MAAM,OAAO,OAAO,OAAO,WAAW,YAAY;AACnE,MAAI,QAAQ,GACV,YAAY,KAAK,OACjB;AAAA,IACE;AAAA,EACF,IAAI,MAAM,EAAE;AACd,OAAM,YAAS;AACb,SAAK,YAAY,KAAK,KAAK,MAAM,EAAG;AACpC,QAAI,SAAS,KAAK,QAAQ,CAAC;AAI3B,aAAS,IAAI,QAAQ,GAAG,IAAI,QAAQ,KAAK,EAAG,MAAK,KAAK,IAAI,CAAC,IAAI,aAAa,GAAG;AAC7E,UAAI,OAAO,KAAK,CAAC;AACjB,UAAI,QAAQ,OAAO,IAAI,MAAM,MAAM,MAAM,SAAS,MAAM,MAAM,MAAM,SAAS,QAAQ,UAAU,MAAM,MAAM,MAAM,OAAO,WAAW,UAAU,IAAI;AAC/I,cAAM,YAAY,IAAI;AACtB;AAAA,MACF;AAAA,IACF;AACA,QAAI,OAAO,MAAM,MACf,MAAM,GACN,OAAO,KAAK,QAAQ,CAAC;AAEvB,QAAI,MAAM,OAAO,KAAK,OAAO,OAAO,KAAK,SAAS,OAAO,IAAI,CAAC,KAAK,OAAqB;AACtF,cAAQ,KAAK,SAAS,OAAO,IAAI,CAAC;AAClC,eAAS;AAAA,IACX;AAEA,WAAO,MAAM,QAAO;AAClB,UAAI,MAAM,MAAM,QAAQ;AACxB,UAAI,QAAQ,SAAS,OAAO,OAAO;AACnC,UAAI,OAAO,KAAK,KAAK,GACnB,KAAK,KAAK,QAAQ,CAAC,KAAK;AAC1B,UAAI,OAAO,KAAM,QAAO;AAAA,eAAa,QAAQ,GAAI,OAAM,MAAM;AAAA,WAAO;AAClE,gBAAQ,KAAK,QAAQ,CAAC;AACtB,cAAM,QAAQ;AACd,iBAAS;AAAA,MACX;AAAA,IACF;AACA;AAAA,EACF;AACF;AACA,SAAS,WAAW,MAAM,OAAO,MAAM;AACrC,WAAS,IAAI,OAAO,OAAO,OAAO,KAAK,CAAC,MAAM,OAAqB,IAAK,KAAI,QAAQ,KAAM,QAAO,IAAI;AACrG,SAAO;AACT;AACA,SAAS,UAAU,OAAO,MAAM,WAAW,aAAa;AACtD,MAAI,QAAQ,WAAW,WAAW,aAAa,IAAI;AACnD,SAAO,QAAQ,KAAK,WAAW,WAAW,aAAa,KAAK,IAAI;AAClE;AAGA,IAAM,UAAU,OAAO,WAAW,eAAe,QAAQ,OAAO,YAAY,KAAK,QAAQ,IAAI,GAAG;AAChG,IAAI,WAAW;AACf,SAAS,MAAM,MAAM,KAAK,MAAM;AAC9B,MAAI,SAAS,KAAK,OAAO,SAAS,gBAAgB;AAClD,SAAO,OAAO,GAAG;AACjB,aAAS;AACP,QAAI,EAAE,OAAO,IAAI,OAAO,YAAY,GAAG,IAAI,OAAO,WAAW,GAAG,GAAI,YAAS;AAC3E,WAAK,OAAO,IAAI,OAAO,KAAK,MAAM,OAAO,OAAO,QAAQ,CAAC,OAAO,KAAK,QAAS,QAAO,OAAO,IAAI,KAAK,IAAI,GAAG,KAAK;AAAA,QAAI,OAAO,KAAK;AAAA,QAAG,MAAM;AAAA;AAAA,MAAyB,CAAC,IAAI,KAAK,IAAI,KAAK,QAAQ,KAAK;AAAA,QAAI,OAAO,OAAO;AAAA,QAAG,MAAM;AAAA;AAAA,MAAyB,CAAC;AACxP,UAAI,OAAO,IAAI,OAAO,YAAY,IAAI,OAAO,YAAY,EAAG;AAC5D,UAAI,CAAC,OAAO,OAAO,EAAG,QAAO,OAAO,IAAI,IAAI,KAAK;AAAA,IACnD;AAAA,EACF;AACF;AACA,IAAM,iBAAN,MAAqB;AAAA,EACnB,YAAY,WAAW,SAAS;AAC9B,SAAK,YAAY;AACjB,SAAK,UAAU;AACf,SAAK,IAAI;AACT,SAAK,WAAW;AAChB,SAAK,WAAW;AAChB,SAAK,SAAS;AACd,SAAK,QAAQ,CAAC;AACd,SAAK,QAAQ,CAAC;AACd,SAAK,QAAQ,CAAC;AACd,SAAK,aAAa;AAAA,EACpB;AAAA,EACA,eAAe;AACb,QAAI,KAAK,KAAK,WAAW,KAAK,KAAK,KAAK,UAAU,SAAS,OAAO,KAAK,UAAU,KAAK,GAAG;AACzF,QAAI,IAAI;AACN,WAAK,WAAW,GAAG,YAAY,MAAM,GAAG,MAAM,GAAG,OAAO,GAAG,QAAQ,CAAC,IAAI,GAAG,SAAS,GAAG;AACvF,WAAK,SAAS,GAAG,UAAU,MAAM,GAAG,MAAM,GAAG,KAAK,GAAG,QAAQ,EAAE,IAAI,GAAG,SAAS,GAAG;AAClF,aAAO,KAAK,MAAM,QAAQ;AACxB,aAAK,MAAM,IAAI;AACf,aAAK,MAAM,IAAI;AACf,aAAK,MAAM,IAAI;AAAA,MACjB;AACA,WAAK,MAAM,KAAK,GAAG,IAAI;AACvB,WAAK,MAAM,KAAK,CAAC,GAAG,MAAM;AAC1B,WAAK,MAAM,KAAK,CAAC;AACjB,WAAK,YAAY,KAAK;AAAA,IACxB,OAAO;AACL,WAAK,YAAY;AAAA,IACnB;AAAA,EACF;AAAA;AAAA,EAEA,OAAO,KAAK;AACV,QAAI,MAAM,KAAK,UAAW,QAAO;AACjC,WAAO,KAAK,YAAY,KAAK,UAAU,IAAK,MAAK,aAAa;AAC9D,QAAI,CAAC,KAAK,SAAU,QAAO;AAC3B,eAAS;AACP,UAAI,OAAO,KAAK,MAAM,SAAS;AAC/B,UAAI,OAAO,GAAG;AAEZ,aAAK,aAAa;AAClB,eAAO;AAAA,MACT;AACA,UAAI,MAAM,KAAK,MAAM,IAAI,GACvB,QAAQ,KAAK,MAAM,IAAI;AACzB,UAAI,SAAS,IAAI,SAAS,QAAQ;AAChC,aAAK,MAAM,IAAI;AACf,aAAK,MAAM,IAAI;AACf,aAAK,MAAM,IAAI;AACf;AAAA,MACF;AACA,UAAI,OAAO,IAAI,SAAS,KAAK;AAC7B,UAAI,QAAQ,KAAK,MAAM,IAAI,IAAI,IAAI,UAAU,KAAK;AAClD,UAAI,QAAQ,KAAK;AACf,aAAK,YAAY;AACjB,eAAO;AAAA,MACT;AACA,UAAI,gBAAgB,MAAM;AACxB,YAAI,SAAS,KAAK;AAChB,cAAI,QAAQ,KAAK,SAAU,QAAO;AAClC,cAAI,MAAM,QAAQ,KAAK;AACvB,cAAI,OAAO,KAAK,QAAQ;AACtB,gBAAI,YAAY,KAAK,KAAK,SAAS,SAAS;AAC5C,gBAAI,CAAC,aAAa,MAAM,YAAY,KAAK,SAAS,GAAI,QAAO;AAAA,UAC/D;AAAA,QACF;AACA,aAAK,MAAM,IAAI;AACf,YAAI,QAAQ,KAAK,UAAU,KAAK,IAAI,KAAK,UAAU,GAAG,GAAG;AAEvD,eAAK,MAAM,KAAK,IAAI;AACpB,eAAK,MAAM,KAAK,KAAK;AACrB,eAAK,MAAM,KAAK,CAAC;AAAA,QACnB;AAAA,MACF,OAAO;AACL,aAAK,MAAM,IAAI;AACf,aAAK,YAAY,QAAQ,KAAK;AAAA,MAChC;AAAA,IACF;AAAA,EACF;AACF;AACA,IAAM,aAAN,MAAiB;AAAA,EACf,YAAYA,SAAQ,QAAQ;AAC1B,SAAK,SAAS;AACd,SAAK,SAAS,CAAC;AACf,SAAK,YAAY;AACjB,SAAK,UAAU,CAAC;AAChB,SAAK,SAASA,QAAO,WAAW,IAAI,OAAK,IAAI,YAAY,CAAC;AAAA,EAC5D;AAAA,EACA,WAAW,OAAO;AAChB,QAAI,cAAc;AAClB,QAAI,OAAO;AACX,QAAI;AAAA,MACA,QAAAA;AAAA,IACF,IAAI,MAAM,GACV;AAAA,MACE;AAAA,IACF,IAAIA;AACN,QAAI,OAAOA,QAAO;AAAA,MAAU,MAAM;AAAA,MAAO;AAAA;AAAA,IAAgC;AACzE,QAAI,UAAU,MAAM,aAAa,MAAM,WAAW,OAAO;AACzD,QAAI,YAAY;AAChB,aAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAC1C,WAAK,KAAK,IAAI,SAAS,EAAG;AAC1B,UAAI,YAAY,WAAW,CAAC,GAC1B,QAAQ,KAAK,OAAO,CAAC;AACvB,UAAI,QAAQ,CAAC,UAAU,SAAU;AACjC,UAAI,UAAU,cAAc,MAAM,SAAS,MAAM,OAAO,MAAM,QAAQ,QAAQ,MAAM,WAAW,SAAS;AACtG,aAAK,kBAAkB,OAAO,WAAW,KAAK;AAC9C,cAAM,OAAO;AACb,cAAM,UAAU;AAAA,MAClB;AACA,UAAI,MAAM,YAAY,MAAM,MAAM,GAA2B,aAAY,KAAK,IAAI,MAAM,WAAW,SAAS;AAC5G,UAAI,MAAM,SAAS,GAAkB;AACnC,YAAI,aAAa;AACjB,YAAI,MAAM,WAAW,GAAI,eAAc,KAAK,WAAW,OAAO,MAAM,UAAU,MAAM,KAAK,WAAW;AACpG,sBAAc,KAAK,WAAW,OAAO,MAAM,OAAO,MAAM,KAAK,WAAW;AACxE,YAAI,CAAC,UAAU,QAAQ;AACrB,iBAAO;AACP,cAAI,cAAc,WAAY;AAAA,QAChC;AAAA,MACF;AAAA,IACF;AACA,WAAO,KAAK,QAAQ,SAAS,YAAa,MAAK,QAAQ,IAAI;AAC3D,QAAI,UAAW,OAAM,aAAa,SAAS;AAC3C,QAAI,CAAC,QAAQ,MAAM,OAAO,KAAK,OAAO,KAAK;AACzC,aAAO,IAAI,YAAY;AACvB,WAAK,QAAQ,MAAM,EAAE,OAAO;AAC5B,WAAK,QAAQ,KAAK,MAAM,MAAM;AAC9B,oBAAc,KAAK,WAAW,OAAO,KAAK,OAAO,KAAK,KAAK,WAAW;AAAA,IACxE;AACA,SAAK,YAAY;AACjB,WAAO,KAAK;AAAA,EACd;AAAA,EACA,aAAa,OAAO;AAClB,QAAI,KAAK,UAAW,QAAO,KAAK;AAChC,QAAI,OAAO,IAAI,YAAY,GACzB;AAAA,MACE;AAAA,MACA;AAAA,IACF,IAAI;AACN,SAAK,QAAQ;AACb,SAAK,MAAM,KAAK,IAAI,MAAM,GAAG,EAAE,OAAO,GAAG;AACzC,SAAK,QAAQ,OAAO,EAAE,OAAO,MAAM,EAAE,OAAO,UAAU;AACtD,WAAO;AAAA,EACT;AAAA,EACA,kBAAkB,OAAO,WAAW,OAAO;AACzC,QAAI,QAAQ,KAAK,OAAO,QAAQ,MAAM,GAAG;AACzC,cAAU,MAAM,KAAK,OAAO,MAAM,OAAO,KAAK,GAAG,KAAK;AACtD,QAAI,MAAM,QAAQ,IAAI;AACpB,UAAI;AAAA,QACF,QAAAA;AAAA,MACF,IAAI,MAAM;AACV,eAAS,IAAI,GAAG,IAAIA,QAAO,YAAY,QAAQ,IAAK,KAAIA,QAAO,YAAY,CAAC,KAAK,MAAM,OAAO;AAC5F,YAAI,SAASA,QAAO,aAAa,CAAC,EAAE,KAAK,OAAO,KAAK,MAAM,OAAO,MAAM,GAAG,GAAG,KAAK;AACnF,YAAI,UAAU,KAAK,MAAM,EAAE,OAAO,QAAQ,OAAO,UAAU,CAAC,GAAG;AAC7D,eAAK,SAAS,MAAM,EAA+B,OAAM,QAAQ,UAAU;AAAA,cAAO,OAAM,WAAW,UAAU;AAC7G;AAAA,QACF;AAAA,MACF;AAAA,IACF,OAAO;AACL,YAAM,QAAQ;AACd,YAAM,MAAM,KAAK,OAAO,QAAQ,QAAQ,CAAC;AAAA,IAC3C;AAAA,EACF;AAAA,EACA,UAAU,QAAQ,OAAO,KAAK,OAAO;AAEnC,aAAS,IAAI,GAAG,IAAI,OAAO,KAAK,EAAG,KAAI,KAAK,QAAQ,CAAC,KAAK,OAAQ,QAAO;AACzE,SAAK,QAAQ,OAAO,IAAI;AACxB,SAAK,QAAQ,OAAO,IAAI;AACxB,SAAK,QAAQ,OAAO,IAAI;AACxB,WAAO;AAAA,EACT;AAAA,EACA,WAAW,OAAO,OAAO,KAAK,OAAO;AACnC,QAAI;AAAA,MACA;AAAA,IACF,IAAI,OACJ;AAAA,MACE,QAAAA;AAAA,IACF,IAAI,MAAM,GACV;AAAA,MACE;AAAA,IACF,IAAIA;AACN,aAAS,MAAM,GAAG,MAAM,GAAG,OAAO;AAChC,eAAS,IAAIA,QAAO;AAAA,QAAU;AAAA,QAAO,MAAM,IAA0B;AAAA;AAAA,MAA0B,KAAI,KAAK,GAAG;AACzG,YAAI,KAAK,CAAC,KAAK,OAAqB;AAClC,cAAI,KAAK,IAAI,CAAC,KAAK,GAAkB;AACnC,gBAAI,KAAK,MAAM,IAAI,CAAC;AAAA,UACtB,OAAO;AACL,gBAAI,SAAS,KAAK,KAAK,IAAI,CAAC,KAAK,EAAmB,SAAQ,KAAK,UAAU,KAAK,MAAM,IAAI,CAAC,GAAG,OAAO,KAAK,KAAK;AAC/G;AAAA,UACF;AAAA,QACF;AACA,YAAI,KAAK,CAAC,KAAK,MAAO,SAAQ,KAAK,UAAU,KAAK,MAAM,IAAI,CAAC,GAAG,OAAO,KAAK,KAAK;AAAA,MACnF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACF;AACA,IAAM,QAAN,MAAY;AAAA,EACV,YAAYA,SAAQ,OAAO,WAAW,QAAQ;AAC5C,SAAK,SAASA;AACd,SAAK,QAAQ;AACb,SAAK,SAAS;AACd,SAAK,aAAa;AAClB,SAAK,cAAc;AACnB,SAAK,cAAc;AACnB,SAAK,SAAS,CAAC;AACf,SAAK,YAAY;AACjB,SAAK,wBAAwB;AAC7B,SAAK,uBAAuB;AAC5B,SAAK,oBAAoB;AACzB,SAAK,SAAS,IAAI,YAAY,OAAO,MAAM;AAC3C,SAAK,SAAS,IAAI,WAAWA,SAAQ,KAAK,MAAM;AAChD,SAAK,UAAUA,QAAO,IAAI,CAAC;AAC3B,QAAI;AAAA,MACF;AAAA,IACF,IAAI,OAAO,CAAC;AACZ,SAAK,SAAS,CAAC,MAAM,MAAM,MAAMA,QAAO,IAAI,CAAC,GAAG,IAAI,CAAC;AACrD,SAAK,YAAY,UAAU,UAAU,KAAK,OAAO,MAAM,OAAOA,QAAO,eAAe,IAAI,IAAI,eAAe,WAAWA,QAAO,OAAO,IAAI;AAAA,EAC1I;AAAA,EACA,IAAI,YAAY;AACd,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,UAAU;AACR,QAAI,SAAS,KAAK,QAChB,MAAM,KAAK;AAEb,QAAI,YAAY,KAAK,SAAS,CAAC;AAC/B,QAAI,SAAS;AAQb,QAAI,KAAK,oBAAoB,OAAkD,OAAO,UAAU,GAAG;AACjG,UAAI,CAAC,CAAC,IAAI;AACV,aAAO,EAAE,YAAY,KAAK,EAAE,MAAM,UAAU,EAAE,MAAM,EAAE,MAAM,SAAS,CAAC,KAAK,KAAK,uBAAuB;AAAA,MAAC;AACxG,WAAK,oBAAoB,KAAK,uBAAuB;AAAA,IACvD;AAIA,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAI,QAAQ,OAAO,CAAC;AACpB,iBAAS;AACP,aAAK,OAAO,YAAY;AACxB,YAAI,MAAM,MAAM,KAAK;AACnB,oBAAU,KAAK,KAAK;AAAA,QACtB,WAAW,KAAK,aAAa,OAAO,WAAW,MAAM,GAAG;AACtD;AAAA,QACF,OAAO;AACL,cAAI,CAAC,SAAS;AACZ,sBAAU,CAAC;AACX,4BAAgB,CAAC;AAAA,UACnB;AACA,kBAAQ,KAAK,KAAK;AAClB,cAAI,MAAM,KAAK,OAAO,aAAa,KAAK;AACxC,wBAAc,KAAK,IAAI,OAAO,IAAI,GAAG;AAAA,QACvC;AACA;AAAA,MACF;AAAA,IACF;AACA,QAAI,CAAC,UAAU,QAAQ;AACrB,UAAI,WAAW,WAAW,aAAa,OAAO;AAC9C,UAAI,UAAU;AACZ,YAAI,QAAS,SAAQ,IAAI,iBAAiB,KAAK,QAAQ,QAAQ,CAAC;AAChE,eAAO,KAAK,YAAY,QAAQ;AAAA,MAClC;AACA,UAAI,KAAK,OAAO,QAAQ;AACtB,YAAI,WAAW,QAAS,SAAQ,IAAI,uBAAuB,KAAK,OAAO,YAAY,KAAK,OAAO,QAAQ,KAAK,OAAO,UAAU,KAAK,IAAI,OAAO;AAC7I,cAAM,IAAI,YAAY,iBAAiB,GAAG;AAAA,MAC5C;AACA,UAAI,CAAC,KAAK,WAAY,MAAK,aAAa;AAAA,IAC1C;AACA,QAAI,KAAK,cAAc,SAAS;AAC9B,UAAI,WAAW,KAAK,aAAa,QAAQ,QAAQ,CAAC,EAAE,MAAM,KAAK,YAAY,QAAQ,CAAC,IAAI,KAAK,YAAY,SAAS,eAAe,SAAS;AAC1I,UAAI,UAAU;AACZ,YAAI,QAAS,SAAQ,IAAI,kBAAkB,KAAK,QAAQ,QAAQ,CAAC;AACjE,eAAO,KAAK,YAAY,SAAS,SAAS,CAAC;AAAA,MAC7C;AAAA,IACF;AACA,QAAI,KAAK,YAAY;AACnB,UAAI,eAAe,KAAK,cAAc,IAAI,IAAI,KAAK,aAAa;AAChE,UAAI,UAAU,SAAS,cAAc;AACnC,kBAAU,KAAK,CAAC,GAAG,MAAM,EAAE,QAAQ,EAAE,KAAK;AAC1C,eAAO,UAAU,SAAS,aAAc,WAAU,IAAI;AAAA,MACxD;AACA,UAAI,UAAU,KAAK,OAAK,EAAE,YAAY,GAAG,EAAG,MAAK;AAAA,IACnD,WAAW,UAAU,SAAS,GAAG;AAI/B,YAAO,UAAS,IAAI,GAAG,IAAI,UAAU,SAAS,GAAG,KAAK;AACpD,YAAI,QAAQ,UAAU,CAAC;AACvB,iBAAS,IAAI,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AAC7C,cAAI,QAAQ,UAAU,CAAC;AACvB,cAAI,MAAM,UAAU,KAAK,KAAK,MAAM,OAAO,SAAS,OAAsC,MAAM,OAAO,SAAS,KAAoC;AAClJ,iBAAK,MAAM,QAAQ,MAAM,SAAS,MAAM,OAAO,SAAS,MAAM,OAAO,UAAU,GAAG;AAChF,wBAAU,OAAO,KAAK,CAAC;AAAA,YACzB,OAAO;AACL,wBAAU,OAAO,KAAK,CAAC;AACvB,uBAAS;AAAA,YACX;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,UAAI,UAAU,SAAS,GAA4B,WAAU;AAAA,QAAO;AAAA,QAA4B,UAAU,SAAS;AAAA;AAAA,MAA0B;AAAA,IAC/I;AACA,SAAK,cAAc,UAAU,CAAC,EAAE;AAChC,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,IAAK,KAAI,UAAU,CAAC,EAAE,MAAM,KAAK,YAAa,MAAK,cAAc,UAAU,CAAC,EAAE;AACpH,WAAO;AAAA,EACT;AAAA,EACA,OAAO,KAAK;AACV,QAAI,KAAK,aAAa,QAAQ,KAAK,YAAY,IAAK,OAAM,IAAI,WAAW,8BAA8B;AACvG,SAAK,YAAY;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,aAAa,OAAO,QAAQ,OAAO;AACjC,QAAI,QAAQ,MAAM,KAChB;AAAA,MACE,QAAAA;AAAA,IACF,IAAI;AACN,QAAI,OAAO,UAAU,KAAK,QAAQ,KAAK,IAAI,SAAS;AACpD,QAAI,KAAK,aAAa,QAAQ,QAAQ,KAAK,UAAW,QAAO,MAAM,YAAY,IAAI,QAAQ;AAC3F,QAAI,KAAK,WAAW;AAClB,UAAI,WAAW,MAAM,cAAc,MAAM,WAAW,QAAQ,QAC1D,SAAS,WAAW,MAAM,WAAW,OAAO;AAC9C,eAAS,SAAS,KAAK,UAAU,OAAO,KAAK,GAAG,UAAS;AACvD,YAAI,QAAQ,KAAK,OAAO,QAAQ,MAAM,OAAO,KAAK,EAAE,KAAK,OAAO,OAAOA,QAAO,QAAQ,MAAM,OAAO,OAAO,KAAK,EAAE,IAAI;AACrH,YAAI,QAAQ,MAAM,OAAO,WAAW,CAAC,aAAa,OAAO,KAAK,SAAS,WAAW,KAAK,MAAM,SAAS;AACpG,gBAAM,QAAQ,QAAQ,KAAK;AAC3B,cAAI,QAAS,SAAQ,IAAI,OAAO,KAAK,QAAQ,KAAK,IAAI,kBAAkBA,QAAO,QAAQ,OAAO,KAAK,EAAE,CAAC,GAAG;AACzG,iBAAO;AAAA,QACT;AACA,YAAI,EAAE,kBAAkB,SAAS,OAAO,SAAS,UAAU,KAAK,OAAO,UAAU,CAAC,IAAI,EAAG;AACzF,YAAI,QAAQ,OAAO,SAAS,CAAC;AAC7B,YAAI,iBAAiB,QAAQ,OAAO,UAAU,CAAC,KAAK,EAAG,UAAS;AAAA,YAAW;AAAA,MAC7E;AAAA,IACF;AACA,QAAI,gBAAgBA,QAAO;AAAA,MAAU,MAAM;AAAA,MAAO;AAAA;AAAA,IAAgC;AAClF,QAAI,gBAAgB,GAAG;AACrB,YAAM,OAAO,aAAa;AAC1B,UAAI,QAAS,SAAQ,IAAI,OAAO,KAAK,QAAQ,KAAK,IAAI,uBAAuBA,QAAO;AAAA,QAAQ,gBAAgB;AAAA;AAAA,MAA4B,CAAC,GAAG;AAC5I,aAAO;AAAA,IACT;AACA,QAAI,MAAM,MAAM,UAAU,MAAyB;AACjD,aAAO,MAAM,MAAM,SAAS,OAAwB,MAAM,YAAY,GAAG;AAAA,MAAC;AAAA,IAC5E;AACA,QAAI,UAAU,KAAK,OAAO,WAAW,KAAK;AAC1C,aAAS,IAAI,GAAG,IAAI,QAAQ,UAAS;AACnC,UAAI,SAAS,QAAQ,GAAG,GACtB,OAAO,QAAQ,GAAG,GAClB,MAAM,QAAQ,GAAG;AACnB,UAAI,OAAO,KAAK,QAAQ,UAAU,CAAC;AACnC,UAAI,aAAa,OAAO,QAAQ,MAAM,MAAM;AAC5C,UAAI,OAAO,KAAK,OAAO;AACvB,iBAAW,MAAM,QAAQ,MAAM,OAAO,KAAK,QAAQ,WAAW,KAAK,GAAG;AACtE,UAAI,QAAS,SAAQ,IAAI,OAAO,KAAK,QAAQ,UAAU,IAAI,UAAU,SAAS,UAAkC,IAAI,UAAU,aAAaA,QAAO;AAAA,QAAQ,SAAS;AAAA;AAAA,MAA4B,CAAC,EAAE,QAAQA,QAAO,QAAQ,IAAI,CAAC,MAAM,KAAK,GAAG,cAAc,QAAQ,KAAK,SAAS,GAAG;AACnR,UAAI,KAAM,QAAO;AAAA,eAAc,WAAW,MAAM,MAAO,QAAO,KAAK,UAAU;AAAA,UAAO,OAAM,KAAK,UAAU;AAAA,IAC3G;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,aAAa,OAAO,WAAW;AAC7B,QAAI,MAAM,MAAM;AAChB,eAAS;AACP,UAAI,CAAC,KAAK,aAAa,OAAO,MAAM,IAAI,EAAG,QAAO;AAClD,UAAI,MAAM,MAAM,KAAK;AACnB,uBAAe,OAAO,SAAS;AAC/B,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAAA,EACA,YAAY,QAAQ,QAAQ,WAAW;AACrC,QAAI,WAAW,MACb,YAAY;AACd,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAI,QAAQ,OAAO,CAAC,GAClB,QAAQ,OAAO,KAAK,CAAC,GACrB,WAAW,QAAQ,KAAK,KAAK,CAAC;AAChC,UAAI,OAAO,UAAU,KAAK,QAAQ,KAAK,IAAI,SAAS;AACpD,UAAI,MAAM,SAAS;AACjB,YAAI,UAAW;AACf,oBAAY;AACZ,cAAM,QAAQ;AACd,YAAI,QAAS,SAAQ,IAAI,OAAO,KAAK,QAAQ,KAAK,IAAI,cAAc;AACpE,YAAI,OAAO,KAAK,aAAa,OAAO,SAAS;AAC7C,YAAI,KAAM;AAAA,MACZ;AACA,UAAI,QAAQ,MAAM,MAAM,GACtB,YAAY;AACd,eAAS,IAAI,GAAG,MAAM,YAAY,KAAK,IAAI,IAA+B,KAAK;AAC7E,YAAI,QAAS,SAAQ,IAAI,YAAY,KAAK,QAAQ,KAAK,IAAI,qBAAqB;AAChF,YAAI,OAAO,KAAK,aAAa,OAAO,SAAS;AAC7C,YAAI,KAAM;AACV,YAAI,QAAS,aAAY,KAAK,QAAQ,KAAK,IAAI;AAAA,MACjD;AACA,eAAS,UAAU,MAAM,gBAAgB,KAAK,GAAG;AAC/C,YAAI,QAAS,SAAQ,IAAI,OAAO,KAAK,QAAQ,MAAM,IAAI,uBAAuB;AAC9E,aAAK,aAAa,QAAQ,SAAS;AAAA,MACrC;AACA,UAAI,KAAK,OAAO,MAAM,MAAM,KAAK;AAC/B,YAAI,YAAY,MAAM,KAAK;AACzB;AACA,kBAAQ;AAAA,QACV;AACA,cAAM,gBAAgB,OAAO,QAAQ;AACrC,YAAI,QAAS,SAAQ,IAAI,OAAO,KAAK,QAAQ,KAAK,IAAI,wBAAwB,KAAK,OAAO,QAAQ,KAAK,CAAC,GAAG;AAC3G,uBAAe,OAAO,SAAS;AAAA,MACjC,WAAW,CAAC,YAAY,SAAS,QAAQ,MAAM,OAAO;AACpD,mBAAW;AAAA,MACb;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA,EAEA,YAAY,OAAO;AACjB,UAAM,MAAM;AACZ,WAAO,KAAK,MAAM;AAAA,MAChB,QAAQ,kBAAkB,OAAO,KAAK;AAAA,MACtC,SAAS,KAAK,OAAO;AAAA,MACrB,OAAO,KAAK;AAAA,MACZ,iBAAiB,KAAK,OAAO;AAAA,MAC7B,QAAQ,KAAK;AAAA,MACb,OAAO,KAAK,OAAO,CAAC,EAAE;AAAA,MACtB,QAAQ,MAAM,MAAM,KAAK,OAAO,CAAC,EAAE;AAAA,MACnC,eAAe,KAAK,OAAO;AAAA,IAC7B,CAAC;AAAA,EACH;AAAA,EACA,QAAQ,OAAO;AACb,QAAIE,OAAM,aAAa,WAAW,oBAAI,QAAQ,IAAI,IAAI,KAAK;AAC3D,QAAI,CAACA,IAAI,UAAS,IAAI,OAAOA,MAAK,OAAO,cAAc,KAAK,aAAa,CAAC;AAC1E,WAAOA,MAAK;AAAA,EACd;AACF;AACA,SAAS,eAAe,OAAO,WAAW;AACxC,WAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,QAAI,QAAQ,UAAU,CAAC;AACvB,QAAI,MAAM,OAAO,MAAM,OAAO,MAAM,UAAU,KAAK,GAAG;AACpD,UAAI,UAAU,CAAC,EAAE,QAAQ,MAAM,MAAO,WAAU,CAAC,IAAI;AACrD;AAAA,IACF;AAAA,EACF;AACA,YAAU,KAAK,KAAK;AACtB;AACA,IAAM,UAAN,MAAc;AAAA,EACZ,YAAY,QAAQ,OAAO,UAAU;AACnC,SAAK,SAAS;AACd,SAAK,QAAQ;AACb,SAAK,WAAW;AAAA,EAClB;AAAA,EACA,OAAO,MAAM;AACX,WAAO,CAAC,KAAK,YAAY,KAAK,SAAS,IAAI,KAAK;AAAA,EAClD;AACF;AACA,IAAM,KAAK,OAAK;AAahB,IAAM,iBAAN,MAAqB;AAAA;AAAA;AAAA;AAAA,EAInB,YAAY,MAAM;AAChB,SAAK,QAAQ,KAAK;AAClB,SAAK,QAAQ,KAAK,SAAS;AAC3B,SAAK,SAAS,KAAK,UAAU;AAC7B,SAAK,QAAQ,KAAK,SAAS;AAC3B,SAAK,OAAO,KAAK,SAAS,MAAM;AAChC,SAAK,SAAS,KAAK,WAAW;AAAA,EAChC;AACF;AAMA,IAAM,WAAN,MAAM,kBAAiB,OAAO;AAAA;AAAA;AAAA;AAAA,EAI5B,YAAY,MAAM;AAChB,UAAM;AAIN,SAAK,WAAW,CAAC;AACjB,QAAI,KAAK,WAAW,GAAuB,OAAM,IAAI,WAAW,mBAAmB,KAAK,OAAO,oCAAoC,EAAqB,GAAG;AAC3J,QAAI,YAAY,KAAK,UAAU,MAAM,GAAG;AACxC,SAAK,gBAAgB,UAAU;AAC/B,aAAS,IAAI,GAAG,IAAI,KAAK,iBAAiB,IAAK,WAAU,KAAK,EAAE;AAChE,QAAI,WAAW,OAAO,KAAK,KAAK,QAAQ,EAAE,IAAI,OAAK,KAAK,SAAS,CAAC,EAAE,CAAC,CAAC;AACtE,QAAI,YAAY,CAAC;AACjB,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,IAAK,WAAU,KAAK,CAAC,CAAC;AAC5D,aAAS,QAAQ,QAAQ,MAAM,OAAO;AACpC,gBAAU,MAAM,EAAE,KAAK,CAAC,MAAM,KAAK,YAAY,OAAO,KAAK,CAAC,CAAC,CAAC;AAAA,IAChE;AACA,QAAI,KAAK,UAAW,UAAS,YAAY,KAAK,WAAW;AACvD,UAAI,OAAO,SAAS,CAAC;AACrB,UAAI,OAAO,QAAQ,SAAU,QAAO,SAAS,IAAI;AACjD,eAAS,IAAI,GAAG,IAAI,SAAS,UAAS;AACpC,YAAI,OAAO,SAAS,GAAG;AACvB,YAAI,QAAQ,GAAG;AACb,kBAAQ,MAAM,MAAM,SAAS,GAAG,CAAC;AAAA,QACnC,OAAO;AACL,cAAI,QAAQ,SAAS,IAAI,CAAC,IAAI;AAC9B,mBAAS,IAAI,CAAC,MAAM,IAAI,GAAG,IAAK,SAAQ,SAAS,GAAG,GAAG,MAAM,KAAK;AAClE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,SAAK,UAAU,IAAI,QAAQ,UAAU,IAAI,CAAC,MAAM,MAAM,SAAS,OAAO;AAAA,MACpE,MAAM,KAAK,KAAK,gBAAgB,SAAY;AAAA,MAC5C,IAAI;AAAA,MACJ,OAAO,UAAU,CAAC;AAAA,MAClB,KAAK,SAAS,QAAQ,CAAC,IAAI;AAAA,MAC3B,OAAO,KAAK;AAAA,MACZ,SAAS,KAAK,gBAAgB,KAAK,aAAa,QAAQ,CAAC,IAAI;AAAA,IAC/D,CAAC,CAAC,CAAC;AACH,QAAI,KAAK,YAAa,MAAK,UAAU,KAAK,QAAQ,OAAO,GAAG,KAAK,WAAW;AAC5E,SAAK,SAAS;AACd,SAAK,eAAe;AACpB,QAAI,aAAa,YAAY,KAAK,SAAS;AAC3C,SAAK,UAAU,KAAK;AACpB,SAAK,mBAAmB,KAAK,eAAe,CAAC;AAC7C,SAAK,cAAc,IAAI,YAAY,KAAK,iBAAiB,MAAM;AAC/D,aAAS,IAAI,GAAG,IAAI,KAAK,iBAAiB,QAAQ,IAAK,MAAK,YAAY,CAAC,IAAI,KAAK,iBAAiB,CAAC,EAAE;AACtG,SAAK,eAAe,KAAK,iBAAiB,IAAI,cAAc;AAC5D,SAAK,SAAS,YAAY,KAAK,QAAQ,WAAW;AAClD,SAAK,OAAO,YAAY,KAAK,SAAS;AACtC,SAAK,OAAO,YAAY,KAAK,IAAI;AACjC,SAAK,UAAU,KAAK;AACpB,SAAK,aAAa,KAAK,WAAW,IAAI,WAAS,OAAO,SAAS,WAAW,IAAI,WAAW,YAAY,KAAK,IAAI,KAAK;AACnH,SAAK,WAAW,KAAK;AACrB,SAAK,WAAW,KAAK,YAAY,CAAC;AAClC,SAAK,qBAAqB,KAAK,sBAAsB;AACrD,SAAK,iBAAiB,KAAK;AAC3B,SAAK,YAAY,KAAK,aAAa;AACnC,SAAK,UAAU,KAAK,QAAQ,MAAM,SAAS;AAC3C,SAAK,UAAU,KAAK,aAAa;AACjC,SAAK,MAAM,KAAK,SAAS,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC,CAAC;AAAA,EACxD;AAAA,EACA,YAAY,OAAO,WAAW,QAAQ;AACpC,QAAI,QAAQ,IAAI,MAAM,MAAM,OAAO,WAAW,MAAM;AACpD,aAAS,KAAK,KAAK,SAAU,SAAQ,EAAE,OAAO,OAAO,WAAW,MAAM;AACtE,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,QAAQ,OAAO,MAAM,QAAQ,OAAO;AAClC,QAAI,QAAQ,KAAK;AACjB,QAAI,QAAQ,MAAM,CAAC,EAAG,QAAO;AAC7B,aAAS,MAAM,MAAM,OAAO,CAAC,OAAK;AAChC,UAAI,WAAW,MAAM,KAAK,GACxB,OAAO,WAAW;AACpB,UAAI,SAAS,MAAM,KAAK;AACxB,UAAI,QAAQ,MAAO,QAAO;AAC1B,eAAS,MAAM,OAAO,YAAY,IAAI,MAAM,KAAK,MAAO,KAAI,MAAM,GAAG,KAAK,MAAO,QAAO;AACxF,UAAI,KAAM,QAAO;AAAA,IACnB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,UAAU,OAAO,UAAU;AACzB,QAAI,OAAO,KAAK;AAChB,aAAS,MAAM,GAAG,MAAM,GAAG,OAAO;AAChC,eAAS,IAAI,KAAK;AAAA,QAAU;AAAA,QAAO,MAAM,IAA0B;AAAA;AAAA,MAA0B,GAAG,QAAO,KAAK,GAAG;AAC7G,aAAK,OAAO,KAAK,CAAC,MAAM,OAAqB;AAC3C,cAAI,KAAK,IAAI,CAAC,KAAK,EAAkB,QAAO,KAAK,IAAI,KAAK,MAAM,IAAI,CAAC,CAAC;AAAA,mBAAW,KAAK,IAAI,CAAC,KAAK,EAAmB,QAAO,KAAK,MAAM,IAAI,CAAC;AAAA,cAAO;AAAA,QACnJ;AACA,YAAI,QAAQ,YAAY,QAAQ,EAAkB,QAAO,KAAK,MAAM,IAAI,CAAC;AAAA,MAC3E;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,UAAU,OAAO,MAAM;AACrB,WAAO,KAAK,OAAO,QAAQ,IAA0B,IAAI;AAAA,EAC3D;AAAA;AAAA;AAAA;AAAA,EAIA,UAAU,OAAO,MAAM;AACrB,YAAQ,KAAK;AAAA,MAAU;AAAA,MAAO;AAAA;AAAA,IAAwB,IAAI,QAAQ;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA,EAIA,YAAY,OAAO,QAAQ;AACzB,WAAO,CAAC,CAAC,KAAK,WAAW,OAAO,OAAK,KAAK,SAAS,OAAO,IAAI;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA,EAIA,WAAW,OAAO,QAAQ;AACxB,QAAI,QAAQ,KAAK;AAAA,MAAU;AAAA,MAAO;AAAA;AAAA,IAAgC;AAClE,QAAI,SAAS,QAAQ,OAAO,KAAK,IAAI;AACrC,aAAS,IAAI,KAAK;AAAA,MAAU;AAAA,MAAO;AAAA;AAAA,IAA0B,GAAG,UAAU,MAAM,KAAK,GAAG;AACtF,UAAI,KAAK,KAAK,CAAC,KAAK,OAAqB;AACvC,YAAI,KAAK,KAAK,IAAI,CAAC,KAAK,EAAkB,KAAI,KAAK,KAAK,MAAM,IAAI,CAAC;AAAA,YAAO;AAAA,MAC5E;AACA,eAAS,OAAO,KAAK,KAAK,MAAM,IAAI,CAAC,CAAC;AAAA,IACxC;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,WAAW,OAAO;AAChB,QAAI,SAAS,CAAC;AACd,aAAS,IAAI,KAAK;AAAA,MAAU;AAAA,MAAO;AAAA;AAAA,IAA0B,KAAI,KAAK,GAAG;AACvE,UAAI,KAAK,KAAK,CAAC,KAAK,OAAqB;AACvC,YAAI,KAAK,KAAK,IAAI,CAAC,KAAK,EAAkB,KAAI,KAAK,KAAK,MAAM,IAAI,CAAC;AAAA,YAAO;AAAA,MAC5E;AACA,WAAK,KAAK,KAAK,IAAI,CAAC,IAAI,SAAiC,OAAO,GAAG;AACjE,YAAI,QAAQ,KAAK,KAAK,IAAI,CAAC;AAC3B,YAAI,CAAC,OAAO,KAAK,CAAC,GAAGD,OAAMA,KAAI,KAAK,KAAK,KAAK,EAAG,QAAO,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK;AAAA,MAClF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAU,QAAQ;AAGhB,QAAI,OAAO,OAAO,OAAO,OAAO,OAAO,UAAS,SAAS,GAAG,IAAI;AAChE,QAAI,OAAO,MAAO,MAAK,UAAU,KAAK,QAAQ,OAAO,GAAG,OAAO,KAAK;AACpE,QAAI,OAAO,KAAK;AACd,UAAI,OAAO,KAAK,SAAS,OAAO,GAAG;AACnC,UAAI,CAAC,KAAM,OAAM,IAAI,WAAW,yBAAyB,OAAO,GAAG,EAAE;AACrE,WAAK,MAAM;AAAA,IACb;AACA,QAAI,OAAO,WAAY,MAAK,aAAa,KAAK,WAAW,IAAI,OAAK;AAChE,UAAI,QAAQ,OAAO,WAAW,KAAK,OAAK,EAAE,QAAQ,CAAC;AACnD,aAAO,QAAQ,MAAM,KAAK;AAAA,IAC5B,CAAC;AACD,QAAI,OAAO,cAAc;AACvB,WAAK,eAAe,KAAK,aAAa,MAAM;AAC5C,WAAK,mBAAmB,KAAK,iBAAiB,IAAI,CAAC,GAAG,MAAM;AAC1D,YAAI,QAAQ,OAAO,aAAa,KAAK,OAAK,EAAE,QAAQ,EAAE,QAAQ;AAC9D,YAAI,CAAC,MAAO,QAAO;AACnB,YAAI,OAAO,OAAO,OAAO,OAAO,OAAO,CAAC,GAAG,CAAC,GAAG;AAAA,UAC7C,UAAU,MAAM;AAAA,QAClB,CAAC;AACD,aAAK,aAAa,CAAC,IAAI,eAAe,IAAI;AAC1C,eAAO;AAAA,MACT,CAAC;AAAA,IACH;AACA,QAAI,OAAO,eAAgB,MAAK,UAAU,OAAO;AACjD,QAAI,OAAO,QAAS,MAAK,UAAU,KAAK,aAAa,OAAO,OAAO;AACnE,QAAI,OAAO,UAAU,KAAM,MAAK,SAAS,OAAO;AAChD,QAAI,OAAO,KAAM,MAAK,WAAW,KAAK,SAAS,OAAO,OAAO,IAAI;AACjE,QAAI,OAAO,gBAAgB,KAAM,MAAK,eAAe,OAAO;AAC5D,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,cAAc;AACZ,WAAO,KAAK,SAAS,SAAS;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAQ,MAAM;AACZ,WAAO,KAAK,YAAY,KAAK,UAAU,IAAI,IAAI,OAAO,QAAQ,KAAK,WAAW,KAAK,QAAQ,MAAM,IAAI,EAAE,QAAQ,IAAI;AAAA,EACrH;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAAU;AACZ,WAAO,KAAK,UAAU;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,UAAU;AACZ,WAAO,KAAK,QAAQ,MAAM,KAAK,IAAI,CAAC,CAAC;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA,EAIA,kBAAkB,MAAM;AACtB,QAAI,OAAO,KAAK;AAChB,WAAO,QAAQ,OAAO,IAAI,KAAK,IAAI,KAAK;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAIA,aAAa,SAAS;AACpB,QAAI,SAAS,OAAO,KAAK,KAAK,QAAQ,GACpC,QAAQ,OAAO,IAAI,MAAM,KAAK;AAChC,QAAI,QAAS,UAAS,QAAQ,QAAQ,MAAM,GAAG,GAAG;AAChD,UAAIC,MAAK,OAAO,QAAQ,IAAI;AAC5B,UAAIA,OAAM,EAAG,OAAMA,GAAE,IAAI;AAAA,IAC3B;AACA,QAAI,WAAW;AACf,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,IAAK,KAAI,CAAC,MAAM,CAAC,GAAG;AACrD,eAAS,IAAI,KAAK,SAAS,OAAO,CAAC,CAAC,GAAGA,MAAKA,MAAK,KAAK,KAAK,GAAG,MAAM,QAAsB,EAAC,aAAa,WAAW,IAAI,WAAW,KAAK,UAAU,CAAC,IAAIA,GAAE,IAAI;AAAA,IAC9J;AACA,WAAO,IAAI,QAAQ,SAAS,OAAO,QAAQ;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,YAAY,MAAM;AACvB,WAAO,IAAI,UAAS,IAAI;AAAA,EAC1B;AACF;AACA,SAAS,KAAK,MAAM,KAAK;AACvB,SAAO,KAAK,GAAG,IAAI,KAAK,MAAM,CAAC,KAAK;AACtC;AACA,SAAS,aAAa,QAAQ;AAC5B,MAAI,OAAO;AACX,WAAS,SAAS,QAAQ;AACxB,QAAI,UAAU,MAAM,EAAE;AACtB,SAAK,MAAM,OAAO,MAAM,EAAE,OAAO,OAAO,WAAW,QAAQ,MAAM,MAAM,YAAY,MAAM,EAAE,OAAO;AAAA,MAAU,MAAM;AAAA,MAAO;AAAA;AAAA,IAA2B,MAAM,CAAC,QAAQ,KAAK,QAAQ,MAAM,OAAQ,QAAO;AAAA,EACvM;AACA,SAAO;AACT;AACA,SAAS,eAAe,MAAM;AAC5B,MAAI,KAAK,UAAU;AACjB,QAAI,OAAO,KAAK,SAAS,IAA4B;AACrD,WAAO,CAAC,OAAO,UAAU,KAAK,SAAS,OAAO,KAAK,KAAK,IAAI;AAAA,EAC9D;AACA,SAAO,KAAK;AACd;;;ACtuDA,IAAM,eAAe;AAArB,IACE,SAAS;AADX,IAEE,SAAS;AAFX,IAGE,YAAY;AAHd,IAIE,iBAAiB;AAJnB,IAKE,mBAAmB;AALrB,IAME,MAAM;AANR,IAOE,gBAAgB;AAPlB,IAQE,SAAS;AARX,IASE,mBAAmB;AATrB,IAUE,YAAY;AAVd,IAWE,SAAS;AAXX,IAYE,0BAA0B;AAZ5B,IAaE,kBAAkB;AAbpB,IAcE,0BAA0B;AAd5B,IAeE,WAAW;AAfb,IAgBE,kBAAkB;AAhBpB,IAiBE,+BAA+B;AAjBjC,IAkBE,SAAS;AAlBX,IAmBE,uBAAuB;AAnBzB,IAoBE,oCAAoC;AApBtC,IAqBE,gBAAgB;AArBlB,IAsBE,6BAA6B;AAtB/B,IAuBE,UAAU;AAvBZ,IAwBE,YAAY;AAxBd,IAyBE,WAAW;AAzBb,IA0BE,cAAc;AA1BhB,IA2BE,eAAe;AA3BjB,IA4BE,eAAe;AA5BjB,IA6BE,gBAAgB;AA7BlB,IA8BE,eAAe;AA9BjB,IA+BE,gBAAgB;AA/BlB,IAgCE,gBAAgB;AAhClB,IAiCE,iBAAiB;AAjCnB,IAkCE,eAAe;AAlCjB,IAmCE,eAAe;AAnCjB,IAoCE,gBAAgB;AApClB,IAqCE,gBAAgB;AArClB,IAsCE,iBAAiB;AAtCnB,IAuCE,gBAAgB;AAvClB,IAwCE,iBAAiB;AAxCnB,IAyCE,iBAAiB;AAzCnB,IA0CE,kBAAkB;AA1CpB,IA2CE,oBAAoB;AA3CtB,IA4CE,0BAA0B;AA5C5B,IA6CE,aAAa;AA7Cf,IA8CE,gBAAgB;AA9ClB,IA+CE,YAAY;AA/Cd,IAgDE,kBAAkB;AAhDpB,IAiDE,iBAAiB;AAjDnB,IAkDE,iBAAiB;AACnB,IAAM,UAAU;AAAhB,IACE,iBAAiB;AADnB,IAEE,QAAQ;AAFV,IAGE,MAAM;AAHR,IAIE,OAAO;AAJT,IAKE,YAAY;AALd,IAME,MAAM;AANR,IAOE,YAAY;AAPd,IAQE,aAAa;AARf,IASE,cAAc;AAThB,IAUE,cAAc;AAVhB,IAWE,YAAY;AAXd,IAYE,WAAW;AAZb,IAaE,WAAW;AAbb,IAcE,WAAW;AAdb,IAeE,WAAW;AAfb,IAgBE,WAAW;AACb,IAAM,YAAY,oBAAI,IAAI,CAAC,yBAAyB,iBAAiB,yBAAyB,YAAY,SAAS,WAAW,iBAAiB,8BAA8B,WAAW,eAAe,4BAA4B,cAAc,mBAAmB,yBAAyB,sBAAsB,mCAAmC,iBAAiB,gBAAgB,gBAAgB,aAAa,CAAC;AACrZ,SAAS,YAAY,IAAI;AACvB,SAAO,MAAM,WAAW,MAAM;AAChC;AACA,SAAS,MAAM,IAAI;AACjB,SAAO,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM;AAC3E;AACA,IAAM,WAAW,IAAI,kBAAkB,CAAC,OAAO,UAAU;AACvD,MAAI;AACJ,MAAI,MAAM,OAAO,GAAG;AAClB,UAAM,YAAY,GAAG;AAAA,EACvB,WAAW,MAAM,QAAQ,QAAQ,cAAc;AAC7C,QAAI,YAAY,MAAM,IAAI,EAAG,OAAM,YAAY,kBAAkB,CAAC;AAAA,EACpE,aAAa,OAAO,MAAM,KAAK,EAAE,KAAK,KAAK,YAAY,IAAI,MAAM,MAAM,SAAS,cAAc,GAAG;AAC/F,QAAI,SAAS;AACb,WAAO,MAAM,QAAQ,SAAS,MAAM,QAAQ,KAAK;AAC/C,YAAM,QAAQ;AACd;AAAA,IACF;AACA,QAAI,MAAM,QAAQ,WAAW,MAAM,QAAQ,kBAAkB,MAAM,QAAQ,KAAM,OAAM,YAAY,gBAAgB,CAAC,MAAM;AAAA,EAC5H,WAAW,YAAY,MAAM,IAAI,GAAG;AAClC,UAAM,YAAY,WAAW,CAAC;AAAA,EAChC;AACF,GAAG;AAAA,EACD,YAAY;AACd,CAAC;AACD,IAAM,cAAc,IAAI,kBAAkB,CAAC,OAAO,UAAU;AAC1D,MAAI,UAAU,MAAM;AACpB,MAAI,QAAQ,MAAO;AACnB,MAAI,OAAO,MAAM,KAAK,EAAE;AACxB,MAAI,QAAQ,WAAW,QAAQ,gBAAgB;AAC7C,QAAI,QAAQ,GACV,QAAQ;AACV,eAAS;AACP,UAAI,MAAM,QAAQ,MAAO;AAAA,eAAiB,MAAM,QAAQ,IAAK,UAAS,IAAI,QAAQ;AAAA,UAAO;AACzF,YAAM,QAAQ;AACd;AAAA,IACF;AACA,QAAI,SAAS,QAAQ,UAAU,MAAM,QAAQ,WAAW,MAAM,QAAQ,kBAAkB,MAAM,QAAQ,MAAM;AAC1G,UAAI,QAAQ,QAAQ,OAAQ,OAAM,YAAY,QAAQ,CAAC,KAAK;AAAA,UAAO,OAAM,YAAY,MAAM;AAAA,IAC7F;AAAA,EACF;AACF,CAAC;AAGD,IAAM,eAAe;AAArB,IACE,YAAY;AADd,IAEE,iBAAiB;AAFnB,IAGE,UAAU;AAHZ,IAIE,SAAS;AAJX,IAKE,YAAY;AACd,SAAS,QAAQ,QAAQC,SAAQ,OAAO;AACtC,OAAK,SAAS;AACd,OAAK,SAASA;AACd,OAAK,QAAQ;AACb,OAAK,QAAQ,SAAS,OAAO,OAAO,OAAO,QAAQ,IAAI,KAAKA,WAAUA,WAAU,KAAK,SAAS,SAAS;AACzG;AACA,IAAM,YAAY,IAAI,QAAQ,MAAM,GAAG,CAAC;AACxC,SAAS,YAAYC,QAAO;AAC1B,MAAI,QAAQ;AACZ,WAAS,IAAI,GAAG,IAAIA,OAAM,QAAQ,IAAK,UAASA,OAAM,WAAW,CAAC,KAAK,MAAM,IAAI,QAAQ,IAAI;AAC7F,SAAO;AACT;AACA,IAAM,cAAc,IAAI,IAAI,CAAC,CAAC,aAAa,CAAC,GAAG,CAAC,cAAc,cAAc,GAAG,CAAC,cAAc,OAAO,GAAG,CAAC,eAAe,UAAU,cAAc,GAAG,CAAC,cAAc,MAAM,GAAG,CAAC,eAAe,SAAS,cAAc,GAAG,CAAC,eAAe,SAAS,OAAO,GAAG,CAAC,gBAAgB,SAAS,UAAU,cAAc,GAAG,CAAC,cAAc,SAAS,GAAG,CAAC,eAAe,YAAY,cAAc,GAAG,CAAC,eAAe,YAAY,OAAO,GAAG,CAAC,gBAAgB,YAAY,UAAU,cAAc,GAAG,CAAC,eAAe,YAAY,MAAM,GAAG,CAAC,gBAAgB,YAAY,SAAS,cAAc,GAAG,CAAC,gBAAgB,YAAY,SAAS,OAAO,GAAG,CAAC,iBAAiB,YAAY,SAAS,UAAU,cAAc,CAAC,EAAE,IAAI,CAAC,CAAC,MAAM,KAAK,MAAM,CAAC,MAAM,QAAQ,SAAS,CAAC,CAAC;AACltB,IAAM,cAAc,IAAI,eAAe;AAAA,EACrC,OAAO;AAAA,EACP,OAAO,SAAS,MAAM,GAAG,OAAO;AAC9B,QAAI,QAAQ,QAAQ,gBAAgB,UAAU,IAAI,IAAI,MAAM,QAAQ,YAAY,QAAQ,iBAAiB,QAAQ,QAAQ,UAAW,QAAO,QAAQ;AACnJ,WAAO;AAAA,EACT;AAAA,EACA,MAAM,SAAS,MAAM,OAAO,OAAO;AACjC,QAAI,QAAQ,OAAQ,QAAO,IAAI,QAAQ,SAAS,YAAY,MAAM,KAAK,MAAM,KAAK,MAAM,GAAG,CAAC,GAAG,CAAC;AAChG,QAAI,QAAQ,OAAQ,QAAO,QAAQ;AACnC,QAAI,QAAQ,UAAU,QAAQ,YAAY,QAAQ,UAAU,QAAQ,iBAAkB,QAAO,IAAI,QAAQ,SAAS,GAAG,YAAY;AACjI,QAAI,YAAY,IAAI,IAAI,EAAG,QAAO,IAAI,QAAQ,SAAS,GAAG,YAAY,IAAI,IAAI,IAAI,QAAQ,QAAQ,YAAY;AAC9G,WAAO;AAAA,EACT;AAAA,EACA,KAAK,SAAS;AACZ,WAAO,QAAQ;AAAA,EACjB;AACF,CAAC;AACD,IAAM,cAAc,IAAI,kBAAkB,WAAS;AACjD,WAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,QAAI,MAAM,QAAQ,QAAQ,WAAW,CAAC,EAAG;AACzC,UAAM,QAAQ;AAAA,EAChB;AACA,MAAI,KAAK,KAAK,OAAO,aAAa,MAAM,IAAI,CAAC,EAAG;AAChD,WAAS,MAAM,KAAI,OAAO;AACxB,QAAI,OAAO,MAAM,KAAK,GAAG;AACzB,QAAI,QAAQ,SAAS,QAAQ,IAAK;AAClC,QAAI,QAAQ,aAAa,QAAQ,OAAO,QAAQ,WAAW,QAAQ,kBAAkB,QAAQ,KAAM,OAAM,YAAY,YAAY;AACjI;AAAA,EACF;AACF,CAAC;AACD,IAAM,UAAU,IAAI,kBAAkB,CAAC,OAAO,UAAU;AACtD,MAAI;AAAA,IACF;AAAA,EACF,IAAI,MAAM;AACV,MAAI,QAAQ,QAAQ,iBAAiB,cAAc;AACnD,MAAI,QAAQ,QAAQ,WAAW;AAC/B,MAAI,UAAU,EAAE,QAAQ;AACxB,MAAI,UAAU,QAAQ,aAAa;AACnC,MAAI,QAAQ,MAAM;AAClB,aAAS;AACP,QAAI,MAAM,OAAO,GAAG;AAClB;AAAA,IACF,WAAW,UAAU,MAAM,QAAQ,WAAW;AAC5C,UAAI,MAAM,KAAK,CAAC,KAAK,WAAW;AAC9B,cAAM,QAAQ,CAAC;AAAA,MACjB,OAAO;AACL,YAAI,MAAM,OAAO,OAAO;AACtB,gBAAM,YAAY,kBAAkB,CAAC;AACrC;AAAA,QACF;AACA;AAAA,MACF;AAAA,IACF,WAAW,WAAW,MAAM,QAAQ,WAAW;AAC7C,UAAI,MAAM,OAAO,OAAO;AACtB,cAAM,QAAQ;AACd,YAAI,UAAU,MAAM;AACpB,YAAI,WAAW,GAAG;AAChB,gBAAM,QAAQ;AACd,qBAAW,OAAO,OAAO;AAAA,QAC3B;AACA,cAAM,YAAY,MAAM;AACxB;AAAA,MACF;AACA;AAAA,IACF,WAAW,MAAM,QAAQ,aAAa,CAAC,WAAW,MAAM,KAAK,CAAC,IAAI,IAAI;AAEpE,YAAM,QAAQ,CAAC;AAAA,IACjB,WAAW,MAAM,QAAQ,UAAU,CAAC,QAAQ,MAAM,KAAK,CAAC,KAAK,SAAS,MAAM,KAAK,CAAC,KAAK,QAAQ;AAC7F,UAAI,MAAM,OAAO,OAAO;AACtB,cAAM,YAAY,WAAW,OAAO,IAAI,CAAC;AACzC;AAAA,MACF;AACA;AAAA,IACF,WAAW,MAAM,QAAQ,SAAS;AAChC,UAAI,MAAM;AACR,cAAM,QAAQ;AAAA,MAChB,WAAW,MAAM,OAAO,OAAO;AAC7B,cAAM,YAAY,SAAS;AAC3B;AAAA,MACF;AACA;AAAA,IACF,OAAO;AACL,YAAM,QAAQ;AAAA,IAChB;AAAA,EACF;AACA,MAAI,MAAM,MAAM,MAAO,OAAM,YAAY,aAAa;AACxD,CAAC;AACD,SAAS,WAAW,OAAO,IAAI;AAC7B,MAAI,MAAM,UAAU;AAClB,aAAS,IAAI,GAAG,IAAI,KAAK,MAAM,QAAQ,MAAM,MAAM,QAAQ,IAAI,IAAK,OAAM,QAAQ;AAAA,EACpF,WAAW,MAAM,UAAU;AACzB,aAAS,IAAI,GAAG,IAAI,KAAK,MAAM,MAAM,IAAI,GAAG,IAAK,OAAM,QAAQ;AAAA,EACjE,WAAW,MAAM,UAAU;AACzB,aAAS,IAAI,GAAG,IAAI,KAAK,MAAM,MAAM,IAAI,GAAG,IAAK,OAAM,QAAQ;AAAA,EACjE,WAAW,MAAM,UAAU;AACzB,aAAS,IAAI,GAAG,IAAI,KAAK,MAAM,MAAM,IAAI,GAAG,IAAK,OAAM,QAAQ;AAAA,EACjE,WAAW,MAAM,UAAU;AACzB,QAAI,MAAM,QAAQ,WAAW;AAC3B,YAAM,QAAQ;AACd,aAAO,MAAM,QAAQ,KAAK,MAAM,QAAQ,cAAc,MAAM,QAAQ,eAAe,MAAM,QAAQ,eAAe,MAAM,QAAQ,QAAS,OAAM,QAAQ;AACrJ,UAAI,MAAM,QAAQ,WAAY,OAAM,QAAQ;AAAA,IAC9C;AAAA,EACF;AACF;AACA,IAAM,qBAAqB,UAAU;AAAA,EACnC,8CAAkD,KAAK;AAAA,EACvD,iHAAiH,KAAK;AAAA,EACtH,wBAAwB,KAAK;AAAA,EAC7B,yCAAyC,KAAK;AAAA,EAC9C,QAAQ,KAAK;AAAA,EACb,iBAAiB,KAAK;AAAA,EACtB,SAAS,KAAK;AAAA,EACd,MAAM,KAAK;AAAA,EACX,cAAc,KAAK;AAAA,EACnB,+BAA+B,KAAK,SAAS,KAAK,YAAY;AAAA,EAC9D,mCAAmC,KAAK,SAAS,KAAK,WAAW,KAAK,YAAY,CAAC;AAAA,EACnF,gCAAgC,KAAK,WAAW,KAAK,SAAS;AAAA,EAC9D,cAAc,KAAK;AAAA,EACnB,gDAAgD,KAAK,SAAS,KAAK,YAAY;AAAA,EAC/E,SAAS,KAAK;AAAA,EACd,QAAQ,KAAK;AAAA,EACb,QAAQ,KAAK;AAAA,EACb,cAAc,KAAK,QAAQ,KAAK,MAAM;AAAA,EACtC,QAAQ,KAAK;AAAA,EACb,UAAU,KAAK;AAAA,EACf,YAAY,KAAK;AAAA,EACjB,OAAO,KAAK;AAAA,EACZ,WAAW,KAAK;AAAA,EAChB,UAAU,KAAK;AAAA,EACf,UAAU,KAAK;AAAA,EACf,IAAI,KAAK;AAAA,EACT,OAAO,KAAK;AAAA,EACZ,OAAO,KAAK;AAAA,EACZ,OAAO,KAAK;AAAA,EACZ,KAAK,KAAK;AAAA,EACV,OAAO,KAAK;AACd,CAAC;AAGD,IAAM,kBAAkB;AAAA,EACtB,WAAW;AAAA,EACX,OAAO;AAAA,EACP,IAAI;AAAA,EACJ,KAAK;AAAA,EACL,IAAI;AAAA,EACJ,KAAK;AAAA,EACL,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,MAAM;AAAA,EACN,OAAO;AAAA,EACP,KAAK;AAAA,EACL,MAAM;AAAA,EACN,MAAM;AAAA,EACN,OAAO;AAAA,EACP,KAAK;AAAA,EACL,MAAM;AAAA,EACN,OAAO;AAAA,EACP,UAAU;AAAA,EACV,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,IAAI;AAAA,EACJ,QAAQ;AAAA,EACR,UAAU;AAAA,EACV,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,MAAM;AAAA,EACN,OAAO;AAAA,EACP,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,MAAM;AAAA,EACN,KAAK;AAAA,EACL,OAAO;AAAA,EACP,OAAO;AAAA,EACP,MAAM;AACR;AACA,IAAM,SAAS,SAAS,YAAY;AAAA,EAClC,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,WAAW;AAAA,EACX,MAAM;AAAA,EACN,WAAW;AAAA,EACX,SAAS;AAAA,EACT,SAAS;AAAA,EACT,WAAW,CAAC,CAAC,WAAW,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,EAAE,GAAG,CAAC,SAAS,KAAK,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK,uBAAuB,KAAK,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,cAAc,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,aAAa,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,SAAS,GAAG,CAAC,YAAY,IAAI,KAAK,IAAI,KAAK,IAAI,GAAG,GAAG,CAAC,YAAY,IAAI,KAAK,IAAI,KAAK,IAAI,GAAG,CAAC;AAAA,EACrd,aAAa,CAAC,kBAAkB;AAAA,EAChC,cAAc,CAAC,GAAG,CAAC;AAAA,EACnB,iBAAiB;AAAA,EACjB,WAAW;AAAA,EACX,YAAY,CAAC,aAAa,aAAa,UAAU,SAAS,GAAG,GAAG,GAAG,GAAG,CAAC;AAAA,EACvE,UAAU;AAAA,IACR,UAAU,CAAC,GAAG,CAAC;AAAA,EACjB;AAAA,EACA,aAAa,CAAC;AAAA,IACZ,MAAM;AAAA,IACN,KAAK,WAAS,gBAAgB,KAAK,KAAK;AAAA,EAC1C,CAAC;AAAA,EACD,WAAW;AACb,CAAC;;;AC9UD,IAAM,QAAqB,IAAI,YAAY;AAC3C,IAAM,aAA0B,oBAAI,IAAI,CAAC,UAAU,QAAQ,sBAAsB,mBAAmB,oBAAoB,gBAAgB,aAAa,CAAC;AACtJ,SAAS,MAAM,MAAM;AACnB,SAAO,CAAC,MAAM,KAAK,UAAU;AAC3B,QAAI,MAAO,QAAO;AAClB,QAAIC,MAAK,KAAK,KAAK,SAAS,cAAc;AAC1C,QAAIA,IAAI,KAAIA,KAAI,IAAI;AACpB,WAAO;AAAA,EACT;AACF;AACA,IAAM,oBAAoB;AAAA,EACxB,oBAAiC,MAAM,UAAU;AAAA,EACjD,iBAA8B,MAAM,OAAO;AAAA,EAC3C,aAAa,MAAM,KAAK,OAAO;AAC7B,QAAI,MAAO,UAAS,QAAQ,KAAK,KAAK,YAAY,OAAO,QAAQ,MAAM,aAAa;AAClF,UAAI,MAAM,QAAQ,eAAgB,KAAI,OAAO,UAAU;AAAA,eAAW,MAAM,QAAQ,KAAM;AAAA,IACxF;AAAA,EACF;AAAA,EACA,gBAAgB,OAAO,KAAK;AAC1B,QAAI,IAAI;AACR,QAAI;AAAA,MACF;AAAA,IACF,IAAI;AACJ,QAAI,WAAW,KAAK,KAAK,gBAAgB,QAAQ,OAAO,SAAS,SAAS,GAAG,SAAS;AACtF,aAAS,KAAK,KAAK,SAAS,QAAQ,GAAG,IAAI,KAAK,GAAG,aAAa;AAC9D,UAAI,GAAG,QAAQ,oBAAoB,KAAK,GAAG,iBAAiB,QAAQ,OAAO,SAAS,SAAS,GAAG,SAAS,KAAM,KAAI,IAAI,SAAS,aAAa,WAAW;AAAA,IAC1J;AAAA,EACF;AAAA,EACA,gBAAgB,MAAM,KAAK;AACzB,aAAS,QAAQ,KAAK,KAAK,YAAY,OAAO,QAAQ,MAAM,aAAa;AACvE,UAAI,MAAM,QAAQ,eAAgB,KAAI,OAAO,UAAU;AAAA,eAAW,MAAM,QAAQ,OAAO,MAAM,QAAQ,WAAY;AAAA,IACnH;AAAA,EACF;AAAA,EACA,UAAU,MAAM,KAAK;AACnB,aAAS,OAAO,MAAM,QAAQ,KAAK,KAAK,YAAY,OAAO,QAAQ,MAAM,aAAa;AACpF,UAAI,MAAM,QAAQ,mBAAmB,CAAC,QAAQ,CAAC,cAAc,KAAK,KAAK,IAAI,GAAI,KAAI,OAAO,UAAU;AACpG,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EACA,gBAA6B,MAAM,UAAU;AAAA,EAC7C,WAAwB,MAAM,UAAU;AAAA,EACxC,WAAW;AACb;AACA,SAAS,SAAS,KAAK,MAAM;AAC3B,MAAI,SAAS,MAAM,IAAI,IAAI;AAC3B,MAAI,OAAQ,QAAO;AACnB,MAAI,cAAc,CAAC,GACjB,MAAM;AACR,WAAS,IAAIC,OAAM,MAAM;AACvB,QAAI,OAAO,IAAI,YAAYA,MAAK,MAAMA,MAAK,EAAE;AAC7C,gBAAY,KAAK;AAAA,MACf,OAAO;AAAA,MACP;AAAA,IACF,CAAC;AAAA,EACH;AACA,OAAK,OAAO,SAAS,gBAAgB,EAAE,QAAQ,CAAAA,UAAQ;AACrD,QAAIA,MAAK,MAAM;AACb,UAAI,SAAS,kBAAkBA,MAAK,IAAI;AACxC,UAAI,UAAU,OAAOA,OAAM,KAAK,GAAG,KAAK,CAAC,OAAO,WAAW,IAAIA,MAAK,IAAI,EAAG,QAAO;AAClF,YAAM;AAAA,IACR,WAAWA,MAAK,KAAKA,MAAK,OAAO,MAAM;AAErC,eAAS,KAAK,SAAS,KAAKA,MAAK,IAAI,EAAG,aAAY,KAAK,CAAC;AAC1D,aAAO;AAAA,IACT;AAAA,EACF,CAAC;AACD,QAAM,IAAI,MAAM,WAAW;AAC3B,SAAO;AACT;AACA,IAAM,aAAa;AACnB,IAAM,eAAe,CAAC,UAAU,gBAAgB,WAAW,cAAc;AAKzE,SAAS,sBAAsB,SAAS;AACtC,MAAI,QAAQ,WAAW,QAAQ,KAAK,EAAE,aAAa,QAAQ,KAAK,EAAE;AAClE,MAAI,aAAa,QAAQ,MAAM,IAAI,IAAI,GAAI,QAAO;AAClD,MAAI,SAAS,MAAM,QAAQ,kBAAkB,MAAM,KAAK,MAAM,OAAO,MAAM,WAAW,KAAK,QAAQ,MAAM,SAAS,MAAM,MAAM,MAAM,EAAE,CAAC;AACvI,MAAI,CAAC,UAAU,CAAC,QAAQ,SAAU,QAAO;AACzC,MAAI,UAAU,CAAC;AACf,WAAS,MAAM,OAAO,KAAK,MAAM,IAAI,QAAQ;AAC3C,QAAI,WAAW,IAAI,IAAI,IAAI,EAAG,WAAU,QAAQ,OAAO,SAAS,QAAQ,MAAM,KAAK,GAAG,CAAC;AAAA,EACzF;AACA,SAAO;AAAA,IACL;AAAA,IACA,MAAM,SAAS,MAAM,OAAO,QAAQ;AAAA,IACpC,UAAU;AAAA,EACZ;AACF;AACA,IAAM,UAAuB,CAAC,mBAAmB,gBAAgB,aAAa,WAAW,cAAc,YAAY,cAAc,eAAe,YAAY,SAAS,QAAQ,MAAM,EAAE,IAAI,QAAM;AAAA,EAC7L,OAAO;AAAA,EACP,MAAM;AACR,EAAE,EAAE,OAAoB,CAAC,mBAAmB,kBAAkB,kBAAkB,iBAAiB,mBAAmB,mBAAmB,eAAe,gBAAgB,qBAAqB,0BAA0B,mBAAmB,0BAA0B,wBAAwB,sBAAsB,YAAY,YAAY,mBAAmB,oBAAoB,aAAa,mBAAmB,qBAAqB,sBAAsB,iBAAiB,iBAAiB,WAAW,eAAe,iBAAiB,oBAAoB,cAAc,oBAAoB,qBAAqB,YAAY,qBAAqB,eAAe,eAAe,uBAAuB,aAAa,sBAAsB,kBAAkB,uBAAuB,WAAW,iBAAiB,6BAA6B,mBAAmB,sBAAsB,kBAAkB,kBAAkB,mBAAmB,gBAAgB,kBAAkB,sBAAsB,iBAAiB,eAAe,iBAAiB,eAAe,cAAc,YAAY,gBAAgB,aAAa,qBAAqB,sBAAsB,sBAAsB,gBAAgB,yBAAyB,kBAAkB,eAAe,cAAc,WAAW,mBAAmB,EAAE,IAAI,QAAM;AAAA,EAC7vC,OAAO;AAAA,EACP,MAAM;AACR,EAAE,CAAC,EAAE,OAAoB,CAAC,QAAQ,aAAa,SAAS,eAAe,WAAW,SAAS,aAAa,OAAO,QAAQ,OAAO,cAAc,UAAU,SAAS,OAAO,gBAAgB,OAAO,SAAS,SAAS,MAAM,EAAE,IAAI,QAAM;AAAA,EAC/N,OAAO;AAAA,EACP,MAAM;AACR,EAAE,CAAC,EAAE,OAAoB,CAAC,OAAO,SAAS,OAAO,SAAS,OAAO,SAAS,OAAO,cAAc,YAAY,OAAO,WAAW,WAAW,QAAQ,OAAO,UAAU,aAAa,QAAQ,QAAQ,QAAQ,UAAU,UAAU,WAAW,WAAW,WAAW,QAAQ,QAAQ,OAAO,MAAM,SAAS,cAAc,cAAc,QAAQ,OAAO,WAAW,UAAU,OAAO,OAAO,QAAQ,OAAO,QAAQ,OAAO,OAAO,SAAS,YAAY,QAAQ,QAAQ,YAAY,SAAS,WAAW,SAAS,UAAU,OAAO,QAAQ,KAAK,EAAE,IAAI,QAAM;AAAA,EAC1gB,OAAO;AAAA,EACP,MAAM;AACR,EAAE,CAAC;AACH,IAAM,WAAW,CAAc,kBAAkB,iCAAkC;AAAA,EACjF,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AACR,CAAC,GAAgB,kBAAkB,uCAAwC;AAAA,EACzE,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AACR,CAAC,GAAgB,kBAAkB,oBAAqB;AAAA,EACtD,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AACR,CAAC,GAAgB,kBAAkB,sCAAwC;AAAA,EACzE,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AACR,CAAC,GAAgB,kBAAkB,gBAAiB;AAAA,EAClD,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AACR,CAAC,GAAgB,kBAAkB,8BAAgC;AAAA,EACjE,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AACR,CAAC,GAAgB,kBAAkB,2DAA+D;AAAA,EAChG,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AACR,CAAC,GAAgB,kBAAkB,oBAAoB;AAAA,EACrD,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AACR,CAAC,GAAgB,kBAAkB,kCAAkC;AAAA,EACnE,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AACR,CAAC,CAAC;AAIF,IAAM,mBAAgC,QAAQ,cAA2B,iBAA8B,QAAQ,OAAO,QAAQ,CAAC,CAAC;AAChI,SAAS,UAAU,SAAS;AAC1B,MAAI;AAAA,IACF;AAAA,IACA;AAAA,EACF,IAAI;AACJ,MAAI,aAAa,QAAQ,WAAW,KAAK,EAAE;AAC3C,MAAI,QAAQ;AACZ,aAAS;AACP,QAAI,SAAS,KAAK,YAAY,GAAG;AACjC,QAAI,CAAC,QAAQ;AACX;AAAA,IACF,WAAW,OAAO,QAAQ,WAAW;AACnC,YAAM,OAAO;AAAA,IACf,WAAW,OAAO,QAAQ,UAAU,OAAO,QAAQ,aAAa;AAC9D,UAAI,QAAQ,cAAc,MAAM,IAAI,QAAQ,QAAQ,WAAY,SAAQ;AACxE,aAAO;AAAA,IACT,WAAW,OAAO,QAAQ,eAAe;AACvC,aAAO;AAAA,IACT,WAAW,OAAO,KAAK,GAAG,WAAW,GAAG;AACtC,aAAO;AAAA,IACT,OAAO;AACL;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AACA,SAAS,WAAW,SAAS,MAAM;AACjC,MAAI,OAAO,QAAQ,cAAc,IAAI;AACrC,MAAI,OAAO,QAAQ,OAAO,QAAQ,KAAK,EAAE,GACvC,KAAK,KAAK,OAAO,KAAK,KAAK;AAG7B,MAAI,YAAY,KAAK,KAAK,IAAI,KAAK,QAAQ,KAAK,KAAK,KAAK,OAAO,CAAC,KAAK,KAAK,QAAQ,MAAM,SAAS,IAAI,QAAQ,KAAK,EAAE,CAAC,KAAK,QAAQ,WAAW,QAAQ,KAAK,EAAE,KAAK,KAAM,QAAO;AAIhL,MAAI,oDAAoD,KAAK,QAAQ,SAAS,KAAK,QAAQ,WAAW,QAAQ,KAAK,EAAE,IAAI,KAAM,QAAO;AACtI,SAAO,OAAO,QAAQ;AACxB;AAMA,IAAM,iBAA8B,WAAW,OAAO;AAAA,EACpD,MAAM;AAAA,EACN,QAAqB,OAAO,UAAU;AAAA,IACpC,OAAO,CAAc,eAAe,IAAI;AAAA,MACtC,MAAM,aAAW;AACf,YAAI;AACJ,YAAI,OAAO,YAAY,KAAK,QAAQ,SAAS,KAAK,UAAU,OAAO,KAAK,QAAQ;AAChF,gBAAQ,KAAK,WAAW,SAAS,IAAI,OAAO,QAAQ,OAAO,SAAS,KAAK,QAAQ,SAAS;AAAA,MAC5F;AAAA,MACA,WAAW,aAAW;AACpB,YAAI;AACJ,YAAI,QAAQ,UAAU,OAAO;AAC7B,gBAAQ,KAAK,WAAW,SAAS,SAAS,QAAQ,IAAI,OAAO,QAAQ,OAAO,SAAS,KAAK,QAAQ,SAAS;AAAA,MAC7G;AAAA,MACA,aAAa,QAAM,oBAAoB,KAAK,GAAG,SAAS,IAAI,GAAG,aAAa,GAAG,SAAS;AAAA,MACxF,+BAA+B,QAAM,YAAY,KAAK,GAAG,SAAS,IAAI,GAAG,aAAa,GAAG,SAAS;AAAA,MAClG,cAAc,QAAM,kCAAkC,KAAK,GAAG,SAAS,IAAI,GAAG,aAAa,GAAG,SAAS;AAAA,MACvG,gBAAgB,QAAM;AACpB,YAAI,YAAY,KAAK,GAAG,SAAS,EAAG,QAAO,GAAG,aAAa,GAAG;AAC9D,eAAO,GAAG,SAAS;AAAA,MACrB;AAAA,MACA,qFAAkG,gBAAgB;AAAA,QAChH,SAAS;AAAA,MACX,CAAC;AAAA,MACD,mGAAgH,gBAAgB;AAAA,QAC9H,SAAS;AAAA,MACX,CAAC;AAAA,MACD,gDAA6D,gBAAgB;AAAA,QAC3E,SAAS;AAAA,MACX,CAAC;AAAA,MACD,kBAAkB,QAAM,GAAG,aAAa,GAAG;AAAA,MAC3C,uBAAuB,MAAM;AAAA,MAC7B,QAAQ,aAAW;AACjB,YAAI;AACJ,YAAI,QAAQ,UAAU,OAAO;AAC7B,gBAAQ,KAAK,SAAS,WAAW,SAAS,KAAK,OAAO,QAAQ,OAAO,SAAS,KAAK,QAAQ,SAAS;AAAA,MACtG;AAAA,IACF,CAAC,GAAgB,aAAa,IAAI;AAAA,MAChC,sEAAsE;AAAA,MACtE,MAAM,CAAC,MAAM,WAAW;AAAA,QACtB,MAAM,KAAK,OAAO;AAAA,QAClB,IAAI,KAAK,MAAM,KAAK,MAAM,MAAM,IAAI,SAAS,IAAI;AAAA,MACnD;AAAA,MACA,uBAAuB,CAAC,MAAM,WAAW;AAAA,QACvC,MAAM,MAAM,IAAI,OAAO,KAAK,IAAI,EAAE;AAAA,QAClC,IAAI,KAAK;AAAA,MACX;AAAA,IACF,CAAC,CAAC;AAAA,EACJ,CAAC;AAAA,EACD,cAAc;AAAA,IACZ,eAAe;AAAA,MACb,UAAU,CAAC,KAAK,KAAK,KAAK,KAAK,KAAK,OAAO,KAAK;AAAA,MAChD,gBAAgB,CAAC,KAAK,MAAM,MAAM,KAAK,KAAK,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,KAAK,KAAK,MAAM,IAAI;AAAA,IACzG;AAAA,IACA,eAAe;AAAA,MACb,MAAM;AAAA,IACR;AAAA;AAAA,IAEA,eAAe;AAAA,EACjB;AACF,CAAC;AAID,SAAS,SAAS;AAChB,SAAO,IAAI,gBAAgB,gBAAgB,CAAC,eAAe,KAAK,GAAG;AAAA,IACjE,cAAc;AAAA,EAChB,CAAC,GAAG,eAAe,KAAK,GAAG;AAAA,IACzB,cAAc;AAAA,EAChB,CAAC,CAAC,CAAC;AACL;",
  "names": ["parser", "i", "id", "indent", "space", "id", "node"]
}
