{
  "filename": "concatenation-of-array",
  "title": "Concatenation of Array",
  "keywords": [
    "concatenation",
    "array",
    "leetcode",
    "1929",
    "given",
    "integer",
    "nums",
    "length",
    "create",
    "ans"
  ],
  "description": "<h2>Concatenation of Array</h2><p>Leetcode 1929. Concatenation of Array</p><p></p><p>You are given an integer array `nums` of length `n`. Create an array `ans` of length `2n` where `ans[i] == nums[i]` and `ans[i + n] == nums[i]` for `0 <= i < n` **(0-indexed)**.</p><p></p><p>Specifically, `ans` is the concatenation of two `nums` arrays.</p><p></p><p>Return the array `ans`.</p><h3>Examples:</h3><ul><li>Input: nums = [1,4,1,2]<br><br>Output: [1,4,1,2,1,4,1,2]</li><li>Input: nums = [22,21,20,1]<br><br>Output: [22,21,20,1,22,21,20,1]</li></ul><h3>Constraints:</h3><ul><li> `1 <= nums.length <= 1000`.</li><li> `1 <= nums[i] <= 1000`</li></ul>",
  "languages": {
    "python": {
      "template": "def concatenationOfArray(nums):\n    ",
      "solution_text": "<h3>Concatenation of Array Solution</h3><p><strong>Algorithm:</strong> Create a new array of length 2n where each element appears twice - once at its original index and once at index + n.</p><p><strong>Time Complexity:</strong> O(n) where n is the length of the input array</p><p><strong>Space Complexity:</strong> O(n) for the result array</p><p><strong>Key Insights:</strong></p><ul><li>Simple array construction problem</li><li>First n elements are copies of original array</li><li>Next n elements are another copy of original array</li><li>Can be solved with array concatenation or manual index mapping</li></ul>",
      "solution_code": "def concatenationOfArray(nums):\n    # Simply concatenate the array with itself\n    return nums + nums"
    },
    "javascript": {
      "template": "function concatenationOfArray(nums) {\n  \n}",
      "solution_text": "<h3>Concatenation of Array Solution</h3><p><strong>Algorithm:</strong> Create a new array of length 2n where each element appears twice - once at its original index and once at index + n.</p><p><strong>Time Complexity:</strong> O(n) where n is the length of the input array</p><p><strong>Space Complexity:</strong> O(n) for the result array</p><p><strong>Key Insights:</strong></p><ul><li>Simple array construction problem</li><li>First n elements are copies of original array</li><li>Next n elements are another copy of original array</li><li>Can be solved with array concatenation or manual index mapping</li></ul>",
      "solution_code": "function concatenationOfArray(nums) {\n    // Simply concatenate the array with itself\n    return nums.concat(nums);\n}"
    },
    "typescript": {
      "template": "function concatenationOfArray(nums: number[]): number[] {\n  \n}",
      "solution_text": "<h3>Concatenation of Array Solution</h3><p><strong>Algorithm:</strong> Create a new array of length 2n where each element appears twice - once at its original index and once at index + n.</p><p><strong>Time Complexity:</strong> O(n) where n is the length of the input array</p><p><strong>Space Complexity:</strong> O(n) for the result array</p><p><strong>Key Insights:</strong></p><ul><li>Simple array construction problem</li><li>First n elements are copies of original array</li><li>Next n elements are another copy of original array</li><li>Can be solved with array concatenation or manual index mapping</li></ul>",
      "solution_code": "function concatenationOfArray(nums: number[]): number[] {\n    // Simply concatenate the array with itself\n    return nums.concat(nums);\n}"
    },
    "java": {
      "template": "class Solution {\n    public int[] concatenationOfArray(int[] nums) {\n        \n    }\n}",
      "solution_text": "<h3>Concatenation of Array Solution</h3><p><strong>Algorithm:</strong> Create a new array of length 2n where each element appears twice - once at its original index and once at index + n.</p><p><strong>Time Complexity:</strong> O(n) where n is the length of the input array</p><p><strong>Space Complexity:</strong> O(n) for the result array</p><p><strong>Key Insights:</strong></p><ul><li>Simple array construction problem</li><li>First n elements are copies of original array</li><li>Next n elements are another copy of original array</li><li>Can be solved with array concatenation or manual index mapping</li></ul>",
      "solution_code": "class Solution {\n    public int[] concatenationOfArray(int[] nums) {\n        int[] result = new int[nums.length * 2];\n        \n        // Copy original array to first half\n        for (int i = 0; i < nums.length; i++) {\n            result[i] = nums[i];\n        }\n        \n        // Copy original array to second half\n        for (int i = 0; i < nums.length; i++) {\n            result[i + nums.length] = nums[i];\n        }\n        \n        return result;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "nums": [
          1,
          4,
          1,
          2
        ]
      },
      "output": [
        1,
        4,
        1,
        2,
        1,
        4,
        1,
        2
      ]
    },
    {
      "id": 2,
      "input": {
        "nums": [
          22,
          21,
          20,
          1
        ]
      },
      "output": [
        22,
        21,
        20,
        1,
        22,
        21,
        20,
        1
      ]
    }
  ]
}