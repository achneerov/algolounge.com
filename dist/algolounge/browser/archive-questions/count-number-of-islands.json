{
  "filename": "count-number-of-islands",
  "title": "Number of Islands",
  "keywords": [
    "number",
    "islands",
    "leetcode",
    "200",
    "given",
    "grid",
    "where",
    "represents",
    "land",
    "water"
  ],
  "description": "<h2>Number of Islands</h2><p>Leetcode 200. Number of Islands</p><p></p><p>Given a 2D grid `grid` where `'1'` represents land and `'0'` represents water, count and return the number of islands.</p><p></p><p>An **island** is formed by connecting adjacent lands horizontally or vertically and is surrounded by water. You may assume water is surrounding the grid (i.e., all the edges are water).</p><h3>Examples:</h3><ul><li>Input: grid = [<br>    [\"0\",\"1\",\"1\",\"1\",\"0\"],<br>    [\"0\",\"1\",\"0\",\"1\",\"0\"],<br>    [\"1\",\"1\",\"0\",\"0\",\"0\"],<br>    [\"0\",\"0\",\"0\",\"0\",\"0\"]<br>  ]<br>Output: 1</li><li>Input: grid = [<br>    [\"1\",\"1\",\"0\",\"0\",\"1\"],<br>    [\"1\",\"1\",\"0\",\"0\",\"1\"],<br>    [\"0\",\"0\",\"1\",\"0\",\"0\"],<br>    [\"0\",\"0\",\"0\",\"1\",\"1\"]<br>  ]<br>Output: 4</li></ul><h3>Constraints:</h3><ul><li> `1 <= grid.length, grid[i].length <= 100`</li><li> `grid[i][j]` is `'0'` or `'1'`.</li></ul>",
  "languages": {
    "python": {
      "template": "def numberOfIslands(grid):\n    ",
      "solution_text": "<h3>Number of Islands</h3><p><strong>Algorithm:</strong></p><ol><li>Iterate through each cell in the 2D grid</li><li>When we find a '1' (land), start DFS to mark all connected land</li><li>Use DFS to visit all adjacent '1' cells and mark them as visited</li><li>Increment island count for each new DFS started</li><li>Continue until all cells are processed</li></ol><p><strong>Time Complexity:</strong> O(m × n) - visit each cell once</p><p><strong>Space Complexity:</strong> O(m × n) - recursion stack in worst case</p><p><strong>Key Insights:</strong></p><ul><li>Each connected component of '1's forms one island</li><li>DFS explores all cells in one island before moving to next</li><li>Mark visited cells to avoid counting same island multiple times</li></ul>",
      "solution_code": "def numberOfIslands(grid):\n    if not grid or not grid[0]:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    islands = 0\n    \n    def dfs(r, c):\n        # Base case: out of bounds or water/visited\n        if (r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != '1'):\n            return\n        \n        # Mark current cell as visited\n        grid[r][c] = '0'\n        \n        # Explore all 4 directions\n        dfs(r + 1, c)  # down\n        dfs(r - 1, c)  # up\n        dfs(r, c + 1)  # right\n        dfs(r, c - 1)  # left\n    \n    # Iterate through each cell in the grid\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '1':\n                islands += 1\n                dfs(r, c)  # Mark all connected land\n    \n    return islands"
    },
    "javascript": {
      "template": "function numberOfIslands(grid) {\n  \n}",
      "solution_text": "<h3>Number of Islands</h3><p><strong>Algorithm:</strong></p><ol><li>Iterate through each cell in the 2D grid</li><li>When we find a '1' (land), start DFS to mark all connected land</li><li>Use DFS to visit all adjacent '1' cells and mark them as visited</li><li>Increment island count for each new DFS started</li><li>Continue until all cells are processed</li></ol><p><strong>Time Complexity:</strong> O(m × n) - visit each cell once</p><p><strong>Space Complexity:</strong> O(m × n) - recursion stack in worst case</p><p><strong>Key Insights:</strong></p><ul><li>Each connected component of '1's forms one island</li><li>DFS explores all cells in one island before moving to next</li><li>Mark visited cells to avoid counting same island multiple times</li></ul>",
      "solution_code": "function numberOfIslands(grid) {\n    if (!grid || !grid.length || !grid[0].length) {\n        return 0;\n    }\n    \n    const rows = grid.length;\n    const cols = grid[0].length;\n    let islands = 0;\n    \n    function dfs(r, c) {\n        // Base case: out of bounds or water/visited\n        if (r < 0 || r >= rows || c < 0 || c >= cols || grid[r][c] !== '1') {\n            return;\n        }\n        \n        // Mark current cell as visited\n        grid[r][c] = '0';\n        \n        // Explore all 4 directions\n        dfs(r + 1, c); // down\n        dfs(r - 1, c); // up\n        dfs(r, c + 1); // right\n        dfs(r, c - 1); // left\n    }\n    \n    // Iterate through each cell in the grid\n    for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n            if (grid[r][c] === '1') {\n                islands++;\n                dfs(r, c); // Mark all connected land\n            }\n        }\n    }\n    \n    return islands;\n}"
    },
    "typescript": {
      "template": "function numberOfIslands(grid: string[][]): number {\n  \n}",
      "solution_text": "<h3>Number of Islands</h3><p><strong>Algorithm:</strong></p><ol><li>Iterate through each cell in the 2D grid</li><li>When we find a '1' (land), start DFS to mark all connected land</li><li>Use DFS to visit all adjacent '1' cells and mark them as visited</li><li>Increment island count for each new DFS started</li><li>Continue until all cells are processed</li></ol><p><strong>Time Complexity:</strong> O(m × n) - visit each cell once</p><p><strong>Space Complexity:</strong> O(m × n) - recursion stack in worst case</p><p><strong>Key Insights:</strong></p><ul><li>Each connected component of '1's forms one island</li><li>DFS explores all cells in one island before moving to next</li><li>Mark visited cells to avoid counting same island multiple times</li></ul>",
      "solution_code": "function numberOfIslands(grid: string[][]): number {\n    if (!grid || !grid.length || !grid[0].length) {\n        return 0;\n    }\n    \n    const rows = grid.length;\n    const cols = grid[0].length;\n    let islands = 0;\n    \n    function dfs(r: number, c: number): void {\n        // Base case: out of bounds or water/visited\n        if (r < 0 || r >= rows || c < 0 || c >= cols || grid[r][c] !== '1') {\n            return;\n        }\n        \n        // Mark current cell as visited\n        grid[r][c] = '0';\n        \n        // Explore all 4 directions\n        dfs(r + 1, c); // down\n        dfs(r - 1, c); // up\n        dfs(r, c + 1); // right\n        dfs(r, c - 1); // left\n    }\n    \n    // Iterate through each cell in the grid\n    for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n            if (grid[r][c] === '1') {\n                islands++;\n                dfs(r, c); // Mark all connected land\n            }\n        }\n    }\n    \n    return islands;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int numberOfIslands(char[][] grid) {\n        \n    }\n}",
      "solution_text": "<h3>Number of Islands</h3><p><strong>Algorithm:</strong></p><ol><li>Iterate through each cell in the 2D grid</li><li>When we find a '1' (land), start DFS to mark all connected land</li><li>Use DFS to visit all adjacent '1' cells and mark them as visited</li><li>Increment island count for each new DFS started</li><li>Continue until all cells are processed</li></ol><p><strong>Time Complexity:</strong> O(m × n) - visit each cell once</p><p><strong>Space Complexity:</strong> O(m × n) - recursion stack in worst case</p><p><strong>Key Insights:</strong></p><ul><li>Each connected component of '1's forms one island</li><li>DFS explores all cells in one island before moving to next</li><li>Mark visited cells to avoid counting same island multiple times</li></ul>",
      "solution_code": "class Solution {\n    public int numberOfIslands(char[][] grid) {\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\n            return 0;\n        }\n        \n        int rows = grid.length;\n        int cols = grid[0].length;\n        int islands = 0;\n        \n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                if (grid[r][c] == '1') {\n                    islands++;\n                    dfs(grid, r, c, rows, cols);\n                }\n            }\n        }\n        \n        return islands;\n    }\n    \n    private void dfs(char[][] grid, int r, int c, int rows, int cols) {\n        // Base case: out of bounds or water/visited\n        if (r < 0 || r >= rows || c < 0 || c >= cols || grid[r][c] != '1') {\n            return;\n        }\n        \n        // Mark current cell as visited\n        grid[r][c] = '0';\n        \n        // Explore all 4 directions\n        dfs(grid, r + 1, c, rows, cols); // down\n        dfs(grid, r - 1, c, rows, cols); // up\n        dfs(grid, r, c + 1, rows, cols); // right\n        dfs(grid, r, c - 1, rows, cols); // left\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "grid": [
          ["0","1","1","1","0"],
          ["0","1","0","1","0"],
          ["1","1","0","0","0"],
          ["0","0","0","0","0"]
        ]
      },
      "output": 1
    },
    {
      "id": 2,
      "input": {
        "grid": [
          ["1","1","0","0","1"],
          ["1","1","0","0","1"],
          ["0","0","1","0","0"],
          ["0","0","0","1","1"]
        ]
      },
      "output": 4
    }
  ]
}