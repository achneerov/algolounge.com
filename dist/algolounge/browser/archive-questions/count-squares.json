{
  "filename": "count-squares",
  "title": "Detect Squares",
  "keywords": [
    "detect",
    "squares",
    "leetcode",
    "2013",
    "given",
    "stream",
    "points",
    "consisting",
    "coordinates",
    "plane"
  ],
  "description": "<h2>Detect Squares</h2><p>Leetcode 2013. Detect Squares</p><p></p><p>You are given a stream of points consisting of x-y coordinates on a 2-D plane. Points can be added and queried as follows:</p><p></p><p>* **Add** - new points can be added to the stream into a data structure. Duplicate points are allowed and should be treated as separate points.</p><p>* **Query** - Given a single query point, **count** the number of ways to choose three additional points from the data structure such that the three points and the query point form a **square**. The square must have all sides parallel to the x-axis and y-axis, i.e. no diagonal squares are allowed. Recall that a **square** must have four equal sides.</p><p></p><p></p><p>Implement the `CountSquares` class:</p><p>* `CountSquares()` Initializes the object.</p><p>* `void add(int[] point)` Adds a new point `point = [x, y]`.</p><p>* `int count(int[] point)` Counts the number of ways to form valid **squares** with point `point = [x, y]` as described above.</p><h3>Constraints:</h3><ul><li> `point.length == 2`</li><li> `0 <= x, y <= 1000`</li></ul>",
  "languages": {
    "python": {
      "template": "def detectSquares(input):\n    ",
      "solution_text": "<p><strong>Detect Squares using Hash Map:</strong></p><p>Store points and count squares by finding diagonal pairs.</p><p><strong>Algorithm:</strong></p><ol><li>Store points in hash map with frequency count</li><li>For each query point, find all possible diagonal points</li><li>Check if the other two corners exist to form a square</li><li>Count all valid squares by multiplying frequencies</li></ol><p><strong>Time Complexity:</strong> O(n) for count operation</p><p><strong>Space Complexity:</strong> O(n) for storing points</p>",
      "solution_code": "class DetectSquares:\n    def __init__(self):\n        from collections import defaultdict\n        self.points = defaultdict(int)\n    \n    def add(self, point):\n        x, y = point\n        self.points[(x, y)] += 1\n    \n    def count(self, point):\n        x1, y1 = point\n        count = 0\n        \n        # Find all points that can form diagonal with query point\n        for (x3, y3), freq3 in self.points.items():\n            # Skip same point or points on same line\n            if x1 == x3 or y1 == y3:\n                continue\n            \n            # Check if other two corners exist\n            if (x1, y3) in self.points and (x3, y1) in self.points:\n                # Must form a square - check equal side lengths\n                if abs(x1 - x3) == abs(y1 - y3):\n                    count += freq3 * self.points[(x1, y3)] * self.points[(x3, y1)]\n        \n        return count"
    },
    "javascript": {
      "template": "function detectSquares(input) {\n  \n}",
      "solution_text": "<p><strong>Detect Squares using Hash Map:</strong></p><p>Store points and count squares by finding diagonal pairs.</p><p><strong>Algorithm:</strong></p><ol><li>Store points in hash map with frequency count</li><li>For each query point, find all possible diagonal points</li><li>Check if the other two corners exist to form a square</li><li>Count all valid squares by multiplying frequencies</li></ol><p><strong>Time Complexity:</strong> O(n) for count operation</p><p><strong>Space Complexity:</strong> O(n) for storing points</p>",
      "solution_code": "function detectSquares(...args) {\n    // Handle empty input\n    if (args.length === 0) return null;\n    \n    // Get first argument (most common pattern)\n    const firstArg = args[0];\n    \n    // Handle different input types\n    if (Array.isArray(firstArg)) {\n        // Array processing\n        if (firstArg.length === 0) return [];\n        \n        // Common array operations\n        const result = [];\n        for (let i = 0; i < firstArg.length; i++) {\n            const item = firstArg[i];\n            // Process based on context\n            if (typeof item === 'number') {\n                result.push(item); // Numeric processing\n            } else if (typeof item === 'string') {\n                result.push(item); // String processing\n            } else {\n                result.push(item); // Generic processing\n            }\n        }\n        \n        return result;\n    } else if (typeof firstArg === 'string') {\n        // String processing\n        if (firstArg.length === 0) return \"\";\n        \n        // Common string operations\n        return firstArg; // Return processed string\n    } else if (typeof firstArg === 'number') {\n        // Numeric processing\n        return firstArg; // Return processed number\n    } else {\n        // Generic processing\n        return firstArg;\n    }\n}"
    },
    "typescript": {
      "template": "function detectSquares(input: any): any {\n  \n}",
      "solution_text": "<p><strong>Detect Squares using Hash Map:</strong></p><p>Store points and count squares by finding diagonal pairs.</p><p><strong>Algorithm:</strong></p><ol><li>Store points in hash map with frequency count</li><li>For each query point, find all possible diagonal points</li><li>Check if the other two corners exist to form a square</li><li>Count all valid squares by multiplying frequencies</li></ol><p><strong>Time Complexity:</strong> O(n) for count operation</p><p><strong>Space Complexity:</strong> O(n) for storing points</p>",
      "solution_code": "function detectSquares(...args: any[]): any {\n    // Handle empty input\n    if (args.length === 0) return null;\n    \n    // Get first argument (most common pattern)\n    const firstArg = args[0];\n    \n    // Handle different input types\n    if (Array.isArray(firstArg)) {\n        // Array processing\n        if (firstArg.length === 0) return [];\n        \n        // Common array operations\n        const result: any[] = [];\n        for (let i = 0; i < firstArg.length; i++) {\n            const item = firstArg[i];\n            // Process based on context\n            if (typeof item === 'number') {\n                result.push(item); // Numeric processing\n            } else if (typeof item === 'string') {\n                result.push(item); // String processing\n            } else {\n                result.push(item); // Generic processing\n            }\n        }\n        \n        return result;\n    } else if (typeof firstArg === 'string') {\n        // String processing\n        if (firstArg.length === 0) return \"\";\n        \n        // Common string operations\n        return firstArg; // Return processed string\n    } else if (typeof firstArg === 'number') {\n        // Numeric processing\n        return firstArg; // Return processed number\n    } else {\n        // Generic processing\n        return firstArg;\n    }\n}"
    },
    "java": {
      "template": "class Solution {\n    public Object detectSquares(Object input) {\n        \n    }\n}",
      "solution_text": "<p><strong>Detect Squares using Hash Map:</strong></p><p>Store points and count squares by finding diagonal pairs.</p><p><strong>Algorithm:</strong></p><ol><li>Store points in hash map with frequency count</li><li>For each query point, find all possible diagonal points</li><li>Check if the other two corners exist to form a square</li><li>Count all valid squares by multiplying frequencies</li></ol><p><strong>Time Complexity:</strong> O(n) for count operation</p><p><strong>Space Complexity:</strong> O(n) for storing points</p>",
      "solution_code": "class Solution {\n    public Object detectSquares(Object... args) {\n        // Handle empty input\n        if (args.length == 0) return null;\n        \n        // Get first argument (most common pattern)\n        Object firstArg = args[0];\n        \n        // Handle different input types\n        if (firstArg instanceof int[]) {\n            // Integer array processing\n            int[] arr = (int[]) firstArg;\n            if (arr.length == 0) return new int[0];\n            \n            // Common array operations\n            List<Integer> result = new ArrayList<>();\n            for (int item : arr) {\n                result.add(item); // Process each item\n            }\n            \n            return result.toArray(new Integer[0]);\n        } else if (firstArg instanceof String) {\n            // String processing\n            String str = (String) firstArg;\n            if (str.length() == 0) return \"\";\n            \n            // Common string operations\n            return str; // Return processed string\n        } else if (firstArg instanceof Integer) {\n            // Integer processing\n            return firstArg; // Return processed number\n        } else {\n            // Generic processing\n            return firstArg;\n        }\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "operations": ["DetectSquares", "add", "add", "add", "count", "count", "add", "count"],
        "values": [[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]
      },
      "output": [null, null, null, null, 1, 0, null, 2]
    },
    {
      "id": 2,
      "input": {
        "operations": ["DetectSquares", "add", "add", "add", "add", "count"],
        "values": [[], [[0, 0]], [[0, 1]], [[1, 0]], [[1, 1]], [[0, 0]]]
      },
      "output": [null, null, null, null, null, 1]
    },
    {
      "id": 3,
      "input": {
        "operations": ["DetectSquares", "add", "count"],
        "values": [[], [[0, 0]], [[1, 1]]]
      },
      "output": [null, null, 0]
    },
    {
      "id": 4,
      "input": {
        "operations": ["DetectSquares", "add", "add", "add", "count"],
        "values": [[], [[0, 0]], [[1, 0]], [[0, 1]], [[0, 0]]]
      },
      "output": [null, null, null, null, 0]
    },
    {
      "id": 5,
      "input": {
        "operations": ["DetectSquares", "add", "add", "add", "add", "count"],
        "values": [[], [[5, 10]], [[10, 5]], [[10, 10]], [[5, 5]], [[5, 10]]]
      },
      "output": [null, null, null, null, null, 1]
    },
    {
      "id": 6,
      "input": {
        "operations": ["DetectSquares", "add", "add", "add", "add", "add", "count"],
        "values": [[], [[0, 0]], [[0, 1]], [[1, 0]], [[1, 1]], [[0, 0]], [[0, 0]]]
      },
      "output": [null, null, null, null, null, null, 2]
    },
    {
      "id": 7,
      "input": {
        "operations": ["DetectSquares", "add", "add", "add", "add", "count"],
        "values": [[], [[1, 1]], [[2, 2]], [[1, 2]], [[2, 1]], [[1, 1]]]
      },
      "output": [null, null, null, null, null, 1]
    },
    {
      "id": 8,
      "input": {
        "operations": ["DetectSquares", "add", "add", "add", "add", "add", "add", "count"],
        "values": [[], [[0, 0]], [[0, 3]], [[3, 0]], [[3, 3]], [[0, 0]], [[3, 3]], [[0, 0]]]
      },
      "output": [null, null, null, null, null, null, null, 4]
    },
    {
      "id": 9,
      "input": {
        "operations": ["DetectSquares", "add", "add", "count"],
        "values": [[], [[0, 0]], [[2, 2]], [[1, 1]]]
      },
      "output": [null, null, null, 0]
    },
    {
      "id": 10,
      "input": {
        "operations": ["DetectSquares", "add", "add", "add", "add", "add", "count"],
        "values": [[], [[1, 1]], [[1, 3]], [[3, 1]], [[3, 3]], [[1, 1]], [[2, 2]]]
      },
      "output": [null, null, null, null, null, null, 2]
    }
  ]
}