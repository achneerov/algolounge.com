{
  "filename": "design-hashmap",
  "title": "Design HashMap",
  "keywords": [
    "design",
    "hashmap",
    "leetcode",
    "706",
    "without",
    "using",
    "any",
    "built",
    "hash",
    "table"
  ],
  "description": "<h2>Design HashMap</h2><p>Leetcode 706. Design HashMap</p><p></p><p>Design a HashMap without using any built-in hash table libraries.</p><p></p><p>Implement the `MyHashMap` class:</p><p></p><p>- `MyHashMap()` initializes the object with an empty map.</p><p>- `void put(int key, int value)` inserts a `(key, value)` pair into the HashMap. If the `key` already exists in the map, update the corresponding `value`.</p><p>- `int get(int key)` returns the `value` to which the specified `key` is mapped, or `-1` if this map contains no mapping for the `key`.</p><p>- `void remove(key)` removes the `key` and its corresponding `value` if the map contains the mapping for the `key`.</p><h3>Examples:</h3><ul><li>Input: ["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]<br>[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]<br><br>Output: [null, null, null, 1, -1, null, 1, null, -1]<br>MyHashMap myHashMap = new MyHashMap();\nmyHashMap.put(1, 1); // The map is now [[1,1]]\nmyHashMap.put(2, 2); // The map is now [[1,1], [2,2]]\nmyHashMap.get(1);    // return 1, The map is now [[1,1], [2,2]]\nmyHashMap.get(3);    // return -1 (i.e., not found), The map is now [[1,1], [2,2]]\nmyHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value)\nmyHashMap.get(2);    // return 1, The map is now [[1,1], [2,1]]\nmyHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]]\nmyHashMap.get(2);    // return -1 (i.e., not found), The map is now [[1,1]]</li></ul><h3>Constraints:</h3><ul><li> `0 <= key, value <= 1,000,000`</li><li> At most `10,000` calls will be made to `put`, `get`, and `remove`.</li></ul>",
  "languages": {
    "python": {
      "template": "class MyHashMap:\n\n    def __init__(self):\n        \n\n    def put(self, key: int, value: int) -> None:\n        \n\n    def get(self, key: int) -> int:\n        \n\n    def remove(self, key: int) -> None:\n        \n",
      "solution_text": "<p><strong>Array-based HashMap with Chaining:</strong></p><p>This solution implements a HashMap using an array of buckets, where each bucket is a list (or linked list) to handle collisions. This technique is known as chaining.</p><p><strong>Algorithm:</strong></p><ol><li><strong>Initialization:</strong><br>   - Choose a size for the internal array (e.g., 1000). This is the number of buckets.<br>   - Initialize the `map` as an array of empty lists (our buckets).</li><li><strong>Hash Function:</strong><br>   - A simple modulo operator `key % size` is used to determine the bucket index for a given key.</li><li><strong>`put(key, value)`:</strong><br>   - Calculate the hash index for the key.<br>   - Access the corresponding bucket (list).<br>   - Iterate through the bucket to check if the key already exists. Each element in the bucket is a `[key, value]` pair.<br>   - If the key is found, update its value and return.<br>   - If the key is not found, append the new `[key, value]` pair to the bucket.</li><li><strong>`get(key)`:</strong><br>   - Calculate the hash index for the key.<br>   - Access the corresponding bucket.<br>   - Iterate through the bucket. If the key is found, return its associated value.<br>   - If the key is not found after checking the entire bucket, return -1.</li><li><strong>`remove(key)`:</strong><br>   - Calculate the hash index for the key.<br>   - Access the corresponding bucket.<br>   - Iterate through the bucket. If the key is found, remove the `[key, value]` pair from the list.<br>   - If the key is not found, do nothing.</li></ol><p><strong>Time Complexity:</strong><br> - Average Case: O(1), assuming keys are well-distributed.<br> - Worst Case: O(N/K), where N is the number of items and K is the number of buckets. This happens when many keys hash to the same bucket.</p><p><strong>Space Complexity:</strong> O(K + N), where K is the number of buckets and N is the number of items stored.</p>",
      "solution_code": "class MyHashMap:\n\n    def __init__(self):\n        self.size = 1000\n        self.map = [[] for _ in range(self.size)]\n\n    def _hash(self, key: int) -> int:\n        return key % self.size\n\n    def put(self, key: int, value: int) -> None:\n        hash_key = self._hash(key)\n        bucket = self.map[hash_key]\n        for i, (k, v) in enumerate(bucket):\n            if k == key:\n                bucket[i] = [key, value]\n                return\n        bucket.append([key, value])\n\n    def get(self, key: int) -> int:\n        hash_key = self._hash(key)\n        bucket = self.map[hash_key]\n        for k, v in bucket:\n            if k == key:\n                return v\n        return -1\n\n    def remove(self, key: int) -> None:\n        hash_key = self._hash(key)\n        bucket = self.map[hash_key]\n        for i, (k, v) in enumerate(bucket):\n            if k == key:\n                bucket.pop(i)\n                return"
    },
    "javascript": {
      "template": "var MyHashMap = function() {\n    \n};\n\nMyHashMap.prototype.put = function(key, value) {\n    \n};\n\nMyHashMap.prototype.get = function(key) {\n    \n};\n\nMyHashMap.prototype.remove = function(key) {\n    \n};",
      "solution_text": "<p><strong>Array-based HashMap with Chaining:</strong></p><p>This solution implements a HashMap using an array of buckets, where each bucket is a list (or linked list) to handle collisions. This technique is known as chaining.</p><p><strong>Algorithm:</strong></p><ol><li><strong>Initialization:</strong><br>   - Choose a size for the internal array (e.g., 1000). This is the number of buckets.<br>   - Initialize the `map` as an array of empty lists (our buckets).</li><li><strong>Hash Function:</strong><br>   - A simple modulo operator `key % size` is used to determine the bucket index for a given key.</li><li><strong>`put(key, value)`:</strong><br>   - Calculate the hash index for the key.<br>   - Access the corresponding bucket (list).<br>   - Iterate through the bucket to check if the key already exists. Each element in the bucket is a `[key, value]` pair.<br>   - If the key is found, update its value and return.<br>   - If the key is not found, append the new `[key, value]` pair to the bucket.</li><li><strong>`get(key)`:</strong><br>   - Calculate the hash index for the key.<br>   - Access the corresponding bucket.<br>   - Iterate through the bucket. If the key is found, return its associated value.<br>   - If the key is not found after checking the entire bucket, return -1.</li><li><strong>`remove(key)`:</strong><br>   - Calculate the hash index for the key.<br>   - Access the corresponding bucket.<br>   - Iterate through the bucket. If the key is found, remove the `[key, value]` pair from the list.<br>   - If the key is not found, do nothing.</li></ol><p><strong>Time Complexity:</strong><br> - Average Case: O(1), assuming keys are well-distributed.<br> - Worst Case: O(N/K), where N is the number of items and K is the number of buckets. This happens when many keys hash to the same bucket.</p><p><strong>Space Complexity:</strong> O(K + N), where K is the number of buckets and N is the number of items stored.</p>",
      "solution_code": "var MyHashMap = function() {\n    this.size = 1000;\n    this.map = new Array(this.size).fill(null).map(() => []);\n};\n\nMyHashMap.prototype._hash = function(key) {\n    return key % this.size;\n};\n\nMyHashMap.prototype.put = function(key, value) {\n    const hashKey = this._hash(key);\n    const bucket = this.map[hashKey];\n    for (let i = 0; i < bucket.length; i++) {\n        if (bucket[i][0] === key) {\n            bucket[i][1] = value;\n            return;\n        }\n    }\n    bucket.push([key, value]);\n};\n\nMyHashMap.prototype.get = function(key) {\n    const hashKey = this._hash(key);\n    const bucket = this.map[hashKey];\n    for (let i = 0; i < bucket.length; i++) {\n        if (bucket[i][0] === key) {\n            return bucket[i][1];\n        }\n    }\n    return -1;\n};\n\nMyHashMap.prototype.remove = function(key) {\n    const hashKey = this._hash(key);\n    const bucket = this.map[hashKey];\n    for (let i = 0; i < bucket.length; i++) {\n        if (bucket[i][0] === key) {\n            bucket.splice(i, 1);\n            return;\n        }\n    }\n};"
    },
    "typescript": {
      "template": "class MyHashMap {\n    constructor() {\n\n    }\n\n    put(key: number, value: number): void {\n\n    }\n\n    get(key: number): number {\n\n    }\n\n    remove(key: number): void {\n\n    }\n}",
      "solution_text": "<p><strong>Array-based HashMap with Chaining:</strong></p><p>This solution implements a HashMap using an array of buckets, where each bucket is a list (or linked list) to handle collisions. This technique is known as chaining.</p><p><strong>Algorithm:</strong></p><ol><li><strong>Initialization:</strong><br>   - Choose a size for the internal array (e.g., 1000). This is the number of buckets.<br>   - Initialize the `map` as an array of empty lists (our buckets).</li><li><strong>Hash Function:</strong><br>   - A simple modulo operator `key % size` is used to determine the bucket index for a given key.</li><li><strong>`put(key, value)`:</strong><br>   - Calculate the hash index for the key.<br>   - Access the corresponding bucket (list).<br>   - Iterate through the bucket to check if the key already exists. Each element in the bucket is a `[key, value]` pair.<br>   - If the key is found, update its value and return.<br>   - If the key is not found, append the new `[key, value]` pair to the bucket.</li><li><strong>`get(key)`:</strong><br>   - Calculate the hash index for the key.<br>   - Access the corresponding bucket.<br>   - Iterate through the bucket. If the key is found, return its associated value.<br>   - If the key is not found after checking the entire bucket, return -1.</li><li><strong>`remove(key)`:</strong><br>   - Calculate the hash index for the key.<br>   - Access the corresponding bucket.<br>   - Iterate through the bucket. If the key is found, remove the `[key, value]` pair from the list.<br>   - If the key is not found, do nothing.</li></ol><p><strong>Time Complexity:</strong><br> - Average Case: O(1), assuming keys are well-distributed.<br> - Worst Case: O(N/K), where N is the number of items and K is the number of buckets. This happens when many keys hash to the same bucket.</p><p><strong>Space Complexity:</strong> O(K + N), where K is the number of buckets and N is the number of items stored.</p>",
      "solution_code": "class MyHashMap {\n    private size: number;\n    private map: [number, number][][];\n\n    constructor() {\n        this.size = 1000;\n        this.map = new Array(this.size).fill(null).map(() => []);\n    }\n\n    private _hash(key: number): number {\n        return key % this.size;\n    }\n\n    put(key: number, value: number): void {\n        const hashKey = this._hash(key);\n        const bucket = this.map[hashKey];\n        for (let i = 0; i < bucket.length; i++) {\n            if (bucket[i][0] === key) {\n                bucket[i][1] = value;\n                return;\n            }\n        }\n        bucket.push([key, value]);\n    }\n\n    get(key: number): number {\n        const hashKey = this._hash(key);\n        const bucket = this.map[hashKey];\n        for (let i = 0; i < bucket.length; i++) {\n            if (bucket[i][0] === key) {\n                return bucket[i][1];\n            }\n        }\n        return -1;\n    }\n\n    remove(key: number): void {\n        const hashKey = this._hash(key);\n        const bucket = this.map[hashKey];\n        for (let i = 0; i < bucket.length; i++) {\n            if (bucket[i][0] === key) {\n                bucket.splice(i, 1);\n                return;\n            }\n        }\n    }\n}"
    },
    "java": {
      "template": "class MyHashMap {\n\n    public MyHashMap() {\n        \n    }\n    \n    public void put(int key, int value) {\n        \n    }\n    \n    public int get(int key) {\n        \n    }\n    \n    public void remove(int key) {\n        \n    }\n}",
      "solution_text": "<p><strong>Array-based HashMap with Chaining:</strong></p><p>This solution implements a HashMap using an array of buckets, where each bucket is a list (or linked list) to handle collisions. This technique is known as chaining.</p><p><strong>Algorithm:</strong></p><ol><li><strong>Initialization:</strong><br>   - Choose a size for the internal array (e.g., 1000). This is the number of buckets.<br>   - Initialize the `map` as an array of empty lists (our buckets).</li><li><strong>Hash Function:</strong><br>   - A simple modulo operator `key % size` is used to determine the bucket index for a given key.</li><li><strong>`put(key, value)`:</strong><br>   - Calculate the hash index for the key.<br>   - Access the corresponding bucket (list).<br>   - Iterate through the bucket to check if the key already exists. Each element in the bucket is a `[key, value]` pair.<br>   - If the key is found, update its value and return.<br>   - If the key is not found, append the new `[key, value]` pair to the bucket.</li><li><strong>`get(key)`:</strong><br>   - Calculate the hash index for the key.<br>   - Access the corresponding bucket.<br>   - Iterate through the bucket. If the key is found, return its associated value.<br>   - If the key is not found after checking the entire bucket, return -1.</li><li><strong>`remove(key)`:</strong><br>   - Calculate the hash index for the key.<br>   - Access the corresponding bucket.<br>   - Iterate through the bucket. If the key is found, remove the `[key, value]` pair from the list.<br>   - If the key is not found, do nothing.</li></ol><p><strong>Time Complexity:</strong><br> - Average Case: O(1), assuming keys are well-distributed.<br> - Worst Case: O(N/K), where N is the number of items and K is the number of buckets. This happens when many keys hash to the same bucket.</p><p><strong>Space Complexity:</strong> O(K + N), where K is the number of buckets and N is the number of items stored.</p>",
      "solution_code": "import java.util.LinkedList;\n\nclass MyHashMap {\n    private int size = 1000;\n    private LinkedList<int[]>[] map;\n\n    public MyHashMap() {\n        map = new LinkedList[size];\n    }\n\n    private int hash(int key) {\n        return key % size;\n    }\n\n    public void put(int key, int value) {\n        int hashKey = hash(key);\n        if (map[hashKey] == null) {\n            map[hashKey] = new LinkedList<>();\n        }\n        for (int[] pair : map[hashKey]) {\n            if (pair[0] == key) {\n                pair[1] = value;\n                return;\n            }\n        }\n        map[hashKey].add(new int[]{key, value});\n    }\n\n    public int get(int key) {\n        int hashKey = hash(key);\n        if (map[hashKey] != null) {\n            for (int[] pair : map[hashKey]) {\n                if (pair[0] == key) {\n                    return pair[1];\n                }\n            }\n        }\n        return -1;\n    }\n\n    public void remove(int key) {\n        int hashKey = hash(key);\n        if (map[hashKey] != null) {\n            map[hashKey].removeIf(pair -> pair[0] == key);\n        }\n    }\n}"
    }
  },
  "order_matters": true,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "commands": ["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"],
        "args": [[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
      },
      "output": [null, null, null, 1, -1, null, 1, null, -1]
    },
    {
      "id": 2,
      "input": {
        "commands": ["MyHashMap", "put", "put", "get", "remove", "get"],
        "args": [[], [1, 10], [1, 20], [1], [1], [1]]
      },
      "output": [null, null, null, 20, null, -1]
    },
    {
      "id": 3,
      "input": {
        "commands": ["MyHashMap", "get", "put", "get", "put", "get", "get"],
        "args": [[], [10], [10, 100], [10], [10, 200], [10], [0]]
      },
      "output": [null, -1, null, 100, null, 200, -1]
    },
    {
      "id": 4,
      "input": {
        "commands": ["MyHashMap", "put", "remove", "put", "remove", "get", "get"],
        "args": [[], [5, 50], [5], [5, 55], [0], [5], [0]]
      },
      "output": [null, null, null, null, null, 55, -1]
    },
    {
      "id": 5,
      "input": {
        "commands": ["MyHashMap", "put", "put", "put", "get", "get", "get"],
        "args": [[], [1, 1], [1001, 2], [2001, 3], [1], [1001], [2001]]
      },
      "output": [null, null, null, null, 1, 2, 3]
    },
    {
      "id": 6,
      "input": {
        "commands": ["MyHashMap", "put", "put", "remove", "remove", "get", "get"],
        "args": [[], [0, 0], [1000000, 1], [0], [1000000], [0], [1000000]]
      },
      "output": [null, null, null, null, null, -1, -1]
    },
    {
      "id": 7,
      "input": {
        "commands": ["MyHashMap", "put", "put", "get", "put", "get"],
        "args": [[], [1, 1], [2, 2], [1], [2, 1], [2]]
      },
      "output": [null, null, null, 1, null, 1]
    },
    {
      "id": 8,
      "input": {
        "commands": ["MyHashMap", "remove", "get"],
        "args": [[], [14], [14]]
      },
      "output": [null, null, -1]
    },
    {
      "id": 9,
      "input": {
        "commands": ["MyHashMap", "put", "put", "put", "remove", "remove", "remove"],
        "args": [[], [1, 1], [2, 2], [3, 3], [1], [2], [3]]
      },
      "output": [null, null, null, null, null, null, null]
    },
    {
      "id": 10,
      "input": {
        "commands": ["MyHashMap", "put", "get", "put", "get"],
        "args": [[], [1, 1], [1], [1, 2], [1]]
      },
      "output": [null, null, 1, null, 2]
    }
  ]
}