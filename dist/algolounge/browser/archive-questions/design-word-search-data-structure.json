{
  "filename": "design-word-search-data-structure",
  "title": "Design Add and Search Word Data Structure",
  "keywords": [
    "design",
    "add",
    "search",
    "word",
    "data",
    "structure",
    "leetcode",
    "211",
    "words",
    "supports"
  ],
  "description": "<h2>Design Add and Search Word Data Structure</h2><p>Leetcode 211. Design Add And Search Words Data Structure</p><p></p><p>Design a data structure that supports adding new words and searching for existing words.</p><p></p><p>Implement the `WordDictionary` class:</p><p></p><p>* `void addWord(word)` Adds `word` to the data structure.</p><p>* `bool search(word)` Returns `true` if there is any string in the data structure that matches `word` or `false` otherwise. `word` may contain dots `'.'` where dots can be matched with any letter.</p><h3>Examples:</h3><ul><li>Input:<br>["WordDictionary", "addWord", "day", "addWord", "bay", "addWord", "may", "search", "say", "search", "day", "search", ".ay", "search", "b.."]<br><br>Output:<br>[null, null, null, null, false, true, true, true]<br><br>Explanation:<br>WordDictionary wordDictionary = new WordDictionary();<br>wordDictionary.addWord("day");<br>wordDictionary.addWord("bay");<br>wordDictionary.addWord("may");<br>wordDictionary.search("say"); // return false<br>wordDictionary.search("day"); // return true<br>wordDictionary.search(".ay"); // return true<br>wordDictionary.search("b.."); // return true</li></ul><h3>Constraints:</h3><ul><li> `1 <= word.length <= 20`</li><li> `word` in `addWord` consists of lowercase English letters.</li><li> `word` in `search` consist of `'.'` or lowercase English letters.</li><li> There will be at most `2` dots in `word` for `search` queries.</li><li> At most `10,000` calls will be made to `addWord` and `search`.</li></ul>",
  "languages": {
    "python": {
      "template": "class WordDictionary:\n\n    def __init__(self):\n        \n\n    def addWord(self, word: str) -> None:\n        \n\n    def search(self, word: str) -> bool:\n        \n",
      "solution_text": "<p><strong>Trie-based Solution for Word Dictionary:</strong></p><p>A Trie (prefix tree) is the perfect data structure for this problem, as it is optimized for prefix-based searches. The wildcard `.` character requires a modification to the standard Trie search.</p><p><strong>Algorithm:</strong></p><ol><li><strong>Trie Node:</strong><br>   - Each `TrieNode` will contain a dictionary (`children`) to store its child nodes, mapping characters to other `TrieNode`s.<br>   - A boolean flag `is_end_of_word` marks if a node represents the end of a complete word.</li><li><strong>`addWord(word)`:</strong><br>   - We start at the root of the Trie.<br>   - For each character in the `word`, we traverse down the Trie. If a character's node doesn't exist, we create it.<br>   - After iterating through all characters, we mark the final node's `is_end_of_word` as `True`.</li><li><strong>`search(word)`:</strong><br>   - This is implemented with a recursive helper function, `_search_in_node(word, node)`.<br>   - The function iterates through the `word` and the Trie simultaneously.<br>   - If the current character is a letter, we move to the corresponding child node. If the child doesn't exist, the word is not found.<br>   - If the character is a `.` (dot), it's a wildcard. We must check all possible paths. We iterate through all children of the current node and recursively call the search function for the rest of the word from each child. If any of these recursive calls return `True`, we've found a match.<br>   - The base case for the recursion is when we've reached the end of the word. We then check if the current node's `is_end_of_word` is `True`.</li></ol><p><strong>Time Complexity:</strong><br> - `addWord`: O(L), where L is the length of the word.<br> - `search`: O(L) for words without wildcards. For words with wildcards, it can be up to O(N*26^M), where N is the number of words and M is the number of wildcards, but it's practically much faster.</p><p><strong>Space Complexity:</strong> O(C), where C is the total number of characters in all words added.</p>",
      "solution_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass WordDictionary:\n\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        return self._search_in_node(word, self.root)\n\n    def _search_in_node(self, word: str, node: TrieNode) -> bool:\n        for i, char in enumerate(word):\n            if char == '.':\n                for child in node.children.values():\n                    if self._search_in_node(word[i+1:], child):\n                        return True\n                return False\n            else:\n                if char not in node.children:\n                    return False\n                node = node.children[char]\n        return node.is_end_of_word"
    },
    "javascript": {
      "template": "var WordDictionary = function() {\n    \n};\n\nWordDictionary.prototype.addWord = function(word) {\n    \n};\n\nWordDictionary.prototype.search = function(word) {\n    \n};",
      "solution_text": "<p><strong>Trie-based Solution for Word Dictionary:</strong></p><p>A Trie (prefix tree) is the perfect data structure for this problem, as it is optimized for prefix-based searches. The wildcard `.` character requires a modification to the standard Trie search.</p><p><strong>Algorithm:</strong></p><ol><li><strong>Trie Node:</strong><br>   - Each `TrieNode` will contain a Map (`children`) to store its child nodes, mapping characters to other `TrieNode`s.<br>   - A boolean flag `isEndOfWord` marks if a node represents the end of a complete word.</li><li><strong>`addWord(word)`:</strong><br>   - We start at the root of the Trie.<br>   - For each character in the `word`, we traverse down the Trie. If a character's node doesn't exist, we create it.<br>   - After iterating through all characters, we mark the final node's `isEndOfWord` as `true`.</li><li><strong>`search(word)`:</strong><br>   - This is implemented with a recursive helper function, `_searchInNode(word, node)`.<br>   - The function iterates through the `word` and the Trie simultaneously.<br>   - If the current character is a letter, we move to the corresponding child node. If the child doesn't exist, the word is not found.<br>   - If the character is a `.` (dot), it's a wildcard. We must check all possible paths. We iterate through all children of the current node and recursively call the search function for the rest of the word from each child. If any of these recursive calls return `true`, we've found a match.<br>   - The base case for the recursion is when we've reached the end of the word. We then check if the current node's `isEndOfWord` is `true`.</li></ol><p><strong>Time Complexity:</strong><br> - `addWord`: O(L), where L is the length of the word.<br> - `search`: O(L) for words without wildcards. For words with wildcards, it can be up to O(N*26^M), where N is the number of words and M is the number of wildcards, but it's practically much faster.</p><p><strong>Space Complexity:</strong> O(C), where C is the total number of characters in all words added.</p>",
      "solution_code": "class TrieNode {\n    constructor() {\n        this.children = new Map();\n        this.isEndOfWord = false;\n    }\n}\n\nvar WordDictionary = function() {\n    this.root = new TrieNode();\n};\n\nWordDictionary.prototype.addWord = function(word) {\n    let node = this.root;\n    for (const char of word) {\n        if (!node.children.has(char)) {\n            node.children.set(char, new TrieNode());\n        }\n        node = node.children.get(char);\n    }\n    node.isEndOfWord = true;\n};\n\nWordDictionary.prototype.search = function(word) {\n    return this._searchInNode(word, this.root);\n};\n\nWordDictionary.prototype._searchInNode = function(word, node) {\n    for (let i = 0; i < word.length; i++) {\n        const char = word[i];\n        if (char === '.') {\n            for (const child of node.children.values()) {\n                if (this._searchInNode(word.substring(i + 1), child)) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            if (!node.children.has(char)) {\n                return false;\n            }\n            node = node.children.get(char);\n        }\n    }\n    return node.isEndOfWord;\n};"
    },
    "typescript": {
      "template": "class WordDictionary {\n    constructor() {\n\n    }\n\n    addWord(word: string): void {\n\n    }\n\n    search(word: string): boolean {\n\n    }\n}",
      "solution_text": "<p><strong>Trie-based Solution for Word Dictionary:</strong></p><p>A Trie (prefix tree) is the perfect data structure for this problem, as it is optimized for prefix-based searches. The wildcard `.` character requires a modification to the standard Trie search.</p><p><strong>Algorithm:</strong></p><ol><li><strong>Trie Node:</strong><br>   - Each `TrieNode` will contain a Map (`children`) to store its child nodes, mapping characters to other `TrieNode`s.<br>   - A boolean flag `isEndOfWord` marks if a node represents the end of a complete word.</li><li><strong>`addWord(word)`:</strong><br>   - We start at the root of the Trie.<br>   - For each character in the `word`, we traverse down the Trie. If a character's node doesn't exist, we create it.<br>   - After iterating through all characters, we mark the final node's `isEndOfWord` as `true`.</li><li><strong>`search(word)`:</strong><br>   - This is implemented with a recursive helper function, `_searchInNode(word, node)`.<br>   - The function iterates through the `word` and the Trie simultaneously.<br>   - If the current character is a letter, we move to the corresponding child node. If the child doesn't exist, the word is not found.<br>   - If the character is a `.` (dot), it's a wildcard. We must check all possible paths. We iterate through all children of the current node and recursively call the search function for the rest of the word from each child. If any of these recursive calls return `true`, we've found a match.<br>   - The base case for the recursion is when we've reached the end of the word. We then check if the current node's `isEndOfWord` is `true`.</li></ol><p><strong>Time Complexity:</strong><br> - `addWord`: O(L), where L is the length of the word.<br> - `search`: O(L) for words without wildcards. For words with wildcards, it can be up to O(N*26^M), where N is the number of words and M is the number of wildcards, but it's practically much faster.</p><p><strong>Space Complexity:</strong> O(C), where C is the total number of characters in all words added.</p>",
      "solution_code": "class TrieNode {\n    children: Map<string, TrieNode> = new Map();\n    isEndOfWord: boolean = false;\n}\n\nclass WordDictionary {\n    private root: TrieNode = new TrieNode();\n\n    constructor() {}\n\n    addWord(word: string): void {\n        let node = this.root;\n        for (const char of word) {\n            if (!node.children.has(char)) {\n                node.children.set(char, new TrieNode());\n            }\n            node = node.children.get(char)!;\n        }\n        node.isEndOfWord = true;\n    }\n\n    search(word: string): boolean {\n        return this._searchInNode(word, this.root);\n    }\n\n    private _searchInNode(word: string, node: TrieNode): boolean {\n        for (let i = 0; i < word.length; i++) {\n            const char = word[i];\n            if (char === '.') {\n                for (const child of node.children.values()) {\n                    if (this._searchInNode(word.substring(i + 1), child)) {\n                        return true;\n                    }\n                }\n                return false;\n            } else {\n                if (!node.children.has(char)) {\n                    return false;\n                }\n                node = node.children.get(char)!;\n            }\n        }\n        return node.isEndOfWord;\n    }\n}"
    },
    "java": {
      "template": "class WordDictionary {\n\n    public WordDictionary() {\n        \n    }\n    \n    public void addWord(String word) {\n        \n    }\n    \n    public boolean search(String word) {\n        \n    }\n}",
      "solution_text": "<p><strong>Trie-based Solution for Word Dictionary:</strong></p><p>A Trie (prefix tree) is the perfect data structure for this problem, as it is optimized for prefix-based searches. The wildcard `.` character requires a modification to the standard Trie search.</p><p><strong>Algorithm:</strong></p><ol><li><strong>Trie Node:</strong><br>   - Each `TrieNode` will contain a HashMap (`children`) to store its child nodes, mapping characters to other `TrieNode`s.<br>   - A boolean flag `isEndOfWord` marks if a node represents the end of a complete word.</li><li><strong>`addWord(word)`:</strong><br>   - We start at the root of the Trie.<br>   - For each character in the `word`, we traverse down the Trie. If a character's node doesn't exist, we create it.<br>   - After iterating through all characters, we mark the final node's `isEndOfWord` as `true`.</li><li><strong>`search(word)`:</strong><br>   - This is implemented with a recursive helper function, `searchInNode(word, node)`.<br>   - The function iterates through the `word` and the Trie simultaneously.<br>   - If the current character is a letter, we move to the corresponding child node. If the child doesn't exist, the word is not found.<br>   - If the character is a `.` (dot), it's a wildcard. We must check all possible paths. We iterate through all children of the current node and recursively call the search function for the rest of the word from each child. If any of these recursive calls return `true`, we've found a match.<br>   - The base case for the recursion is when we've reached the end of the word. We then check if the current node's `isEndOfWord` is `true`.</li></ol><p><strong>Time Complexity:</strong><br> - `addWord`: O(L), where L is the length of the word.<br> - `search`: O(L) for words without wildcards. For words with wildcards, it can be up to O(N*26^M), where N is the number of words and M is the number of wildcards, but it's practically much faster.</p><p><strong>Space Complexity:</strong> O(C), where C is the total number of characters in all words added.</p>",
      "solution_code": "import java.util.HashMap;\nimport java.util.Map;\n\nclass TrieNode {\n    Map<Character, TrieNode> children = new HashMap<>();\n    boolean isEndOfWord = false;\n}\n\nclass WordDictionary {\n    private TrieNode root;\n\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n\n    public void addWord(String word) {\n        TrieNode node = root;\n        for (char c : word.toCharArray()) {\n            node.children.putIfAbsent(c, new TrieNode());\n            node = node.children.get(c);\n        }\n        node.isEndOfWord = true;\n    }\n\n    public boolean search(String word) {\n        return searchInNode(word, root);\n    }\n\n    private boolean searchInNode(String word, TrieNode node) {\n        for (int i = 0; i < word.length(); i++) {\n            char c = word.charAt(i);\n            if (c == '.') {\n                for (TrieNode child : node.children.values()) {\n                    if (searchInNode(word.substring(i + 1), child)) {\n                        return true;\n                    }\n                }\n                return false;\n            } else {\n                if (!node.children.containsKey(c)) {\n                    return false;\n                }\n                node = node.children.get(c);\n            }\n        }\n        return node.isEndOfWord;\n    }\n}"
    }
  },
  "order_matters": true,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "commands": ["WordDictionary", "addWord", "addWord", "addWord", "search", "search", "search", "search"],
        "args": [[], ["bad"], ["dad"], ["mad"], ["pad"], ["bad"], [".ad"], ["b.."]]
      },
      "output": [null, null, null, null, false, true, true, true]
    },
    {
      "id": 2,
      "input": {
        "commands": ["WordDictionary", "addWord", "search"],
        "args": [[], ["a"], ["a"]]
      },
      "output": [null, null, true]
    },
    {
      "id": 3,
      "input": {
        "commands": ["WordDictionary", "addWord", "search"],
        "args": [[], ["a"], ["b"]]
      },
      "output": [null, null, false]
    },
    {
      "id": 4,
      "input": {
        "commands": ["WordDictionary", "addWord", "search"],
        "args": [[], ["apple"], ["app.e"]]
      },
      "output": [null, null, true]
    },
    {
      "id": 5,
      "input": {
        "commands": ["WordDictionary", "addWord", "search"],
        "args": [[], ["hello"], ["h.l.o"]]
      },
      "output": [null, null, true]
    },
    {
      "id": 6,
      "input": {
        "commands": ["WordDictionary", "addWord", "search"],
        "args": [[], ["world"], ["w.r.d"]]
      },
      "output": [null, null, false]
    },
    {
      "id": 7,
      "input": {
        "commands": ["WordDictionary", "addWord", "addWord", "search", "search"],
        "args": [[], ["at"], ["and"], ["a"], ["a."]]
      },
      "output": [null, null, null, false, true]
    },
    {
      "id": 8,
      "input": {
        "commands": ["WordDictionary", "addWord", "search", "search", "search"],
        "args": [[], ["a"], ["."], ["a."], [".."]]
      },
      "output": [null, null, true, false, false]
    },
    {
      "id": 9,
      "input": {
        "commands": ["WordDictionary", "addWord", "addWord", "search", "search"],
        "args": [[], ["ran"], ["rune"], ["..n"], ["r.n."]]
      },
      "output": [null, null, null, true, false]
    },
    {
      "id": 10,
      "input": {
        "commands": ["WordDictionary", "addWord", "addWord", "addWord", "search", "search", "search", "search", "search", "search"],
        "args": [[], ["word"], ["wood"], ["would"], ["w..d"], ["wo.d"], ["w.rd"], ["wo.."], ["...."], ["w.rld"]]
      },
      "output": [null, null, null, null, true, true, true, true, true, false]
    }
  ]
}