{
  "filename": "evaluate-reverse-polish-notation",
  "title": "Evaluate Reverse Polish Notation",
  "keywords": [
    "evaluate",
    "reverse",
    "polish",
    "notation",
    "leetcode",
    "150",
    "given",
    "array",
    "strings",
    "tokens"
  ],
  "description": "<h2>Evaluate Reverse Polish Notation</h2><p>Leetcode 150. Evaluate Reverse Polish Notation</p><p></p><p>You are given an array of strings `tokens` that represents a **valid** arithmetic expression in [Reverse Polish Notation](https://en.wikipedia.org/wiki/Reverse_Polish_notation).</p><p></p><p>Return the integer that represents the evaluation of the expression.</p><p></p><p>* The operands may be integers or the results of other operations.</p><p>* The operators include `'+'`, `'-'`, `'*'`, and `'/'`.</p><p>* Assume that division between integers always truncates toward zero.</p><h3>Examples:</h3><ul><li>Input: tokens = [\"1\",\"2\",\"+\",\"3\",\"*\",\"4\",\"-\"]<br><br>Output: 5<br><br>Explanation: ((1 + 2) * 3) - 4 = 5</li></ul><h3>Constraints:</h3><ul><li> `1 <= tokens.length <= 1000`.</li><li> tokens[i] is `\"+\"`, `\"-\"`, `\"*\"`, or `\"/\"`, or a string representing an integer in the range `[-100, 100]`.</li></ul>",
  "languages": {
    "python": {
      "template": "def evaluateReversePolishNotation(tokens):\n    ",
      "solution_text": "<h3>Evaluate Reverse Polish Notation</h3><p><strong>Algorithm:</strong></p><ol><li>Use a stack to store operands</li><li>Iterate through tokens from left to right</li><li>If token is number, push to stack</li><li>If token is operator, pop two operands, perform operation, push result</li><li>Final stack element is the result</li></ol><p><strong>Time Complexity:</strong> O(n) - single pass through tokens</p><p><strong>Space Complexity:</strong> O(n) - stack space for operands</p><p><strong>Key Insights:</strong></p><ul><li>Stack naturally handles the postfix evaluation order</li><li>Pop order matters: second operand, then first operand</li><li>Handle integer division truncation toward zero</li></ul>",
      "solution_code": "def evaluateReversePolishNotation(tokens):\n    stack = []\n    operators = {'+', '-', '*', '/'}\n    \n    for token in tokens:\n        if token in operators:\n            # Pop two operands (order matters!)\n            b = stack.pop()  # Second operand\n            a = stack.pop()  # First operand\n            \n            # Perform operation\n            if token == '+':\n                result = a + b\n            elif token == '-':\n                result = a - b\n            elif token == '*':\n                result = a * b\n            elif token == '/':\n                # Integer division truncating toward zero\n                result = int(a / b)\n            \n            stack.append(result)\n        else:\n            # Token is a number, push to stack\n            stack.append(int(token))\n    \n    # Final result is the only element left in stack\n    return stack[0]"
    },
    "javascript": {
      "template": "function evaluateReversePolishNotation(tokens) {\n  \n}",
      "solution_text": "<h3>Evaluate Reverse Polish Notation</h3><p><strong>Algorithm:</strong></p><ol><li>Use a stack to store operands</li><li>Iterate through tokens from left to right</li><li>If token is number, push to stack</li><li>If token is operator, pop two operands, perform operation, push result</li><li>Final stack element is the result</li></ol><p><strong>Time Complexity:</strong> O(n) - single pass through tokens</p><p><strong>Space Complexity:</strong> O(n) - stack space for operands</p><p><strong>Key Insights:</strong></p><ul><li>Stack naturally handles the postfix evaluation order</li><li>Pop order matters: second operand, then first operand</li><li>Handle integer division truncation toward zero</li></ul>",
      "solution_code": "function evaluateReversePolishNotation(tokens) {\n    const stack = [];\n    const operators = new Set(['+', '-', '*', '/']);\n    \n    for (const token of tokens) {\n        if (operators.has(token)) {\n            // Pop two operands (order matters!)\n            const b = stack.pop(); // Second operand\n            const a = stack.pop(); // First operand\n            \n            let result;\n            // Perform operation\n            if (token === '+') {\n                result = a + b;\n            } else if (token === '-') {\n                result = a - b;\n            } else if (token === '*') {\n                result = a * b;\n            } else if (token === '/') {\n                // Integer division truncating toward zero\n                result = Math.trunc(a / b);\n            }\n            \n            stack.push(result);\n        } else {\n            // Token is a number, push to stack\n            stack.push(parseInt(token));\n        }\n    }\n    \n    // Final result is the only element left in stack\n    return stack[0];\n}"
    },
    "typescript": {
      "template": "function evaluateReversePolishNotation(tokens: string[]): number {\n  \n}",
      "solution_text": "<h3>Evaluate Reverse Polish Notation</h3><p><strong>Algorithm:</strong></p><ol><li>Use a stack to store operands</li><li>Iterate through tokens from left to right</li><li>If token is number, push to stack</li><li>If token is operator, pop two operands, perform operation, push result</li><li>Final stack element is the result</li></ol><p><strong>Time Complexity:</strong> O(n) - single pass through tokens</p><p><strong>Space Complexity:</strong> O(n) - stack space for operands</p><p><strong>Key Insights:</strong></p><ul><li>Stack naturally handles the postfix evaluation order</li><li>Pop order matters: second operand, then first operand</li><li>Handle integer division truncation toward zero</li></ul>",
      "solution_code": "function evaluateReversePolishNotation(tokens: string[]): number {\n    const stack: number[] = [];\n    const operators = new Set(['+', '-', '*', '/']);\n    \n    for (const token of tokens) {\n        if (operators.has(token)) {\n            // Pop two operands (order matters!)\n            const b = stack.pop()!; // Second operand\n            const a = stack.pop()!; // First operand\n            \n            let result: number;\n            // Perform operation\n            if (token === '+') {\n                result = a + b;\n            } else if (token === '-') {\n                result = a - b;\n            } else if (token === '*') {\n                result = a * b;\n            } else { // token === '/'\n                // Integer division truncating toward zero\n                result = Math.trunc(a / b);\n            }\n            \n            stack.push(result);\n        } else {\n            // Token is a number, push to stack\n            stack.push(parseInt(token));\n        }\n    }\n    \n    // Final result is the only element left in stack\n    return stack[0];\n}"
    },
    "java": {
      "template": "class Solution {\n    public int evaluateReversePolishNotation(String[] tokens) {\n        \n    }\n}",
      "solution_text": "<h3>Evaluate Reverse Polish Notation</h3><p><strong>Algorithm:</strong></p><ol><li>Use a stack to store operands</li><li>Iterate through tokens from left to right</li><li>If token is number, push to stack</li><li>If token is operator, pop two operands, perform operation, push result</li><li>Final stack element is the result</li></ol><p><strong>Time Complexity:</strong> O(n) - single pass through tokens</p><p><strong>Space Complexity:</strong> O(n) - stack space for operands</p><p><strong>Key Insights:</strong></p><ul><li>Stack naturally handles the postfix evaluation order</li><li>Pop order matters: second operand, then first operand</li><li>Handle integer division truncation toward zero</li></ul>",
      "solution_code": "class Solution {\n    public int evaluateReversePolishNotation(String[] tokens) {\n        Stack<Integer> stack = new Stack<>();\n        Set<String> operators = Set.of(\"+\", \"-\", \"*\", \"/\");\n        \n        for (String token : tokens) {\n            if (operators.contains(token)) {\n                // Pop two operands (order matters!)\n                int b = stack.pop(); // Second operand\n                int a = stack.pop(); // First operand\n                \n                int result;\n                // Perform operation\n                switch (token) {\n                    case \"+\":\n                        result = a + b;\n                        break;\n                    case \"-\":\n                        result = a - b;\n                        break;\n                    case \"*\":\n                        result = a * b;\n                        break;\n                    case \"/\":\n                        // Integer division truncating toward zero\n                        result = a / b;\n                        break;\n                    default:\n                        throw new IllegalArgumentException(\"Invalid operator: \" + token);\n                }\n                \n                stack.push(result);\n            } else {\n                // Token is a number, push to stack\n                stack.push(Integer.parseInt(token));\n            }\n        }\n        \n        // Final result is the only element left in stack\n        return stack.pop();\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "tokens": [
          "1",
          "2",
          "+",
          "3",
          "*",
          "4",
          "-"
        ]
      },
      "output": 5
    }
  ]
}