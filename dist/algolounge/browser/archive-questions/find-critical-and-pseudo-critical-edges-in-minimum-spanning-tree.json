{
  "filename": "find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree",
  "title": "Find Critical and Pseudo Critical Edges in Minimum Spanning Tree",
  "keywords": [
    "find",
    "critical",
    "pseudo",
    "edges",
    "minimum",
    "spanning",
    "tree",
    "leetcode",
    "1489",
    "given"
  ],
  "description": "<h2>Find Critical and Pseudo Critical Edges in Minimum Spanning Tree</h2><p>Leetcode 1489. Find Critical and Pseudo Critical Edges in Minimum Spanning Tree</p><p></p><p>You are given a weighted undirected connected graph with `n` vertices numbered from `0` to `n - 1`, and an array `edges` where `edges[i] = [a[i], b[i], weight[i]]` represents a bidirectional and weighted edge between nodes `a[i]` and `b[i]`. A minimum spanning tree (MST) is a subset of the graph's edges that connects all vertices without cycles and with the minimum possible total edge weight.</p><p></p><p>Find all the critical and pseudo-critical edges in the given graph's minimum spanning tree (MST). An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge. On the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all.</p><p></p><p>Note that you can return the indices of the edges in any order.</p><h3>Examples:</h3><ul><li>Input: n = 4, edges = [[0,3,2],[0,2,5],[1,2,4]]<br><br>Output: [[0,2,1],[]]</li><li>Input: n = 5, edges = [[0,3,2],[0,4,2],[1,3,2],[3,4,2],[2,3,1],[1,2,3],[0,1,1]]<br><br>Output: [[4,6],[0,1,2,3]]</li></ul><h3>Constraints:</h3><ul><li> `2 <= n <= 100`</li><li> `1 <= edges.length <= min(200, n * (n - 1) / 2)`</li><li> `edges[i].length == 3`</li><li> `0 <= a[i] < b[i] < n`</li><li> `1 <= weight[i] <= 1000`</li><li> All pairs `(a[i], b[i])` are **distinct**.</li></ul>",
  "languages": {
    "python": {
      "template": "def findCriticalAndPseudoCriticalEdgesInMinimumSpanningTree(n, edges):\n    ",
      "solution_text": "<h3>Find Critical and Pseudo Critical Edges in Minimum Spanning Tree</h3><p><strong>Algorithm:</strong></p><ol><li>Use Kruskal's algorithm with Union-Find to build MST</li><li>Find original MST weight by sorting edges and applying Kruskal's</li><li>For each edge, check if it's critical by excluding it and computing MST</li><li>For each edge, check if it's pseudo-critical by forcing its inclusion</li><li>An edge is critical if MST weight increases when excluded</li><li>An edge is pseudo-critical if MST weight stays same when forced</li></ol><p><strong>Time Complexity:</strong> O(E² × α(V)) - E edges, each tested with Union-Find operations</p><p><strong>Space Complexity:</strong> O(E + V) - Union-Find structure and edge storage</p><p><strong>Key Insights:</strong></p><ul><li>Critical edges are essential for minimum weight</li><li>Pseudo-critical edges can be in some MSTs but not all</li><li>Use Union-Find for efficient cycle detection in Kruskal's algorithm</li></ul>",
      "solution_code": "def findCriticalAndPseudoCriticalEdgesInMinimumSpanningTree(n, edges):\n    # Union-Find class\n    class UnionFind:\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n        \n        def find(self, x):\n            if self.parent[x] != x:\n                self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n        \n        def union(self, x, y):\n            px, py = self.find(x), self.find(y)\n            if px == py:\n                return False\n            if self.rank[px] < self.rank[py]:\n                px, py = py, px\n            self.parent[py] = px\n            if self.rank[px] == self.rank[py]:\n                self.rank[px] += 1\n            return True\n    \n    def kruskal(exclude=-1, include=-1):\n        uf = UnionFind(n)\n        weight = 0\n        edges_used = 0\n        \n        # Include forced edge first\n        if include != -1:\n            u, v, w = edges[include]\n            if uf.union(u, v):\n                weight += w\n                edges_used += 1\n        \n        # Process edges in sorted order\n        for i, (u, v, w) in enumerate(sorted_edges):\n            if i == exclude:\n                continue\n            if uf.union(u, v):\n                weight += w\n                edges_used += 1\n                if edges_used == n - 1:\n                    break\n        \n        return weight if edges_used == n - 1 else float('inf')\n    \n    # Add index to edges and sort by weight\n    indexed_edges = [(u, v, w, i) for i, (u, v, w) in enumerate(edges)]\n    sorted_edges = sorted(indexed_edges)\n    \n    # Find original MST weight\n    original_weight = kruskal()\n    \n    critical = []\n    pseudo_critical = []\n    \n    for i in range(len(edges)):\n        # Check if critical (excluding this edge increases weight)\n        if kruskal(exclude=i) > original_weight:\n            critical.append(i)\n        # Check if pseudo-critical (including this edge doesn't increase weight)\n        elif kruskal(include=i) == original_weight:\n            pseudo_critical.append(i)\n    \n    return [critical, pseudo_critical]"
    },
    "javascript": {
      "template": "function findCriticalAndPseudoCriticalEdgesInMinimumSpanningTree(n, edges) {\n  \n}",
      "solution_text": "<h3>Find Critical and Pseudo Critical Edges in Minimum Spanning Tree</h3><p><strong>Algorithm:</strong></p><ol><li>Use Kruskal's algorithm with Union-Find to build MST</li><li>Find original MST weight by sorting edges and applying Kruskal's</li><li>For each edge, check if it's critical by excluding it and computing MST</li><li>For each edge, check if it's pseudo-critical by forcing its inclusion</li><li>An edge is critical if MST weight increases when excluded</li><li>An edge is pseudo-critical if MST weight stays same when forced</li></ol><p><strong>Time Complexity:</strong> O(E² × α(V)) - E edges, each tested with Union-Find operations</p><p><strong>Space Complexity:</strong> O(E + V) - Union-Find structure and edge storage</p><p><strong>Key Insights:</strong></p><ul><li>Critical edges are essential for minimum weight</li><li>Pseudo-critical edges can be in some MSTs but not all</li><li>Use Union-Find for efficient cycle detection in Kruskal's algorithm</li></ul>",
      "solution_code": "function findCriticalAndPseudoCriticalEdgesInMinimumSpanningTree(n, edges) {\n    // Union-Find class\n    class UnionFind {\n        constructor(n) {\n            this.parent = Array.from({length: n}, (_, i) => i);\n            this.rank = new Array(n).fill(0);\n        }\n        \n        find(x) {\n            if (this.parent[x] !== x) {\n                this.parent[x] = this.find(this.parent[x]);\n            }\n            return this.parent[x];\n        }\n        \n        union(x, y) {\n            const px = this.find(x);\n            const py = this.find(y);\n            if (px === py) return false;\n            \n            if (this.rank[px] < this.rank[py]) {\n                this.parent[px] = py;\n            } else if (this.rank[px] > this.rank[py]) {\n                this.parent[py] = px;\n            } else {\n                this.parent[py] = px;\n                this.rank[px]++;\n            }\n            return true;\n        }\n    }\n    \n    function kruskal(exclude = -1, include = -1) {\n        const uf = new UnionFind(n);\n        let weight = 0;\n        let edgesUsed = 0;\n        \n        // Include forced edge first\n        if (include !== -1) {\n            const [u, v, w] = edges[include];\n            if (uf.union(u, v)) {\n                weight += w;\n                edgesUsed++;\n            }\n        }\n        \n        // Process edges in sorted order\n        for (const [u, v, w, i] of sortedEdges) {\n            if (i === exclude) continue;\n            if (uf.union(u, v)) {\n                weight += w;\n                edgesUsed++;\n                if (edgesUsed === n - 1) break;\n            }\n        }\n        \n        return edgesUsed === n - 1 ? weight : Infinity;\n    }\n    \n    // Add index to edges and sort by weight\n    const indexedEdges = edges.map((edge, i) => [...edge, i]);\n    const sortedEdges = indexedEdges.sort((a, b) => a[2] - b[2]);\n    \n    // Find original MST weight\n    const originalWeight = kruskal();\n    \n    const critical = [];\n    const pseudoCritical = [];\n    \n    for (let i = 0; i < edges.length; i++) {\n        // Check if critical (excluding this edge increases weight)\n        if (kruskal(i) > originalWeight) {\n            critical.push(i);\n        }\n        // Check if pseudo-critical (including this edge doesn't increase weight)\n        else if (kruskal(-1, i) === originalWeight) {\n            pseudoCritical.push(i);\n        }\n    }\n    \n    return [critical, pseudoCritical];\n}"
    },
    "typescript": {
      "template": "function findCriticalAndPseudoCriticalEdgesInMinimumSpanningTree(n: number, edges: number[][]): number[][] {\n  \n}",
      "solution_text": "<h3>Find Critical and Pseudo Critical Edges in Minimum Spanning Tree</h3><p><strong>Algorithm:</strong></p><ol><li>Use Kruskal's algorithm with Union-Find to build MST</li><li>Find original MST weight by sorting edges and applying Kruskal's</li><li>For each edge, check if it's critical by excluding it and computing MST</li><li>For each edge, check if it's pseudo-critical by forcing its inclusion</li><li>An edge is critical if MST weight increases when excluded</li><li>An edge is pseudo-critical if MST weight stays same when forced</li></ol><p><strong>Time Complexity:</strong> O(E² × α(V)) - E edges, each tested with Union-Find operations</p><p><strong>Space Complexity:</strong> O(E + V) - Union-Find structure and edge storage</p><p><strong>Key Insights:</strong></p><ul><li>Critical edges are essential for minimum weight</li><li>Pseudo-critical edges can be in some MSTs but not all</li><li>Use Union-Find for efficient cycle detection in Kruskal's algorithm</li></ul>",
      "solution_code": "function findCriticalAndPseudoCriticalEdgesInMinimumSpanningTree(n: number, edges: number[][]): number[][] {\n    // Union-Find class\n    class UnionFind {\n        parent: number[];\n        rank: number[];\n        \n        constructor(n: number) {\n            this.parent = Array.from({length: n}, (_, i) => i);\n            this.rank = new Array(n).fill(0);\n        }\n        \n        find(x: number): number {\n            if (this.parent[x] !== x) {\n                this.parent[x] = this.find(this.parent[x]);\n            }\n            return this.parent[x];\n        }\n        \n        union(x: number, y: number): boolean {\n            const px = this.find(x);\n            const py = this.find(y);\n            if (px === py) return false;\n            \n            if (this.rank[px] < this.rank[py]) {\n                this.parent[px] = py;\n            } else if (this.rank[px] > this.rank[py]) {\n                this.parent[py] = px;\n            } else {\n                this.parent[py] = px;\n                this.rank[px]++;\n            }\n            return true;\n        }\n    }\n    \n    function kruskal(exclude: number = -1, include: number = -1): number {\n        const uf = new UnionFind(n);\n        let weight = 0;\n        let edgesUsed = 0;\n        \n        // Include forced edge first\n        if (include !== -1) {\n            const [u, v, w] = edges[include];\n            if (uf.union(u, v)) {\n                weight += w;\n                edgesUsed++;\n            }\n        }\n        \n        // Process edges in sorted order\n        for (const [u, v, w, i] of sortedEdges) {\n            if (i === exclude) continue;\n            if (uf.union(u, v)) {\n                weight += w;\n                edgesUsed++;\n                if (edgesUsed === n - 1) break;\n            }\n        }\n        \n        return edgesUsed === n - 1 ? weight : Infinity;\n    }\n    \n    // Add index to edges and sort by weight\n    const indexedEdges = edges.map((edge, i) => [...edge, i]);\n    const sortedEdges = indexedEdges.sort((a, b) => a[2] - b[2]);\n    \n    // Find original MST weight\n    const originalWeight = kruskal();\n    \n    const critical: number[] = [];\n    const pseudoCritical: number[] = [];\n    \n    for (let i = 0; i < edges.length; i++) {\n        // Check if critical (excluding this edge increases weight)\n        if (kruskal(i) > originalWeight) {\n            critical.push(i);\n        }\n        // Check if pseudo-critical (including this edge doesn't increase weight)\n        else if (kruskal(-1, i) === originalWeight) {\n            pseudoCritical.push(i);\n        }\n    }\n    \n    return [critical, pseudoCritical];\n}"
    },
    "java": {
      "template": "class Solution {\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdgesInMinimumSpanningTree(int n, int[][] edges) {\n        \n    }\n}",
      "solution_text": "<h3>Find Critical and Pseudo Critical Edges in Minimum Spanning Tree</h3><p><strong>Algorithm:</strong></p><ol><li>Use Kruskal's algorithm with Union-Find to build MST</li><li>Find original MST weight by sorting edges and applying Kruskal's</li><li>For each edge, check if it's critical by excluding it and computing MST</li><li>For each edge, check if it's pseudo-critical by forcing its inclusion</li><li>An edge is critical if MST weight increases when excluded</li><li>An edge is pseudo-critical if MST weight stays same when forced</li></ol><p><strong>Time Complexity:</strong> O(E² × α(V)) - E edges, each tested with Union-Find operations</p><p><strong>Space Complexity:</strong> O(E + V) - Union-Find structure and edge storage</p><p><strong>Key Insights:</strong></p><ul><li>Critical edges are essential for minimum weight</li><li>Pseudo-critical edges can be in some MSTs but not all</li><li>Use Union-Find for efficient cycle detection in Kruskal's algorithm</li></ul>",
      "solution_code": "class Solution {\n    class UnionFind {\n        int[] parent, rank;\n        \n        public UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n        \n        public int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        public boolean union(int x, int y) {\n            int px = find(x), py = find(y);\n            if (px == py) return false;\n            \n            if (rank[px] < rank[py]) {\n                parent[px] = py;\n            } else if (rank[px] > rank[py]) {\n                parent[py] = px;\n            } else {\n                parent[py] = px;\n                rank[px]++;\n            }\n            return true;\n        }\n    }\n    \n    public List<List<Integer>> findCriticalAndPseudoCriticalEdgesInMinimumSpanningTree(int n, int[][] edges) {\n        // Add index to edges and sort by weight\n        int[][] indexedEdges = new int[edges.length][4];\n        for (int i = 0; i < edges.length; i++) {\n            indexedEdges[i] = new int[]{edges[i][0], edges[i][1], edges[i][2], i};\n        }\n        Arrays.sort(indexedEdges, (a, b) -> a[2] - b[2]);\n        \n        // Find original MST weight\n        int originalWeight = kruskal(n, indexedEdges, -1, -1);\n        \n        List<Integer> critical = new ArrayList<>();\n        List<Integer> pseudoCritical = new ArrayList<>();\n        \n        for (int i = 0; i < edges.length; i++) {\n            // Check if critical (excluding this edge increases weight)\n            if (kruskal(n, indexedEdges, i, -1) > originalWeight) {\n                critical.add(i);\n            }\n            // Check if pseudo-critical (including this edge doesn't increase weight)\n            else if (kruskal(n, indexedEdges, -1, i) == originalWeight) {\n                pseudoCritical.add(i);\n            }\n        }\n        \n        return Arrays.asList(critical, pseudoCritical);\n    }\n    \n    private int kruskal(int n, int[][] sortedEdges, int exclude, int include) {\n        UnionFind uf = new UnionFind(n);\n        int weight = 0, edgesUsed = 0;\n        \n        // Include forced edge first\n        if (include != -1) {\n            int[] edge = null;\n            for (int[] e : sortedEdges) {\n                if (e[3] == include) {\n                    edge = e;\n                    break;\n                }\n            }\n            if (edge != null && uf.union(edge[0], edge[1])) {\n                weight += edge[2];\n                edgesUsed++;\n            }\n        }\n        \n        // Process edges in sorted order\n        for (int[] edge : sortedEdges) {\n            if (edge[3] == exclude) continue;\n            if (uf.union(edge[0], edge[1])) {\n                weight += edge[2];\n                edgesUsed++;\n                if (edgesUsed == n - 1) break;\n            }\n        }\n        \n        return edgesUsed == n - 1 ? weight : Integer.MAX_VALUE;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "n": 4,
        "edges": [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,2,5],[1,3,4],[2,0,4]]
      },
      "output": [[0,1],[2,3,4,5]]
    },
    {
      "id": 2,
      "input": {
        "n": 5,
        "edges": [[0,1,1],[1,2,1],[2,3,1],[0,3,2],[0,4,2],[3,4,2],[1,4,2]]
      },
      "output": [[],[0,1,2,3,4,5,6]]
    }
  ]
}