{
  "filename": "find-duplicate-integer",
  "title": "Find the Duplicate Number",
  "keywords": [
    "find",
    "duplicate",
    "number",
    "leetcode",
    "287",
    "given",
    "array",
    "integers",
    "nums",
    "containing"
  ],
  "description": "<h2>Find the Duplicate Number</h2><p>Leetcode 287. Find The Duplicate Number</p><p></p><p>You are given an array of integers `nums` containing `n + 1` integers. Each integer in `nums` is in the range `[1, n]` inclusive.</p><p></p><p>Every integer appears **exactly once**, except for one integer which appears **two or more times**. Return the integer that appears more than once.</p><h3>Examples:</h3><ul><li>Input: nums = [1,2,3,2,2]<br><br>Output: 2</li><li>Input: nums = [1,2,3,4,4]<br><br>Output: 4</li></ul><h3>Constraints:</h3><ul><li> `1 <= n <= 10000`</li><li> `nums.length == n + 1`</li><li> `1 <= nums[i] <= n`</li></ul>",
  "languages": {
    "python": {
      "template": "def findTheDuplicateNumber(nums):\n    ",
      "solution_text": "<h3>Find the Duplicate Number</h3><p><strong>Algorithm (Floyd's Tortoise and Hare):</strong></p><ol><li>Treat the array as a linked list where nums[i] points to index nums[i]</li><li>Use two pointers (slow and fast) to detect the cycle</li><li>Move slow by 1 step and fast by 2 steps until they meet</li><li>Reset one pointer to start, move both by 1 step until they meet again</li><li>The meeting point is the duplicate number</li></ol><p><strong>Time Complexity:</strong> O(n) - linear scan with cycle detection</p><p><strong>Space Complexity:</strong> O(1) - only uses two pointers</p><p><strong>Key Insights:</strong></p><ul><li>Treats array indexing as linked list traversal</li><li>Cycle detection finds the duplicate without extra space</li><li>Works because duplicate creates a cycle in the 'linked list'</li></ul>",
      "solution_code": "def findTheDuplicateNumber(nums):\n    # Floyd's Tortoise and Hare (Cycle Detection)\n    # Phase 1: Find intersection point in the cycle\n    slow = nums[0]\n    fast = nums[0]\n    \n    # Move slow one step and fast two steps\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n    \n    # Phase 2: Find the entrance to the cycle (duplicate number)\n    # Reset one pointer to start, move both at same speed\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n    \n    return slow"
    },
    "javascript": {
      "template": "function findTheDuplicateNumber(nums) {\n  \n}",
      "solution_text": "<h3>Find the Duplicate Number</h3><p><strong>Algorithm (Floyd's Tortoise and Hare):</strong></p><ol><li>Treat the array as a linked list where nums[i] points to index nums[i]</li><li>Use two pointers (slow and fast) to detect the cycle</li><li>Move slow by 1 step and fast by 2 steps until they meet</li><li>Reset one pointer to start, move both by 1 step until they meet again</li><li>The meeting point is the duplicate number</li></ol><p><strong>Time Complexity:</strong> O(n) - linear scan with cycle detection</p><p><strong>Space Complexity:</strong> O(1) - only uses two pointers</p><p><strong>Key Insights:</strong></p><ul><li>Treats array indexing as linked list traversal</li><li>Cycle detection finds the duplicate without extra space</li><li>Works because duplicate creates a cycle in the 'linked list'</li></ul>",
      "solution_code": "function findTheDuplicateNumber(nums) {\n    // Floyd's Tortoise and Hare (Cycle Detection)\n    // Phase 1: Find intersection point in the cycle\n    let slow = nums[0];\n    let fast = nums[0];\n    \n    // Move slow one step and fast two steps\n    do {\n        slow = nums[slow];\n        fast = nums[nums[fast]];\n    } while (slow !== fast);\n    \n    // Phase 2: Find the entrance to the cycle (duplicate number)\n    // Reset one pointer to start, move both at same speed\n    slow = nums[0];\n    while (slow !== fast) {\n        slow = nums[slow];\n        fast = nums[fast];\n    }\n    \n    return slow;\n}"
    },
    "typescript": {
      "template": "function findTheDuplicateNumber(nums: number[]): number {\n  \n}",
      "solution_text": "<h3>Find the Duplicate Number</h3><p><strong>Algorithm (Floyd's Tortoise and Hare):</strong></p><ol><li>Treat the array as a linked list where nums[i] points to index nums[i]</li><li>Use two pointers (slow and fast) to detect the cycle</li><li>Move slow by 1 step and fast by 2 steps until they meet</li><li>Reset one pointer to start, move both by 1 step until they meet again</li><li>The meeting point is the duplicate number</li></ol><p><strong>Time Complexity:</strong> O(n) - linear scan with cycle detection</p><p><strong>Space Complexity:</strong> O(1) - only uses two pointers</p><p><strong>Key Insights:</strong></p><ul><li>Treats array indexing as linked list traversal</li><li>Cycle detection finds the duplicate without extra space</li><li>Works because duplicate creates a cycle in the 'linked list'</li></ul>",
      "solution_code": "function findTheDuplicateNumber(nums: number[]): number {\n    // Floyd's Tortoise and Hare (Cycle Detection)\n    // Phase 1: Find intersection point in the cycle\n    let slow = nums[0];\n    let fast = nums[0];\n    \n    // Move slow one step and fast two steps\n    do {\n        slow = nums[slow];\n        fast = nums[nums[fast]];\n    } while (slow !== fast);\n    \n    // Phase 2: Find the entrance to the cycle (duplicate number)\n    // Reset one pointer to start, move both at same speed\n    slow = nums[0];\n    while (slow !== fast) {\n        slow = nums[slow];\n        fast = nums[fast];\n    }\n    \n    return slow;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int findTheDuplicateNumber(int[] nums) {\n        \n    }\n}",
      "solution_text": "<h3>Find the Duplicate Number</h3><p><strong>Algorithm (Floyd's Tortoise and Hare):</strong></p><ol><li>Treat the array as a linked list where nums[i] points to index nums[i]</li><li>Use two pointers (slow and fast) to detect the cycle</li><li>Move slow by 1 step and fast by 2 steps until they meet</li><li>Reset one pointer to start, move both by 1 step until they meet again</li><li>The meeting point is the duplicate number</li></ol><p><strong>Time Complexity:</strong> O(n) - linear scan with cycle detection</p><p><strong>Space Complexity:</strong> O(1) - only uses two pointers</p><p><strong>Key Insights:</strong></p><ul><li>Treats array indexing as linked list traversal</li><li>Cycle detection finds the duplicate without extra space</li><li>Works because duplicate creates a cycle in the 'linked list'</li></ul>",
      "solution_code": "class Solution {\n    public int findTheDuplicateNumber(int[] nums) {\n        // Floyd's Tortoise and Hare (Cycle Detection)\n        // Phase 1: Find intersection point in the cycle\n        int slow = nums[0];\n        int fast = nums[0];\n        \n        // Move slow one step and fast two steps\n        do {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        } while (slow != fast);\n        \n        // Phase 2: Find the entrance to the cycle (duplicate number)\n        // Reset one pointer to start, move both at same speed\n        slow = nums[0];\n        while (slow != fast) {\n            slow = nums[slow];\n            fast = nums[fast];\n        }\n        \n        return slow;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "nums": [
          1,
          2,
          3,
          2,
          2
        ]
      },
      "output": 2
    },
    {
      "id": 2,
      "input": {
        "nums": [
          1,
          2,
          3,
          4,
          4
        ]
      },
      "output": 4
    }
  ]
}