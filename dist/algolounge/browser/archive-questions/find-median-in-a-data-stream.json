{
  "filename": "find-median-in-a-data-stream",
  "title": "Find Median From Data Stream",
  "keywords": [
    "find",
    "median",
    "data",
    "stream",
    "leetcode",
    "295",
    "https",
    "wikipedia",
    "org",
    "wiki"
  ],
  "description": "<h2>Find Median From Data Stream</h2><p>Leetcode 295. Find Median From Data Stream</p><p></p><p>The **[median](https://en.wikipedia.org/wiki/Median)** is the middle value in a sorted list of integers. For lists of *even* length, there is no middle value, so the median is the [mean](https://en.wikipedia.org/wiki/Mean) of the two middle values.</p><p></p><p>For example:</p><p>* For `arr = [1,2,3]`, the median is `2`.</p><p>* For `arr = [1,2]`, the median is `(1 + 2) / 2 = 1.5`</p><p></p><p>Implement the MedianFinder class:</p><p></p><p>* `MedianFinder()` initializes the `MedianFinder` object.</p><p>* `void addNum(int num)` adds the integer `num` from the data stream to the data structure.</p><p>* `double findMedian()` returns the median of all elements so far.</p><h3>Examples:</h3><ul><li>Input:<br>[\"MedianFinder\", \"addNum\", \"1\", \"findMedian\", \"addNum\", \"3\" \"findMedian\", \"addNum\", \"2\", \"findMedian\"]<br><br>Output:<br>[null, null, 1.0, null, 2.0, null, 2.0]<br><br>Explanation:<br>MedianFinder medianFinder = new MedianFinder();<br>medianFinder.addNum(1);    // arr = [1]<br>medianFinder.findMedian(); // return 1.0<br>medianFinder.addNum(3);    // arr = [1, 3]<br>medianFinder.findMedian(); // return 2.0<br>medianFinder.addNum(2);    // arr[1, 2, 3]<br>medianFinder.findMedian(); // return 2.0</li></ul><h3>Constraints:</h3><ul><li> `-100,000 <= num <= 100,000`</li><li> `findMedian` will only be called after adding at least one integer to the data structure.</li></ul>",
  "languages": {
    "python": {
      "template": "class MedianFinder:\n    def __init__(self):\n        \n    def addNum(self, num):\n        \n    def findMedian(self):\n        ",
      "solution_text": "<h3>Find Median From Data Stream</h3><p><strong>Algorithm (Two Heaps):</strong></p><ol><li>Use a max heap for the smaller half of numbers</li><li>Use a min heap for the larger half of numbers</li><li>Keep heaps balanced: max heap size ≤ min heap size + 1</li><li>When adding: add to appropriate heap, then rebalance if needed</li><li>Median: if heaps equal size, average of tops; else top of max heap</li></ol><p><strong>Time Complexity:</strong> O(log n) - addNum, O(1) - findMedian</p><p><strong>Space Complexity:</strong> O(n) - storing all numbers in heaps</p><p><strong>Key Insights:</strong></p><ul><li>Two heaps maintain sorted order without full sorting</li><li>Max heap stores smaller half, min heap stores larger half</li><li>Balance ensures median is always at heap tops</li></ul>",
      "solution_code": "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n        # Max heap for smaller half (negate values for max heap behavior)\n        self.max_heap = []\n        # Min heap for larger half\n        self.min_heap = []\n    \n    def addNum(self, num):\n        # Add to max heap first (smaller half)\n        heapq.heappush(self.max_heap, -num)\n        \n        # Move largest from max heap to min heap\n        heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap))\n        \n        # Balance heaps: max heap should have equal or one more element\n        if len(self.max_heap) < len(self.min_heap):\n            heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap))\n    \n    def findMedian(self):\n        if len(self.max_heap) > len(self.min_heap):\n            # Odd total count: median is top of max heap\n            return -self.max_heap[0]\n        else:\n            # Even total count: median is average of both tops\n            return (-self.max_heap[0] + self.min_heap[0]) / 2.0"
    },
    "javascript": {
      "template": "class MedianFinder {\n    constructor() {\n        \n    }\n    \n    addNum(num) {\n        \n    }\n    \n    findMedian() {\n        \n    }\n}",
      "solution_text": "<h3>Find Median From Data Stream</h3><p><strong>Algorithm (Two Heaps):</strong></p><ol><li>Use a max heap for the smaller half of numbers</li><li>Use a min heap for the larger half of numbers</li><li>Keep heaps balanced: max heap size ≤ min heap size + 1</li><li>When adding: add to appropriate heap, then rebalance if needed</li><li>Median: if heaps equal size, average of tops; else top of max heap</li></ol><p><strong>Time Complexity:</strong> O(log n) - addNum, O(1) - findMedian</p><p><strong>Space Complexity:</strong> O(n) - storing all numbers in heaps</p><p><strong>Key Insights:</strong></p><ul><li>Two heaps maintain sorted order without full sorting</li><li>Max heap stores smaller half, min heap stores larger half</li><li>Balance ensures median is always at heap tops</li></ul>",
      "solution_code": "class MedianFinder {\n    constructor() {\n        // Use arrays as heaps with manual heap operations\n        // Max heap for smaller half (negate values for max heap behavior)\n        this.maxHeap = [];\n        // Min heap for larger half\n        this.minHeap = [];\n    }\n    \n    addNum(num) {\n        // Add to max heap first (smaller half)\n        this.heapPush(this.maxHeap, -num, true);\n        \n        // Move largest from max heap to min heap\n        const maxTop = -this.heapPop(this.maxHeap, true);\n        this.heapPush(this.minHeap, maxTop, false);\n        \n        // Balance heaps: max heap should have equal or one more element\n        if (this.maxHeap.length < this.minHeap.length) {\n            const minTop = this.heapPop(this.minHeap, false);\n            this.heapPush(this.maxHeap, -minTop, true);\n        }\n    }\n    \n    findMedian() {\n        if (this.maxHeap.length > this.minHeap.length) {\n            // Odd total count: median is top of max heap\n            return -this.maxHeap[0];\n        } else {\n            // Even total count: median is average of both tops\n            return (-this.maxHeap[0] + this.minHeap[0]) / 2.0;\n        }\n    }\n    \n    heapPush(heap, val, isMaxHeap) {\n        heap.push(val);\n        this.heapifyUp(heap, heap.length - 1, isMaxHeap);\n    }\n    \n    heapPop(heap, isMaxHeap) {\n        if (heap.length === 0) return null;\n        const result = heap[0];\n        heap[0] = heap[heap.length - 1];\n        heap.pop();\n        if (heap.length > 0) {\n            this.heapifyDown(heap, 0, isMaxHeap);\n        }\n        return result;\n    }\n    \n    heapifyUp(heap, index, isMaxHeap) {\n        while (index > 0) {\n            const parentIndex = Math.floor((index - 1) / 2);\n            const shouldSwap = isMaxHeap ? \n                heap[index] > heap[parentIndex] : \n                heap[index] < heap[parentIndex];\n            if (!shouldSwap) break;\n            [heap[index], heap[parentIndex]] = [heap[parentIndex], heap[index]];\n            index = parentIndex;\n        }\n    }\n    \n    heapifyDown(heap, index, isMaxHeap) {\n        while (index < heap.length) {\n            let targetIndex = index;\n            const leftChild = 2 * index + 1;\n            const rightChild = 2 * index + 2;\n            \n            if (leftChild < heap.length) {\n                const shouldSwap = isMaxHeap ? \n                    heap[leftChild] > heap[targetIndex] : \n                    heap[leftChild] < heap[targetIndex];\n                if (shouldSwap) targetIndex = leftChild;\n            }\n            \n            if (rightChild < heap.length) {\n                const shouldSwap = isMaxHeap ? \n                    heap[rightChild] > heap[targetIndex] : \n                    heap[rightChild] < heap[targetIndex];\n                if (shouldSwap) targetIndex = rightChild;\n            }\n            \n            if (targetIndex === index) break;\n            [heap[index], heap[targetIndex]] = [heap[targetIndex], heap[index]];\n            index = targetIndex;\n        }\n    }\n}"
    },
    "typescript": {
      "template": "class MedianFinder {\n    constructor() {\n        \n    }\n    \n    addNum(num: number): void {\n        \n    }\n    \n    findMedian(): number {\n        \n    }\n}",
      "solution_text": "<h3>Find Median From Data Stream</h3><p><strong>Algorithm (Two Heaps):</strong></p><ol><li>Use a max heap for the smaller half of numbers</li><li>Use a min heap for the larger half of numbers</li><li>Keep heaps balanced: max heap size ≤ min heap size + 1</li><li>When adding: add to appropriate heap, then rebalance if needed</li><li>Median: if heaps equal size, average of tops; else top of max heap</li></ol><p><strong>Time Complexity:</strong> O(log n) - addNum, O(1) - findMedian</p><p><strong>Space Complexity:</strong> O(n) - storing all numbers in heaps</p><p><strong>Key Insights:</strong></p><ul><li>Two heaps maintain sorted order without full sorting</li><li>Max heap stores smaller half, min heap stores larger half</li><li>Balance ensures median is always at heap tops</li></ul>",
      "solution_code": "class MedianFinder {\n    private maxHeap: number[]; // For smaller half\n    private minHeap: number[]; // For larger half\n    \n    constructor() {\n        // Max heap for smaller half (negate values for max heap behavior)\n        this.maxHeap = [];\n        // Min heap for larger half\n        this.minHeap = [];\n    }\n    \n    addNum(num: number): void {\n        // Add to max heap first (smaller half)\n        this.heapPush(this.maxHeap, -num, true);\n        \n        // Move largest from max heap to min heap\n        const maxTop = -this.heapPop(this.maxHeap, true)!;\n        this.heapPush(this.minHeap, maxTop, false);\n        \n        // Balance heaps: max heap should have equal or one more element\n        if (this.maxHeap.length < this.minHeap.length) {\n            const minTop = this.heapPop(this.minHeap, false)!;\n            this.heapPush(this.maxHeap, -minTop, true);\n        }\n    }\n    \n    findMedian(): number {\n        if (this.maxHeap.length > this.minHeap.length) {\n            // Odd total count: median is top of max heap\n            return -this.maxHeap[0];\n        } else {\n            // Even total count: median is average of both tops\n            return (-this.maxHeap[0] + this.minHeap[0]) / 2.0;\n        }\n    }\n    \n    private heapPush(heap: number[], val: number, isMaxHeap: boolean): void {\n        heap.push(val);\n        this.heapifyUp(heap, heap.length - 1, isMaxHeap);\n    }\n    \n    private heapPop(heap: number[], isMaxHeap: boolean): number | null {\n        if (heap.length === 0) return null;\n        const result = heap[0];\n        heap[0] = heap[heap.length - 1];\n        heap.pop();\n        if (heap.length > 0) {\n            this.heapifyDown(heap, 0, isMaxHeap);\n        }\n        return result;\n    }\n    \n    private heapifyUp(heap: number[], index: number, isMaxHeap: boolean): void {\n        while (index > 0) {\n            const parentIndex = Math.floor((index - 1) / 2);\n            const shouldSwap = isMaxHeap ? \n                heap[index] > heap[parentIndex] : \n                heap[index] < heap[parentIndex];\n            if (!shouldSwap) break;\n            [heap[index], heap[parentIndex]] = [heap[parentIndex], heap[index]];\n            index = parentIndex;\n        }\n    }\n    \n    private heapifyDown(heap: number[], index: number, isMaxHeap: boolean): void {\n        while (index < heap.length) {\n            let targetIndex = index;\n            const leftChild = 2 * index + 1;\n            const rightChild = 2 * index + 2;\n            \n            if (leftChild < heap.length) {\n                const shouldSwap = isMaxHeap ? \n                    heap[leftChild] > heap[targetIndex] : \n                    heap[leftChild] < heap[targetIndex];\n                if (shouldSwap) targetIndex = leftChild;\n            }\n            \n            if (rightChild < heap.length) {\n                const shouldSwap = isMaxHeap ? \n                    heap[rightChild] > heap[targetIndex] : \n                    heap[rightChild] < heap[targetIndex];\n                if (shouldSwap) targetIndex = rightChild;\n            }\n            \n            if (targetIndex === index) break;\n            [heap[index], heap[targetIndex]] = [heap[targetIndex], heap[index]];\n            index = targetIndex;\n        }\n    }\n}"
    },
    "java": {
      "template": "class MedianFinder {\n    public MedianFinder() {\n        \n    }\n    \n    public void addNum(int num) {\n        \n    }\n    \n    public double findMedian() {\n        \n    }\n}",
      "solution_text": "<h3>Find Median From Data Stream</h3><p><strong>Algorithm (Two Heaps):</strong></p><ol><li>Use a max heap for the smaller half of numbers</li><li>Use a min heap for the larger half of numbers</li><li>Keep heaps balanced: max heap size ≤ min heap size + 1</li><li>When adding: add to appropriate heap, then rebalance if needed</li><li>Median: if heaps equal size, average of tops; else top of max heap</li></ol><p><strong>Time Complexity:</strong> O(log n) - addNum, O(1) - findMedian</p><p><strong>Space Complexity:</strong> O(n) - storing all numbers in heaps</p><p><strong>Key Insights:</strong></p><ul><li>Two heaps maintain sorted order without full sorting</li><li>Max heap stores smaller half, min heap stores larger half</li><li>Balance ensures median is always at heap tops</li></ul>",
      "solution_code": "class MedianFinder {\n    private PriorityQueue<Integer> maxHeap; // For smaller half\n    private PriorityQueue<Integer> minHeap; // For larger half\n    \n    public MedianFinder() {\n        // Max heap for smaller half (reverse order)\n        maxHeap = new PriorityQueue<>((a, b) -> b - a);\n        // Min heap for larger half (natural order)\n        minHeap = new PriorityQueue<>();\n    }\n    \n    public void addNum(int num) {\n        // Add to max heap first (smaller half)\n        maxHeap.offer(num);\n        \n        // Move largest from max heap to min heap\n        minHeap.offer(maxHeap.poll());\n        \n        // Balance heaps: max heap should have equal or one more element\n        if (maxHeap.size() < minHeap.size()) {\n            maxHeap.offer(minHeap.poll());\n        }\n    }\n    \n    public double findMedian() {\n        if (maxHeap.size() > minHeap.size()) {\n            // Odd total count: median is top of max heap\n            return maxHeap.peek();\n        } else {\n            // Even total count: median is average of both tops\n            return (maxHeap.peek() + minHeap.peek()) / 2.0;\n        }\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "operations": ["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"],
        "values": [[], [1], [2], [], [3], []]
      },
      "output": [null, null, null, 1.5, null, 2.0]
    }
  ]
}