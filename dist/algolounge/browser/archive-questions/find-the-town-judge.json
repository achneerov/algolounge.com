{
  "filename": "find-the-town-judge",
  "title": "Find the Town Judge",
  "keywords": [
    "find",
    "town",
    "judge",
    "leetcode",
    "997",
    "there",
    "people",
    "labeled",
    "rumor",
    "one"
  ],
  "description": "<h2>Find the Town Judge</h2><p>Leetcode 997. Find the Town Judge</p><p></p><p>In a town, there are `n` people labeled from `1` to `n`. There is a rumor that one of these people is secretly the town judge.</p><p></p><p>If the town judge exists, then:</p><p></p><p>1. The town judge trusts nobody.</p><p>2. Everybody (except for the town judge) trusts the town judge.</p><p>3. There is exactly one person that satisfies properties **1** and **2**.</p><p></p><p>You are given an array `trust` where `trust[i] = [ai, bi]` representing that the person labeled `ai` trusts the person labeled `bi`.</p><p></p><p>Return the label of the town judge if the town judge exists and can be identified, or return `-1` otherwise.</p><h3>Examples:</h3><ul><li>Input: n = 4, trust = [[1,3],[4,3],[2,3]]<br><br>Output: 3</li><li>Input: n = 3, trust = [[1,3],[2,3],[3,1],[3,2]]<br><br>Output: -1</li></ul><h3>Constraints:</h3><ul><li> `1 <= n <= 1000`</li><li> `0 <= trust.length <= 10,000`</li><li> `trust[i].length == 2`</li><li> All the pairs of `trust` are **unique**.</li><li> `trust[i][0] != trust[i][1]`</li><li> `1 <= trust[i][0], trust[i][1] <= n`</li></ul>",
  "languages": {
    "python": {
      "template": "def findTheTownJudge(n, trust):\n    ",
      "solution_text": "**Algorithm:**\nTo find the town judge, we need to find someone who:\n1. Trusts nobody (outdegree = 0)\n2. Is trusted by everyone else (indegree = n-1)\n\nWe can use a single array to track the net trust score (indegree - outdegree) for each person.\n\n**Time Complexity:** O(E) where E is the number of trust relationships\n**Space Complexity:** O(n) for the trust score array\n\n**Key Insights:**\n- The judge has a net trust score of n-1\n- Everyone else has a net trust score < n-1\n- If no judge exists, no one will have score n-1",
      "solution_code": "def findTheTownJudge(n, trust):\n    if n == 1:\n        return 1  # Only one person, must be the judge\n    \n    # trust_score[i] = indegree[i] - outdegree[i]\n    trust_score = [0] * (n + 1)\n    \n    for a, b in trust:\n        trust_score[a] -= 1  # a trusts someone (outdegree++)\n        trust_score[b] += 1  # b is trusted (indegree++)\n    \n    # Find the person with trust_score == n-1\n    for i in range(1, n + 1):\n        if trust_score[i] == n - 1:\n            return i\n    \n    return -1  # No judge found"
    },
    "javascript": {
      "template": "function findTheTownJudge(n, trust) {\n  \n}",
      "solution_text": "**Algorithm:**\nTo find the town judge, we need to find someone who:\n1. Trusts nobody (outdegree = 0)\n2. Is trusted by everyone else (indegree = n-1)\n\nWe can use a single array to track the net trust score (indegree - outdegree) for each person.\n\n**Time Complexity:** O(E) where E is the number of trust relationships\n**Space Complexity:** O(n) for the trust score array\n\n**Key Insights:**\n- The judge has a net trust score of n-1\n- Everyone else has a net trust score < n-1\n- If no judge exists, no one will have score n-1",
      "solution_code": "function findTheTownJudge(n, trust) {\n    if (n === 1) {\n        return 1; // Only one person, must be the judge\n    }\n    \n    // trustScore[i] = indegree[i] - outdegree[i]\n    const trustScore = new Array(n + 1).fill(0);\n    \n    for (const [a, b] of trust) {\n        trustScore[a]--; // a trusts someone (outdegree++)\n        trustScore[b]++; // b is trusted (indegree++)\n    }\n    \n    // Find the person with trustScore == n-1\n    for (let i = 1; i <= n; i++) {\n        if (trustScore[i] === n - 1) {\n            return i;\n        }\n    }\n    \n    return -1; // No judge found\n}"
    },
    "typescript": {
      "template": "function findTheTownJudge(n: number, trust: number[][]): number {\n  \n}",
      "solution_text": "**Algorithm:**\nTo find the town judge, we need to find someone who:\n1. Trusts nobody (outdegree = 0)\n2. Is trusted by everyone else (indegree = n-1)\n\nWe can use a single array to track the net trust score (indegree - outdegree) for each person.\n\n**Time Complexity:** O(E) where E is the number of trust relationships\n**Space Complexity:** O(n) for the trust score array\n\n**Key Insights:**\n- The judge has a net trust score of n-1\n- Everyone else has a net trust score < n-1\n- If no judge exists, no one will have score n-1",
      "solution_code": "function findTheTownJudge(n: number, trust: number[][]): number {\n    if (n === 1) {\n        return 1; // Only one person, must be the judge\n    }\n    \n    // trustScore[i] = indegree[i] - outdegree[i]\n    const trustScore: number[] = new Array(n + 1).fill(0);\n    \n    for (const [a, b] of trust) {\n        trustScore[a]--; // a trusts someone (outdegree++)\n        trustScore[b]++; // b is trusted (indegree++)\n    }\n    \n    // Find the person with trustScore == n-1\n    for (let i = 1; i <= n; i++) {\n        if (trustScore[i] === n - 1) {\n            return i;\n        }\n    }\n    \n    return -1; // No judge found\n}"
    },
    "java": {
      "template": "class Solution {\n    public int findTheTownJudge(int n, int[][] trust) {\n        \n    }\n}",
      "solution_text": "**Algorithm:**\nTo find the town judge, we need to find someone who:\n1. Trusts nobody (outdegree = 0)\n2. Is trusted by everyone else (indegree = n-1)\n\nWe can use a single array to track the net trust score (indegree - outdegree) for each person.\n\n**Time Complexity:** O(E) where E is the number of trust relationships\n**Space Complexity:** O(n) for the trust score array\n\n**Key Insights:**\n- The judge has a net trust score of n-1\n- Everyone else has a net trust score < n-1\n- If no judge exists, no one will have score n-1",
      "solution_code": "class Solution {\n    public int findTheTownJudge(int n, int[][] trust) {\n        if (n == 1) {\n            return 1; // Only one person, must be the judge\n        }\n        \n        // trustScore[i] = indegree[i] - outdegree[i]\n        int[] trustScore = new int[n + 1];\n        \n        for (int[] relation : trust) {\n            int a = relation[0];\n            int b = relation[1];\n            trustScore[a]--; // a trusts someone (outdegree++)\n            trustScore[b]++; // b is trusted (indegree++)\n        }\n        \n        // Find the person with trustScore == n-1\n        for (int i = 1; i <= n; i++) {\n            if (trustScore[i] == n - 1) {\n                return i;\n            }\n        }\n        \n        return -1; // No judge found\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "n": 2,
        "trust": [[1, 2]]
      },
      "output": 2
    },
    {
      "id": 2,
      "input": {
        "n": 3,
        "trust": [[1, 3], [2, 3]]
      },
      "output": 3
    },
    {
      "id": 3,
      "input": {
        "n": 3,
        "trust": [[1, 3], [2, 3], [3, 1]]
      },
      "output": -1
    },
    {
      "id": 4,
      "input": {
        "n": 4,
        "trust": [[1, 3], [1, 4], [2, 3], [2, 4], [4, 3]]
      },
      "output": 3
    },
    {
      "id": 5,
      "input": {
        "n": 1,
        "trust": []
      },
      "output": 1
    },
    {
      "id": 6,
      "input": {
        "n": 2,
        "trust": []
      },
      "output": -1
    },
    {
      "id": 7,
      "input": {
        "n": 3,
        "trust": [[1, 2], [2, 3]]
      },
      "output": -1
    },
    {
      "id": 8,
      "input": {
        "n": 4,
        "trust": [[1, 2], [1, 3], [1, 4]]
      },
      "output": -1
    },
    {
      "id": 9,
      "input": {
        "n": 5,
        "trust": [[1, 5], [2, 5], [3, 5], [4, 5]]
      },
      "output": 5
    },
    {
      "id": 10,
      "input": {
        "n": 6,
        "trust": [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]
      },
      "output": -1
    },
    {
      "id": 11,
      "input": {
        "n": 4,
        "trust": [[1, 3], [2, 3], [4, 3]]
      },
      "output": 3
    },
    {
      "id": 12,
      "input": {
        "n": 3,
        "trust": [[1, 2], [3, 2]]
      },
      "output": 2
    }
  ]
}