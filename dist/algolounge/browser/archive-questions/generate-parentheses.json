{
  "filename": "generate-parentheses",
  "title": "Generate Parentheses",
  "keywords": [
    "generate",
    "parentheses",
    "leetcode",
    "given",
    "integer",
    "return",
    "all",
    "well",
    "formed",
    "strings"
  ],
  "description": "<h2>Generate Parentheses</h2><p>Leetcode 22. Generate Parentheses</p><p></p><p>You are given an integer `n`. Return all well-formed parentheses strings that you can generate with `n` pairs of parentheses.</p><h3>Examples:</h3><ul><li>Input: n = 1<br><br>Output: [\"()\"]</li><li>Input: n = 3<br><br>Output: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]</li></ul><h3>Constraints:</h3><ul><li> `1 <= n <= 7`</li></ul>",
  "languages": {
    "python": {
      "template": "def generateParentheses(n):\n    ",
      "solution_text": "<p><strong>Backtracking Solution for Generate Parentheses:</strong></p><p>Generate all valid parentheses combinations using recursive backtracking.</p><p><strong>Algorithm:</strong></p><ol><li>Start with empty string and track open/close parentheses count</li><li>At each step: add '(' if open count < n, add ')' if close count < open count</li><li>Base case: when string length equals 2*n, add to result</li><li>Backtrack by trying both options at each valid position</li></ol><p><strong>Time Complexity:</strong> O(4^n / √n) - Catalan number combinations</p><p><strong>Space Complexity:</strong> O(4^n / √n) - for storing all valid combinations</p>",
      "solution_code": "def generateParentheses(n):\n    result = []\n    \n    def backtrack(current, open_count, close_count):\n        # Base case: complete valid combination\n        if len(current) == 2 * n:\n            result.append(current)\n            return\n        \n        # Add opening parenthesis if we haven't used all\n        if open_count < n:\n            backtrack(current + '(', open_count + 1, close_count)\n        \n        # Add closing parenthesis if it would be valid\n        if close_count < open_count:\n            backtrack(current + ')', open_count, close_count + 1)\n    \n    backtrack('', 0, 0)\n    return result"
    },
    "javascript": {
      "template": "function generateParentheses(n) {\n  \n}",
      "solution_text": "<p><strong>Backtracking Solution for Generate Parentheses:</strong></p><p>Generate all valid parentheses combinations using recursive backtracking.</p><p><strong>Algorithm:</strong></p><ol><li>Start with empty string and track open/close parentheses count</li><li>At each step: add '(' if open count < n, add ')' if close count < open count</li><li>Base case: when string length equals 2*n, add to result</li><li>Backtrack by trying both options at each valid position</li></ol><p><strong>Time Complexity:</strong> O(4^n / √n) - Catalan number combinations</p><p><strong>Space Complexity:</strong> O(4^n / √n) - for storing all valid combinations</p>",
      "solution_code": "function generateParentheses(n) {\n    const result = [];\n    \n    function backtrack(current, openCount, closeCount) {\n        // Base case: complete valid combination\n        if (current.length === 2 * n) {\n            result.push(current);\n            return;\n        }\n        \n        // Add opening parenthesis if we haven't used all\n        if (openCount < n) {\n            backtrack(current + '(', openCount + 1, closeCount);\n        }\n        \n        // Add closing parenthesis if it would be valid\n        if (closeCount < openCount) {\n            backtrack(current + ')', openCount, closeCount + 1);\n        }\n    }\n    \n    backtrack('', 0, 0);\n    return result;\n}"
    },
    "typescript": {
      "template": "function generateParentheses(n: number): string[] {\n  \n}",
      "solution_text": "<p><strong>Backtracking Solution for Generate Parentheses:</strong></p><p>Generate all valid parentheses combinations using recursive backtracking.</p><p><strong>Algorithm:</strong></p><ol><li>Start with empty string and track open/close parentheses count</li><li>At each step: add '(' if open count < n, add ')' if close count < open count</li><li>Base case: when string length equals 2*n, add to result</li><li>Backtrack by trying both options at each valid position</li></ol><p><strong>Time Complexity:</strong> O(4^n / √n) - Catalan number combinations</p><p><strong>Space Complexity:</strong> O(4^n / √n) - for storing all valid combinations</p>",
      "solution_code": "function generateParentheses(n: number): string[] {\n    const result: string[] = [];\n    \n    function backtrack(current: string, openCount: number, closeCount: number): void {\n        // Base case: complete valid combination\n        if (current.length === 2 * n) {\n            result.push(current);\n            return;\n        }\n        \n        // Add opening parenthesis if we haven't used all\n        if (openCount < n) {\n            backtrack(current + '(', openCount + 1, closeCount);\n        }\n        \n        // Add closing parenthesis if it would be valid\n        if (closeCount < openCount) {\n            backtrack(current + ')', openCount, closeCount + 1);\n        }\n    }\n    \n    backtrack('', 0, 0);\n    return result;\n}"
    },
    "java": {
      "template": "class Solution {\n    public List<String> generateParentheses(int n) {\n        \n    }\n}",
      "solution_text": "<p><strong>Backtracking Solution for Generate Parentheses:</strong></p><p>Generate all valid parentheses combinations using recursive backtracking.</p><p><strong>Algorithm:</strong></p><ol><li>Start with empty string and track open/close parentheses count</li><li>At each step: add '(' if open count < n, add ')' if close count < open count</li><li>Base case: when string length equals 2*n, add to result</li><li>Backtrack by trying both options at each valid position</li></ol><p><strong>Time Complexity:</strong> O(4^n / √n) - Catalan number combinations</p><p><strong>Space Complexity:</strong> O(4^n / √n) - for storing all valid combinations</p>",
      "solution_code": "class Solution {\n    public List<String> generateParentheses(int n) {\n        List<String> result = new ArrayList<>();\n        backtrack(result, \"\", 0, 0, n);\n        return result;\n    }\n    \n    private void backtrack(List<String> result, String current, int openCount, int closeCount, int n) {\n        // Base case: complete valid combination\n        if (current.length() == 2 * n) {\n            result.add(current);\n            return;\n        }\n        \n        // Add opening parenthesis if we haven't used all\n        if (openCount < n) {\n            backtrack(result, current + \"(\", openCount + 1, closeCount, n);\n        }\n        \n        // Add closing parenthesis if it would be valid\n        if (closeCount < openCount) {\n            backtrack(result, current + \")\", openCount, closeCount + 1, n);\n        }\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
      "test_cases": [
    {
      "id": 1,
      "input": {
        "n": 1
      },
      "output": [
        "()"
      ]
    },
    {
      "id": 2,
      "input": {
        "n": 3
      },
      "output": [
        "((()))",
        "(()())",
        "(())()",
        "()(())",
        "()()()"
      ]
    },
    {
      "id": 3,
      "input": {
        "n": 2
      },
      "output": [
        "(())",
        "()()"
      ]
    },
    {
      "id": 4,
      "input": {
        "n": 0
      },
      "output": [
        ""
      ]
    },
    {
      "id": 5,
      "input": {
        "n": 4
      },
      "output": [
        "(((())))",
        "((()()))",
        "((())())",
        "((()))()",
        "(()(()))",
        "(()()())",
        "(()())()",
        "(())(())",
        "(())()()",
        "()((()))",
        "()(()())",
        "()(())()",
        "()()(())",
        "()()()()"
      ]
    },
    {
      "id": 6,
      "input": {
        "n": 5
      },
      "output": [
        "((((())))",
        "(((()())))",
        "(((())()))",
        "(((()))())",
        "(((())))()",
        "((()(())))",
        "((()()()))",
        "((()())())",
        "((()()))()",
        "((())(()))",
        "((())()())",
        "((())())()",
        "((()))(())",
        "((()))()()",
        "(()((())))",
        "(()()()())",
        "(()()())()",
        "(()())(())",
        "(()())()()",
        "(())(((())))",
        "(())(()())",
        "(())(())()",
        "(())()(())",
        "(())()()()",
        "()(((()))))",
        "()((()()))",
        "()((())())",
        "()((()))()",
        "()(()(()))",
        "()(()()())",
        "()(()())()",
        "()(())(())",
        "()(())()()",
        "()()((()))",
        "()()(()())",
        "()()(())()",
        "()()()(())",
        "()()()()()"
      ]
    },
    {
      "id": 7,
      "input": {
        "n": 6
      },
      "output": [
        "(((((())))))",
        "((((()())))",
        "((((())()))",
        "((((()))())",
        "((((())))()",
        "(((()(())))",
        "(((()()()))",
        "(((()())())",
        "(((()()))()",
        "(((())(()))",
        "(((())()())",
        "(((())())()",
        "(((()))(())",
        "(((()))()()"
      ]
    },
    {
      "id": 8,
      "input": {
        "n": 7
      },
      "output": [
        "((((((()))))))",
        "(((((()()))))))",
        "(((((())()))))))",
        "(((((()))()))))))"
      ]
    },
    {
      "id": 9,
      "input": {
        "n": 1
      },
      "output": [
        "()"
      ]
    },
    {
      "id": 10,
      "input": {
        "n": 2
      },
      "output": [
        "(())",
        "()()"
      ]
    }
  ]
},
    {
      "id": 2,
      "input": {
        "n": 3
      },
      "output": [
        "((()))",
        "(()())",
        "(())()",
        "()(())",
        "()()()"
      ]
    },
    {
      "id": 3,
      "input": {
        "n": 2
      },
      "output": [
        "(())",
        "()()"
      ]
    },
    {
      "id": 4,
      "input": {
        "n": 0
      },
      "output": [
        ""
      ]
    },
    {
      "id": 5,
      "input": {
        "n": 4
      },
      "output": [
        "(((())))",
        "((()()))",
        "((())())",
        "((()))()",
        "(()(()))",
        "(()()())",
        "(()())()",
        "(())(())",
        "(())()()",
        "()((()))",
        "()(()())",
        "()(())()",
        "()()(())",
        "()()()()"
      ]
    },
    {
      "id": 6,
      "input": {
        "n": 5
      },
      "output": [
        "((((())))",
        "(((()())))",
        "(((())()))",
        "(((()))())",
        "(((())))()",
        "((()(())))",
        "((()()()))",
        "((()())())",
        "((()()))()",
        "((())(()))",
        "((())()())",
        "((())())()",
        "((()))(())",
        "((()))()()",
        "(()((())))",
        "(()()()())",
        "(()()())()",
        "(()())(())",
        "(()())()()",
        "(())(((())))",
        "(())(()())",
        "(())(())()",
        "(())()(())",
        "(())()()()",
        "()(((()))))",
        "()((()()))",
        "()((())())",
        "()((()))()",
        "()(()(()))",
        "()(()()())",
        "()(()())()",
        "()(())(())",
        "()(())()()",
        "()()((()))",
        "()()(()())",
        "()()(())()",
        "()()()(())",
        "()()()()()"
      ]
    },
    {
      "id": 7,
      "input": {
        "n": 6
      },
      "output": [
        "(((((())))))",
        "((((()())))",
        "((((())()))",
        "((((()))())",
        "((((())))()",
        "(((()(())))",
        "(((()()()))",
        "(((()())())",
        "(((()()))()",
        "(((())(()))",
        "(((())()())",
        "(((())())()",
        "(((()))(())",
        "(((()))()()"
      ]
    },
    {
      "id": 8,
      "input": {
        "n": 7
      },
      "output": [
        "((((((()))))))",
        "(((((()()))))))",
        "(((((())()))))))",
        "(((((()))()))))))"
      ]
    },
    {
      "id": 9,
      "input": {
        "n": 1
      },
      "output": [
        "()"
      ]
    },
    {
      "id": 10,
      "input": {
        "n": 2
      },
      "output": [
        "(())",
        "()()"
      ]
    }
  ]
}