{
  "filename": "implement-stack-using-queues",
  "title": "Implement Stack Using Queues",
  "keywords": [
    "implement",
    "stack",
    "using",
    "queues",
    "leetcode",
    "225",
    "last",
    "first",
    "out",
    "lifo"
  ],
  "description": "<h2>Implement Stack Using Queues</h2><p>Leetcode 225. Implement Stack Using Queues</p><p></p><p>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (`push`, `top`, `pop`, and `empty`).</p><p></p><p>Implement the `MyStack` class:</p><p></p><p>- `void push(int x)` Pushes element `x` to the top of the stack.</p><p>- `int pop()` Removes the element on the top of the stack and returns it.</p><p>- `int top()` Returns the element on the top of the stack.</p><p>- `boolean empty()` Returns true if the stack is empty, false otherwise.</p><p></p><p>**Notes:**</p><p></p><p>- You must use **only** standard operations of a queue, which means that only `push` to `back`, `peek/pop from front`, `size` and `is empty` operations are valid.</p><p>- Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.</p><h3>Examples:</h3><ul><li>Input: [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"]<br>[[], [1], [2], [], [], []]<br><br>Output: [null, null, null, 2, 2, false]<br>MyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // return 2\nmyStack.pop(); // return 2\nmyStack.empty(); // return False</li></ul><h3>Constraints:</h3><ul><li> `1 <= x <= 9`</li><li> At most `100` calls will be made to `push`, `pop`, `top`, and empty.</li><li> All the calls to `pop` and `top` are valid.</li></ul>",
  "languages": {
    "python": {
      "template": "def implementStackUsingQueues(operations, values):\n    ",
      "solution_text": "<h3>Solution Approach</h3><p><strong>Algorithm:</strong><br/>We implement a stack using one queue by making push operations expensive. The key insight is that after pushing an element, we rotate the queue to bring the new element to the front.</p><p><strong>Strategy:</strong><br/>- Use a single queue<br/>- For push: Add element to queue, then rotate by dequeuing and re-enqueuing n-1 elements<br/>- For pop/top: Simply dequeue from front (which is now the top of stack)<br/>- For empty: Check if queue is empty</p><p><strong>Time Complexity:</strong><br/>- Push: O(n) where n is number of elements<br/>- Pop/Top: O(1)<br/>- Empty: O(1)</p><p><strong>Space Complexity:</strong> O(n) where n is the number of elements in the stack</p><p><strong>Key Insights:</strong><br/>- By rotating after each push, we maintain stack order in a queue<br/>- This approach makes push expensive but keeps pop/top operations efficient<br/>- Alternative approach uses two queues but is more complex</p>",
      "solution_code": "def implementStackUsingQueues(operations, values):\n    from collections import deque\n    \n    class MyStack:\n        def __init__(self):\n            self.queue = deque()\n        \n        def push(self, x):\n            self.queue.append(x)\n            # Rotate the queue to put the new element at front\n            for _ in range(len(self.queue) - 1):\n                self.queue.append(self.queue.popleft())\n        \n        def pop(self):\n            return self.queue.popleft()\n        \n        def top(self):\n            return self.queue[0]\n        \n        def empty(self):\n            return len(self.queue) == 0\n    \n    stack = None\n    results = []\n    \n    for i, operation in enumerate(operations):\n        if operation == \"MyStack\":\n            stack = MyStack()\n            results.append(None)\n        elif operation == \"push\":\n            stack.push(values[i][0])\n            results.append(None)\n        elif operation == \"pop\":\n            results.append(stack.pop())\n        elif operation == \"top\":\n            results.append(stack.top())\n        elif operation == \"empty\":\n            results.append(stack.empty())\n    \n    return results"
    },
    "javascript": {
      "template": "function implementStackUsingQueues(operations, values) {\n  \n}",
      "solution_text": "<h3>Solution Approach</h3><p><strong>Algorithm:</strong><br/>We implement a stack using one queue by making push operations expensive. The key insight is that after pushing an element, we rotate the queue to bring the new element to the front.</p><p><strong>Strategy:</strong><br/>- Use a single queue<br/>- For push: Add element to queue, then rotate by dequeuing and re-enqueuing n-1 elements<br/>- For pop/top: Simply dequeue from front (which is now the top of stack)<br/>- For empty: Check if queue is empty</p><p><strong>Time Complexity:</strong><br/>- Push: O(n) where n is number of elements<br/>- Pop/Top: O(1)<br/>- Empty: O(1)</p><p><strong>Space Complexity:</strong> O(n) where n is the number of elements in the stack</p><p><strong>Key Insights:</strong><br/>- By rotating after each push, we maintain stack order in a queue<br/>- This approach makes push expensive but keeps pop/top operations efficient<br/>- Alternative approach uses two queues but is more complex</p>",
      "solution_code": "function implementStackUsingQueues(operations, values) {\n    class MyStack {\n        constructor() {\n            this.queue = [];\n        }\n        \n        push(x) {\n            this.queue.push(x);\n            // Rotate the queue to put the new element at front\n            const size = this.queue.length;\n            for (let i = 0; i < size - 1; i++) {\n                this.queue.push(this.queue.shift());\n            }\n        }\n        \n        pop() {\n            return this.queue.shift();\n        }\n        \n        top() {\n            return this.queue[0];\n        }\n        \n        empty() {\n            return this.queue.length === 0;\n        }\n    }\n    \n    let stack = null;\n    const results = [];\n    \n    for (let i = 0; i < operations.length; i++) {\n        const operation = operations[i];\n        \n        if (operation === \"MyStack\") {\n            stack = new MyStack();\n            results.push(null);\n        } else if (operation === \"push\") {\n            stack.push(values[i][0]);\n            results.push(null);\n        } else if (operation === \"pop\") {\n            results.push(stack.pop());\n        } else if (operation === \"top\") {\n            results.push(stack.top());\n        } else if (operation === \"empty\") {\n            results.push(stack.empty());\n        }\n    }\n    \n    return results;\n}"
    },
    "typescript": {
      "template": "function implementStackUsingQueues(operations: string[], values: number[][]): (number | null | boolean)[] {\n  \n}",
      "solution_text": "<h3>Solution Approach</h3><p><strong>Algorithm:</strong><br/>We implement a stack using one queue by making push operations expensive. The key insight is that after pushing an element, we rotate the queue to bring the new element to the front.</p><p><strong>Strategy:</strong><br/>- Use a single queue<br/>- For push: Add element to queue, then rotate by dequeuing and re-enqueuing n-1 elements<br/>- For pop/top: Simply dequeue from front (which is now the top of stack)<br/>- For empty: Check if queue is empty</p><p><strong>Time Complexity:</strong><br/>- Push: O(n) where n is number of elements<br/>- Pop/Top: O(1)<br/>- Empty: O(1)</p><p><strong>Space Complexity:</strong> O(n) where n is the number of elements in the stack</p><p><strong>Key Insights:</strong><br/>- By rotating after each push, we maintain stack order in a queue<br/>- This approach makes push expensive but keeps pop/top operations efficient<br/>- Alternative approach uses two queues but is more complex</p>",
      "solution_code": "function implementStackUsingQueues(operations: string[], values: number[][]): (number | null | boolean)[] {\n    class MyStack {\n        private queue: number[];\n        \n        constructor() {\n            this.queue = [];\n        }\n        \n        push(x: number): void {\n            this.queue.push(x);\n            // Rotate the queue to put the new element at front\n            const size = this.queue.length;\n            for (let i = 0; i < size - 1; i++) {\n                this.queue.push(this.queue.shift()!);\n            }\n        }\n        \n        pop(): number {\n            return this.queue.shift()!;\n        }\n        \n        top(): number {\n            return this.queue[0];\n        }\n        \n        empty(): boolean {\n            return this.queue.length === 0;\n        }\n    }\n    \n    let stack: MyStack | null = null;\n    const results: (number | null | boolean)[] = [];\n    \n    for (let i = 0; i < operations.length; i++) {\n        const operation = operations[i];\n        \n        if (operation === \"MyStack\") {\n            stack = new MyStack();\n            results.push(null);\n        } else if (operation === \"push\") {\n            stack!.push(values[i][0]);\n            results.push(null);\n        } else if (operation === \"pop\") {\n            results.push(stack!.pop());\n        } else if (operation === \"top\") {\n            results.push(stack!.top());\n        } else if (operation === \"empty\") {\n            results.push(stack!.empty());\n        }\n    }\n    \n    return results;\n}"
    },
    "java": {
      "template": "import java.util.*;\n\nclass Solution {\n    public Object[] implementStackUsingQueues(String[] operations, int[][] values) {\n        \n    }\n}",
      "solution_text": "<h3>Solution Approach</h3><p><strong>Algorithm:</strong><br/>We implement a stack using one queue by making push operations expensive. The key insight is that after pushing an element, we rotate the queue to bring the new element to the front.</p><p><strong>Strategy:</strong><br/>- Use a single queue<br/>- For push: Add element to queue, then rotate by dequeuing and re-enqueuing n-1 elements<br/>- For pop/top: Simply dequeue from front (which is now the top of stack)<br/>- For empty: Check if queue is empty</p><p><strong>Time Complexity:</strong><br/>- Push: O(n) where n is number of elements<br/>- Pop/Top: O(1)<br/>- Empty: O(1)</p><p><strong>Space Complexity:</strong> O(n) where n is the number of elements in the stack</p><p><strong>Key Insights:</strong><br/>- By rotating after each push, we maintain stack order in a queue<br/>- This approach makes push expensive but keeps pop/top operations efficient<br/>- Alternative approach uses two queues but is more complex</p>",
      "solution_code": "import java.util.*;\n\nclass Solution {\n    public Object[] implementStackUsingQueues(String[] operations, int[][] values) {\n        class MyStack {\n            private Queue<Integer> queue;\n            \n            public MyStack() {\n                queue = new LinkedList<>();\n            }\n            \n            public void push(int x) {\n                queue.offer(x);\n                // Rotate the queue to put the new element at front\n                int size = queue.size();\n                for (int i = 0; i < size - 1; i++) {\n                    queue.offer(queue.poll());\n                }\n            }\n            \n            public int pop() {\n                return queue.poll();\n            }\n            \n            public int top() {\n                return queue.peek();\n            }\n            \n            public boolean empty() {\n                return queue.isEmpty();\n            }\n        }\n        \n        MyStack stack = null;\n        List<Object> results = new ArrayList<>();\n        \n        for (int i = 0; i < operations.length; i++) {\n            String operation = operations[i];\n            \n            if (operation.equals(\"MyStack\")) {\n                stack = new MyStack();\n                results.add(null);\n            } else if (operation.equals(\"push\")) {\n                stack.push(values[i][0]);\n                results.add(null);\n            } else if (operation.equals(\"pop\")) {\n                results.add(stack.pop());\n            } else if (operation.equals(\"top\")) {\n                results.add(stack.top());\n            } else if (operation.equals(\"empty\")) {\n                results.add(stack.empty());\n            }\n        }\n        \n        return results.toArray();\n    }\n}"
    }
  },
  "order_matters": true,
  "test_cases": [
    {
      "id": 1,
      "input": [
        ["MyStack", "push", "push", "top", "pop", "empty"],
        [[], [1], [2], [], [], []]
      ],
      "output": [null, null, null, 2, 2, false]
    },
    {
      "id": 2,
      "input": [
        ["MyStack", "push", "push", "push", "pop", "top", "pop", "empty"],
        [[], [1], [2], [3], [], [], [], []]
      ],
      "output": [null, null, null, null, 3, 2, 2, false]
    },
    {
      "id": 3,
      "input": [
        ["MyStack", "push", "top", "push", "top", "pop", "top", "pop", "empty"],
        [[], [1], [], [2], [], [], [], [], []]
      ],
      "output": [null, null, 1, null, 2, 2, 1, 1, true]
    },
    {
      "id": 4,
      "input": [
        ["MyStack", "empty", "push", "empty", "top", "pop", "empty"],
        [[], [], [5], [], [], [], []]
      ],
      "output": [null, true, null, false, 5, 5, true]
    },
    {
      "id": 5,
      "input": [
        ["MyStack", "push", "push", "push", "push", "pop", "pop", "pop", "pop", "empty"],
        [[], [1], [2], [3], [4], [], [], [], [], []]
      ],
      "output": [null, null, null, null, null, 4, 3, 2, 1, true]
    },
    {
      "id": 6,
      "input": [
        ["MyStack", "push", "top", "top", "pop", "empty"],
        [[], [9], [], [], [], []]
      ],
      "output": [null, null, 9, 9, 9, true]
    },
    {
      "id": 7,
      "input": [
        ["MyStack", "push", "push", "pop", "push", "top", "pop", "pop", "empty"],
        [[], [1], [2], [], [3], [], [], [], []]
      ],
      "output": [null, null, null, 2, null, 3, 3, 1, true]
    },
    {
      "id": 8,
      "input": [
        ["MyStack", "push", "push", "push", "top", "pop", "top", "pop", "top", "pop"],
        [[], [1], [2], [3], [], [], [], [], [], []]
      ],
      "output": [null, null, null, null, 3, 3, 2, 2, 1, 1]
    },
    {
      "id": 9,
      "input": [
        ["MyStack", "push", "push", "push", "push", "push", "pop", "pop", "pop", "pop", "pop"],
        [[], [5], [4], [3], [2], [1], [], [], [], [], []]
      ],
      "output": [null, null, null, null, null, null, 1, 2, 3, 4, 5]
    },
    {
      "id": 10,
      "input": [
        ["MyStack", "push", "top", "push", "top", "push", "top", "pop", "top", "pop", "top"],
        [[], [7], [], [8], [], [9], [], [], [], [], []]
      ],
      "output": [null, null, 7, null, 8, null, 9, 9, 8, 8, 7]
    }
  ]
}