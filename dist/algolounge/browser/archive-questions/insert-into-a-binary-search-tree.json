{
  "filename": "insert-into-a-binary-search-tree",
  "title": "Insert into a Binary Search Tree",
  "keywords": [
    "insert",
    "into",
    "binary",
    "search",
    "tree",
    "leetcode",
    "701",
    "given",
    "root",
    "node"
  ],
  "description": "<h2>Insert into a Binary Search Tree</h2><p>Leetcode 701. Insert into a Binary Search Tree</p><p></p><p>You are given the `root` node of a binary search tree (BST) and a value `val` to insert into the tree. Return the root node of the BST after the insertion. It is **guaranteed** that the new value does not exist in the original BST.</p><p></p><p>Note: There may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.</p><h3>Examples:</h3><ul><li>Input: root = [5,3,6,null,4,null,10,null,null,7], val = 9<br><br>Output: [5,3,6,null,4,null,10,null,null,7,null,null,9]</li></ul><h3>Constraints:</h3><ul><li> `0 <= The number of nodes in the tree <= 10,000`.</li><li> `-100,000,000 <= val, Node.val <= 100,000,000`</li><li> All the values `Node.val` are unique.</li><li> It's **guaranteed** that `val` does not exist in the original BST.</li></ul>",
  "languages": {
    "python": {
      "template": "def insertIntoABinarySearchTree(root, val):\n    ",
      "solution_text": "<p><strong>BST Insertion Algorithm:</strong></p><p>Insert value into Binary Search Tree while maintaining BST property.</p><p><strong>Algorithm:</strong></p><ol><li>If root is null, create new node with val and return it</li><li>If val < root.val, recursively insert into left subtree</li><li>If val > root.val, recursively insert into right subtree</li><li>Return root after insertion</li></ol><p><strong>Time Complexity:</strong> O(h) where h is tree height, O(log n) average case</p><p><strong>Space Complexity:</strong> O(h) for recursion stack</p>",
      "solution_code": "def insertIntoABinarySearchTree(root, val):\n    if not root:\n        return TreeNode(val)\n    \n    if val < root.val:\n        root.left = insertIntoABinarySearchTree(root.left, val)\n    else:  # val > root.val (guaranteed val doesn't exist)\n        root.right = insertIntoABinarySearchTree(root.right, val)\n    \n    return root"
    },
    "javascript": {
      "template": "function insertIntoABinarySearchTree(root, val) {\n  \n}",
      "solution_text": "<p><strong>BST Insertion Algorithm:</strong></p><p>Insert value into Binary Search Tree while maintaining BST property.</p><p><strong>Algorithm:</strong></p><ol><li>If root is null, create new node with val and return it</li><li>If val < root.val, recursively insert into left subtree</li><li>If val > root.val, recursively insert into right subtree</li><li>Return root after insertion</li></ol><p><strong>Time Complexity:</strong> O(h) where h is tree height, O(log n) average case</p><p><strong>Space Complexity:</strong> O(h) for recursion stack</p>",
      "solution_code": "function insertIntoABinarySearchTree(root, val) {\n    if (!root) {\n        return new TreeNode(val);\n    }\n    \n    if (val < root.val) {\n        root.left = insertIntoABinarySearchTree(root.left, val);\n    } else {  // val > root.val (guaranteed val doesn't exist)\n        root.right = insertIntoABinarySearchTree(root.right, val);\n    }\n    \n    return root;\n}"
    },
    "typescript": {
      "template": "function insertIntoABinarySearchTree(root: TreeNode | null, val: number): TreeNode | null {\n  \n}",
      "solution_text": "<p><strong>BST Insertion Algorithm:</strong></p><p>Insert value into Binary Search Tree while maintaining BST property.</p><p><strong>Algorithm:</strong></p><ol><li>If root is null, create new node with val and return it</li><li>If val < root.val, recursively insert into left subtree</li><li>If val > root.val, recursively insert into right subtree</li><li>Return root after insertion</li></ol><p><strong>Time Complexity:</strong> O(h) where h is tree height, O(log n) average case</p><p><strong>Space Complexity:</strong> O(h) for recursion stack</p>",
      "solution_code": "function insertIntoABinarySearchTree(root: TreeNode | null, val: number): TreeNode | null {\n    if (!root) {\n        return new TreeNode(val);\n    }\n    \n    if (val < root.val) {\n        root.left = insertIntoABinarySearchTree(root.left, val);\n    } else {  // val > root.val (guaranteed val doesn't exist)\n        root.right = insertIntoABinarySearchTree(root.right, val);\n    }\n    \n    return root;\n}"
    },
    "java": {
      "template": "class Solution {\n    public TreeNode insertIntoABinarySearchTree(TreeNode root, int val) {\n        \n    }\n}",
      "solution_text": "<p><strong>BST Insertion Algorithm:</strong></p><p>Insert value into Binary Search Tree while maintaining BST property.</p><p><strong>Algorithm:</strong></p><ol><li>If root is null, create new node with val and return it</li><li>If val < root.val, recursively insert into left subtree</li><li>If val > root.val, recursively insert into right subtree</li><li>Return root after insertion</li></ol><p><strong>Time Complexity:</strong> O(h) where h is tree height, O(log n) average case</p><p><strong>Space Complexity:</strong> O(h) for recursion stack</p>",
      "solution_code": "class Solution {\n    public TreeNode insertIntoABinarySearchTree(TreeNode root, int val) {\n        if (root == null) {\n            return new TreeNode(val);\n        }\n        \n        if (val < root.val) {\n            root.left = insertIntoABinarySearchTree(root.left, val);\n        } else {  // val > root.val (guaranteed val doesn't exist)\n            root.right = insertIntoABinarySearchTree(root.right, val);\n        }\n        \n        return root;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "root": [4, 2, 7, 1, 3],
        "val": 5
      },
      "output": [4, 2, 7, 1, 3, 5]
    },
    {
      "id": 2,
      "input": {
        "root": [40, 20, 60, 10, 30, 50, 70],
        "val": 25
      },
      "output": [40, 20, 60, 10, 30, 50, 70, null, null, 25]
    },
    {
      "id": 3,
      "input": {
        "root": [4, 2, 7, 1, 3, null, null, null, null, null, null],
        "val": 5
      },
      "output": [4, 2, 7, 1, 3, 5]
    },
    {
      "id": 4,
      "input": {
        "root": [],
        "val": 5
      },
      "output": [5]
    },
    {
      "id": 5,
      "input": {
        "root": [1],
        "val": 2
      },
      "output": [1, null, 2]
    },
    {
      "id": 6,
      "input": {
        "root": [5],
        "val": 3
      },
      "output": [5, 3]
    },
    {
      "id": 7,
      "input": {
        "root": [5, 3, 8, 2, 4, 7, 10],
        "val": 6
      },
      "output": [5, 3, 8, 2, 4, 7, 10, null, null, null, null, 6]
    },
    {
      "id": 8,
      "input": {
        "root": [10, 5, 15, null, 7, 12, 20],
        "val": 6
      },
      "output": [10, 5, 15, null, 7, 12, 20, null, null, 6]
    },
    {
      "id": 9,
      "input": {
        "root": [8, 3, 10, 1, 6, null, 14, null, null, 4, 7, 13],
        "val": 5
      },
      "output": [8, 3, 10, 1, 6, null, 14, null, null, 4, 7, 13, null, null, null, 5]
    },
    {
      "id": 10,
      "input": {
        "root": [2, 1, 3],
        "val": 4
      },
      "output": [2, 1, 3, null, null, null, 4]
    }
  ]
}