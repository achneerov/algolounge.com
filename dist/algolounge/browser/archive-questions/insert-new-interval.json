{
  "filename": "insert-new-interval",
  "title": "Insert Interval",
  "keywords": [
    "insert",
    "interval",
    "leetcode",
    "given",
    "array",
    "non",
    "overlapping",
    "intervals",
    "where",
    "start_i"
  ],
  "description": "<h2>Insert Interval</h2><p>Leetcode 57. Insert Interval</p><p></p><p>You are given an array of non-overlapping intervals `intervals` where `intervals[i] = [start_i, end_i]` represents the start and the end time of the `ith` interval. `intervals` is initially sorted in ascending order by `start_i`.</p><p></p><p>You are given another interval `newInterval = [start, end]`.</p><p></p><p>Insert `newInterval` into `intervals` such that `intervals` is still sorted in ascending order by `start_i` and also `intervals` still does not have any overlapping intervals. You may merge the overlapping intervals if needed.</p><p></p><p>Return `intervals` after adding `newInterval`.</p><p></p><p>Note: Intervals are *non-overlapping* if they have no common point. For example, [1,2] and [3,4] are non-overlapping, but [1,2] and [2,3] are overlapping.</p><h3>Examples:</h3><ul><li>Input: intervals = [[1,3],[4,6]], newInterval = [2,5]<br><br>Output: [[1,6]]</li><li>Input: intervals = [[1,2],[3,5],[9,10]], newInterval = [6,7]<br><br>Output: [[1,2],[3,5],[6,7],[9,10]]</li></ul><h3>Constraints:</h3><ul><li> `0 <= intervals.length <= 1000`</li><li> `newInterval.length == intervals[i].length == 2`</li><li> `0 <= start <= end <= 1000`</li></ul>",
  "languages": {
    "python": {
      "template": "def insertInterval(intervals, newInterval):\n    ",
      "solution_text": "<h3>Solution Approach</h3><p><strong>Algorithm:</strong><br/>We solve this by processing intervals in three phases: before overlap, during overlap (merge), and after overlap. This ensures we handle all cases correctly.</p><p><strong>Strategy:</strong><br/>1. Add all intervals that end before the new interval starts<br/>2. Merge all overlapping intervals with the new interval<br/>3. Add all remaining intervals that start after the merged interval ends</p><p><strong>Time Complexity:</strong> O(n) where n is the number of intervals</p><p><strong>Space Complexity:</strong> O(n) for the result array</p><p><strong>Key Insights:</strong><br/>- Two intervals [a,b] and [c,d] overlap if max(a,c) <= min(b,d)<br/>- When merging overlapping intervals, take min of starts and max of ends<br/>- Process intervals sequentially, handling three distinct phases</p>",
      "solution_code": "def insertInterval(intervals, newInterval):\n    result = []\n    i = 0\n    n = len(intervals)\n    \n    # Add all intervals that end before newInterval starts\n    while i < n and intervals[i][1] < newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n    \n    # Merge overlapping intervals\n    while i < n and intervals[i][0] <= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n    \n    # Add the merged interval\n    result.append(newInterval)\n    \n    # Add all remaining intervals\n    while i < n:\n        result.append(intervals[i])\n        i += 1\n    \n    return result"
    },
    "javascript": {
      "template": "function insertInterval(intervals, newInterval) {\n  \n}",
      "solution_text": "<h3>Solution Approach</h3><p><strong>Algorithm:</strong><br/>We solve this by processing intervals in three phases: before overlap, during overlap (merge), and after overlap. This ensures we handle all cases correctly.</p><p><strong>Strategy:</strong><br/>1. Add all intervals that end before the new interval starts<br/>2. Merge all overlapping intervals with the new interval<br/>3. Add all remaining intervals that start after the merged interval ends</p><p><strong>Time Complexity:</strong> O(n) where n is the number of intervals</p><p><strong>Space Complexity:</strong> O(n) for the result array</p><p><strong>Key Insights:</strong><br/>- Two intervals [a,b] and [c,d] overlap if max(a,c) <= min(b,d)<br/>- When merging overlapping intervals, take min of starts and max of ends<br/>- Process intervals sequentially, handling three distinct phases</p>",
      "solution_code": "function insertInterval(intervals, newInterval) {\n    const result = [];\n    let i = 0;\n    \n    // Add all intervals that end before newInterval starts\n    while (i < intervals.length && intervals[i][1] < newInterval[0]) {\n        result.push(intervals[i]);\n        i++;\n    }\n    \n    // Merge overlapping intervals\n    while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n        newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n        i++;\n    }\n    \n    // Add the merged interval\n    result.push(newInterval);\n    \n    // Add all remaining intervals\n    while (i < intervals.length) {\n        result.push(intervals[i]);\n        i++;\n    }\n    \n    return result;\n}"
    },
    "typescript": {
      "template": "function insertInterval(intervals: number[][], newInterval: number[]): number[][] {\n  \n}",
      "solution_text": "<h3>Solution Approach</h3><p><strong>Algorithm:</strong><br/>We solve this by processing intervals in three phases: before overlap, during overlap (merge), and after overlap. This ensures we handle all cases correctly.</p><p><strong>Strategy:</strong><br/>1. Add all intervals that end before the new interval starts<br/>2. Merge all overlapping intervals with the new interval<br/>3. Add all remaining intervals that start after the merged interval ends</p><p><strong>Time Complexity:</strong> O(n) where n is the number of intervals</p><p><strong>Space Complexity:</strong> O(n) for the result array</p><p><strong>Key Insights:</strong><br/>- Two intervals [a,b] and [c,d] overlap if max(a,c) <= min(b,d)<br/>- When merging overlapping intervals, take min of starts and max of ends<br/>- Process intervals sequentially, handling three distinct phases</p>",
      "solution_code": "function insertInterval(intervals: number[][], newInterval: number[]): number[][] {\n    const result: number[][] = [];\n    let i = 0;\n    \n    // Add all intervals that end before newInterval starts\n    while (i < intervals.length && intervals[i][1] < newInterval[0]) {\n        result.push(intervals[i]);\n        i++;\n    }\n    \n    // Merge overlapping intervals\n    while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n        newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n        i++;\n    }\n    \n    // Add the merged interval\n    result.push(newInterval);\n    \n    // Add all remaining intervals\n    while (i < intervals.length) {\n        result.push(intervals[i]);\n        i++;\n    }\n    \n    return result;\n}"
    },
    "java": {
      "template": "import java.util.*;\n\nclass Solution {\n    public int[][] insertInterval(int[][] intervals, int[] newInterval) {\n        \n    }\n}",
      "solution_text": "<h3>Solution Approach</h3><p><strong>Algorithm:</strong><br/>We solve this by processing intervals in three phases: before overlap, during overlap (merge), and after overlap. This ensures we handle all cases correctly.</p><p><strong>Strategy:</strong><br/>1. Add all intervals that end before the new interval starts<br/>2. Merge all overlapping intervals with the new interval<br/>3. Add all remaining intervals that start after the merged interval ends</p><p><strong>Time Complexity:</strong> O(n) where n is the number of intervals</p><p><strong>Space Complexity:</strong> O(n) for the result array</p><p><strong>Key Insights:</strong><br/>- Two intervals [a,b] and [c,d] overlap if max(a,c) <= min(b,d)<br/>- When merging overlapping intervals, take min of starts and max of ends<br/>- Process intervals sequentially, handling three distinct phases</p>",
      "solution_code": "import java.util.*;\n\nclass Solution {\n    public int[][] insertInterval(int[][] intervals, int[] newInterval) {\n        List<int[]> result = new ArrayList<>();\n        int i = 0;\n        \n        // Add all intervals that end before newInterval starts\n        while (i < intervals.length && intervals[i][1] < newInterval[0]) {\n            result.add(intervals[i]);\n            i++;\n        }\n        \n        // Merge overlapping intervals\n        while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n            i++;\n        }\n        \n        // Add the merged interval\n        result.add(newInterval);\n        \n        // Add all remaining intervals\n        while (i < intervals.length) {\n            result.add(intervals[i]);\n            i++;\n        }\n        \n        return result.toArray(new int[result.size()][]);\n    }\n}"
    }
  },
  "order_matters": true,
  "test_cases": [
    {
      "id": 1,
      "input": [[[1,3],[6,9]], [2,5]],
      "output": [[1,5],[6,9]]
    },
    {
      "id": 2,
      "input": [[[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8]],
      "output": [[1,2],[3,10],[12,16]]
    },
    {
      "id": 3,
      "input": [[], [5,7]],
      "output": [[5,7]]
    },
    {
      "id": 4,
      "input": [[[1,5]], [2,3]],
      "output": [[1,5]]
    },
    {
      "id": 5,
      "input": [[[1,5]], [6,8]],
      "output": [[1,5],[6,8]]
    },
    {
      "id": 6,
      "input": [[[3,5],[12,15]], [6,6]],
      "output": [[3,5],[6,6],[12,15]]
    },
    {
      "id": 7,
      "input": [[[1,3],[4,6],[8,10]], [5,7]],
      "output": [[1,3],[4,10]]
    },
    {
      "id": 8,
      "input": [[[2,3],[5,5],[6,7],[8,10]], [0,1]],
      "output": [[0,1],[2,3],[5,5],[6,7],[8,10]]
    },
    {
      "id": 9,
      "input": [[[2,4],[5,7],[8,10],[11,13]], [3,6]],
      "output": [[2,7],[8,10],[11,13]]
    },
    {
      "id": 10,
      "input": [[[0,2],[3,9]], [6,8]],
      "output": [[0,2],[3,9]]
    }
  ]
}