{
  "filename": "invert-a-binary-tree",
  "title": "Invert Binary Tree",
  "keywords": [
    "invert",
    "binary",
    "tree",
    "leetcode",
    "226",
    "given",
    "root",
    "return",
    "its",
    "example"
  ],
  "description": "<h2>Invert Binary Tree</h2><p>Leetcode 226. Invert Binary Tree</p><p></p><p>You are given the root of a binary tree `root`. Invert the binary tree and return its root.</p><h3>Examples:</h3><ul><li>Input: root = []<br><br>Output: []</li></ul><h3>Constraints:</h3><ul><li> `0 <= The number of nodes in the tree <= 100`.</li><li> `-100 <= Node.val <= 100`</li></ul>",
  "languages": {
    "python": {
      "template": "def invertBinaryTree(root):\n    ",
      "solution_text": "<p><strong>Binary Tree Inversion Algorithm:</strong></p><p>Recursively swap left and right children of every node in the tree.</p><p><strong>Algorithm:</strong></p><ol><li>If root is null, return null (base case)</li><li>Recursively invert left and right subtrees</li><li>Swap the left and right children of current node</li><li>Return the root</li></ol><p><strong>Time Complexity:</strong> O(n) - visit each node once</p><p><strong>Space Complexity:</strong> O(h) - recursion stack depth where h is tree height</p>",
      "solution_code": "def invertBinaryTree(root):\n    if not root:\n        return None\n    \n    # Recursively invert left and right subtrees\n    left = invertBinaryTree(root.left)\n    right = invertBinaryTree(root.right)\n    \n    # Swap left and right children\n    root.left = right\n    root.right = left\n    \n    return root"
    },
    "javascript": {
      "template": "function invertBinaryTree(root) {\n  \n}",
      "solution_text": "<p><strong>Binary Tree Inversion Algorithm:</strong></p><p>Recursively swap left and right children of every node in the tree.</p><p><strong>Algorithm:</strong></p><ol><li>If root is null, return null (base case)</li><li>Recursively invert left and right subtrees</li><li>Swap the left and right children of current node</li><li>Return the root</li></ol><p><strong>Time Complexity:</strong> O(n) - visit each node once</p><p><strong>Space Complexity:</strong> O(h) - recursion stack depth where h is tree height</p>",
      "solution_code": "function invertBinaryTree(root) {\n    if (!root) {\n        return null;\n    }\n    \n    // Recursively invert left and right subtrees\n    const left = invertBinaryTree(root.left);\n    const right = invertBinaryTree(root.right);\n    \n    // Swap left and right children\n    root.left = right;\n    root.right = left;\n    \n    return root;\n}"
    },
    "typescript": {
      "template": "function invertBinaryTree(root: TreeNode | null): TreeNode | null {\n  \n}",
      "solution_text": "<p><strong>Binary Tree Inversion Algorithm:</strong></p><p>Recursively swap left and right children of every node in the tree.</p><p><strong>Algorithm:</strong></p><ol><li>If root is null, return null (base case)</li><li>Recursively invert left and right subtrees</li><li>Swap the left and right children of current node</li><li>Return the root</li></ol><p><strong>Time Complexity:</strong> O(n) - visit each node once</p><p><strong>Space Complexity:</strong> O(h) - recursion stack depth where h is tree height</p>",
      "solution_code": "function invertBinaryTree(root: TreeNode | null): TreeNode | null {\n    if (!root) {\n        return null;\n    }\n    \n    // Recursively invert left and right subtrees\n    const left: TreeNode | null = invertBinaryTree(root.left);\n    const right: TreeNode | null = invertBinaryTree(root.right);\n    \n    // Swap left and right children\n    root.left = right;\n    root.right = left;\n    \n    return root;\n}"
    },
    "java": {
      "template": "class Solution {\n    public TreeNode invertBinaryTree(TreeNode root) {\n        \n    }\n}",
      "solution_text": "<p><strong>Binary Tree Inversion Algorithm:</strong></p><p>Recursively swap left and right children of every node in the tree.</p><p><strong>Algorithm:</strong></p><ol><li>If root is null, return null (base case)</li><li>Recursively invert left and right subtrees</li><li>Swap the left and right children of current node</li><li>Return the root</li></ol><p><strong>Time Complexity:</strong> O(n) - visit each node once</p><p><strong>Space Complexity:</strong> O(h) - recursion stack depth where h is tree height</p>",
      "solution_code": "class Solution {\n    public TreeNode invertBinaryTree(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        \n        // Recursively invert left and right subtrees\n        TreeNode left = invertBinaryTree(root.left);\n        TreeNode right = invertBinaryTree(root.right);\n        \n        // Swap left and right children\n        root.left = right;\n        root.right = left;\n        \n        return root;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "root": [4, 2, 7, 1, 3, 6, 9]
      },
      "output": [4, 7, 2, 9, 6, 3, 1]
    },
    {
      "id": 2,
      "input": {
        "root": [2, 1, 3]
      },
      "output": [2, 3, 1]
    },
    {
      "id": 3,
      "input": {
        "root": []
      },
      "output": []
    },
    {
      "id": 4,
      "input": {
        "root": [1]
      },
      "output": [1]
    },
    {
      "id": 5,
      "input": {
        "root": [1, 2]
      },
      "output": [1, null, 2]
    },
    {
      "id": 6,
      "input": {
        "root": [1, null, 2]
      },
      "output": [1, 2]
    },
    {
      "id": 7,
      "input": {
        "root": [5, 3, 8, 2, 4, 7, 10]
      },
      "output": [5, 8, 3, 10, 7, 4, 2]
    },
    {
      "id": 8,
      "input": {
        "root": [1, 2, 3, 4, 5, 6, 7]
      },
      "output": [1, 3, 2, 7, 6, 5, 4]
    },
    {
      "id": 9,
      "input": {
        "root": [10, 5, 15, null, 7, 12, 20]
      },
      "output": [10, 15, 5, 20, 12, 7]
    },
    {
      "id": 10,
      "input": {
        "root": [3, 9, 20, null, null, 15, 7]
      },
      "output": [3, 20, 9, 7, 15]
    }
  ]
}