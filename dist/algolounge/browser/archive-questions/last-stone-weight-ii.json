{
  "filename": "last-stone-weight-ii",
  "title": "Last Stone Weight II",
  "keywords": [
    "last",
    "stone",
    "weight",
    "leetcode",
    "1049",
    "given",
    "array",
    "integers",
    "stones",
    "where"
  ],
  "description": "<h2>Last Stone Weight II</h2><p>You are given an array of integers <code>stones</code> where <code>stones[i]</code> is the weight of the <code>ith</code> stone.</p><p>We are playing a game with the stones. On each turn, we choose any two stones and smash them together. Suppose the stones have weights <code>x</code> and <code>y</code> with <code>x <= y</code>. The result of this smash is:</p><ul><li>If <code>x == y</code>, both stones are destroyed</li><li>If <code>x != y</code>, the stone of weight <code>x</code> is destroyed, and the stone of weight <code>y</code> has new weight <code>y - x</code></li></ul><p>At the end of the game, there is <strong>at most one</strong> stone left.</p><p>Return the <strong>smallest possible weight</strong> of the left stone. If there are no stones left, return <code>0</code>.</p><h3>Examples</h3><ul><li><strong>Input:</strong> stones = [2,4,1,5,6,3]<br><strong>Output:</strong> 1<br><strong>Explanation:</strong><br>1. We smash 2 and 1 which makes the array [1,4,5,6,3]<br>2. We smash 4 and 3 which makes the array [1,1,5,6]<br>3. We smash 5 and 6 which makes the array [1,1,1]<br>4. We smash 1 and 1 which makes the array [1]</li><li><strong>Input:</strong> stones = [4,4,1,7,10]<br><strong>Output:</strong> 2</li></ul><h3>Constraints</h3><ul><li><code>1 <= stones.length <= 30</code></li><li><code>1 <= stones[i] <= 100</code></li></ul>",
  "languages": {
    "python": {
      "template": "def lastStoneWeightII(stones):\n    ",
      "solution_text": "**Dynamic Programming Approach:**\n\nThis problem can be transformed into finding two groups of stones where the difference between their sums is minimized. The key insight is that we want to partition the stones into two groups such that their weight difference is minimal.\n\n**Algorithm:**\n1. Calculate the total sum of all stones\n2. Use dynamic programming to find all possible subset sums up to sum//2\n3. Find the largest possible sum for one group that doesn't exceed sum//2\n4. The minimum weight is sum - 2 * largest_subset_sum\n\n**Time Complexity:** O(n * sum) where n is number of stones and sum is total weight\n**Space Complexity:** O(sum) for the DP array\n\n**Key Insight:** This is equivalent to the 0/1 knapsack problem where we want to find the subset closest to half the total sum.",
      "solution_code": "def lastStoneWeightII(stones):\n    total_sum = sum(stones)\n    target = total_sum // 2\n    \n    # DP array to track possible sums\n    dp = [False] * (target + 1)\n    dp[0] = True  # Sum of 0 is always possible\n    \n    for stone in stones:\n        # Traverse backwards to avoid using the same stone twice\n        for j in range(target, stone - 1, -1):\n            dp[j] = dp[j] or dp[j - stone]\n    \n    # Find the largest sum <= target that is achievable\n    for i in range(target, -1, -1):\n        if dp[i]:\n            return total_sum - 2 * i\n    \n    return 0"
    },
    "javascript": {
      "template": "function lastStoneWeightII(stones) {\n  \n}",
      "solution_text": "**Dynamic Programming Approach:**\n\nThis problem can be transformed into finding two groups of stones where the difference between their sums is minimized. The key insight is that we want to partition the stones into two groups such that their weight difference is minimal.\n\n**Algorithm:**\n1. Calculate the total sum of all stones\n2. Use dynamic programming to find all possible subset sums up to sum//2\n3. Find the largest possible sum for one group that doesn't exceed sum//2\n4. The minimum weight is sum - 2 * largest_subset_sum\n\n**Time Complexity:** O(n * sum) where n is number of stones and sum is total weight\n**Space Complexity:** O(sum) for the DP array\n\n**Key Insight:** This is equivalent to the 0/1 knapsack problem where we want to find the subset closest to half the total sum.",
      "solution_code": "function lastStoneWeightII(stones) {\n    const totalSum = stones.reduce((sum, stone) => sum + stone, 0);\n    const target = Math.floor(totalSum / 2);\n    \n    // DP array to track possible sums\n    const dp = new Array(target + 1).fill(false);\n    dp[0] = true; // Sum of 0 is always possible\n    \n    for (const stone of stones) {\n        // Traverse backwards to avoid using the same stone twice\n        for (let j = target; j >= stone; j--) {\n            dp[j] = dp[j] || dp[j - stone];\n        }\n    }\n    \n    // Find the largest sum <= target that is achievable\n    for (let i = target; i >= 0; i--) {\n        if (dp[i]) {\n            return totalSum - 2 * i;\n        }\n    }\n    \n    return 0;\n}"
    },
    "typescript": {
      "template": "function lastStoneWeightII(stones: number[]): number {\n  \n}",
      "solution_text": "**Dynamic Programming Approach:**\n\nThis problem can be transformed into finding two groups of stones where the difference between their sums is minimized. The key insight is that we want to partition the stones into two groups such that their weight difference is minimal.\n\n**Algorithm:**\n1. Calculate the total sum of all stones\n2. Use dynamic programming to find all possible subset sums up to sum//2\n3. Find the largest possible sum for one group that doesn't exceed sum//2\n4. The minimum weight is sum - 2 * largest_subset_sum\n\n**Time Complexity:** O(n * sum) where n is number of stones and sum is total weight\n**Space Complexity:** O(sum) for the DP array\n\n**Key Insight:** This is equivalent to the 0/1 knapsack problem where we want to find the subset closest to half the total sum.",
      "solution_code": "function lastStoneWeightII(stones: number[]): number {\n    const totalSum: number = stones.reduce((sum, stone) => sum + stone, 0);\n    const target: number = Math.floor(totalSum / 2);\n    \n    // DP array to track possible sums\n    const dp: boolean[] = new Array(target + 1).fill(false);\n    dp[0] = true; // Sum of 0 is always possible\n    \n    for (const stone of stones) {\n        // Traverse backwards to avoid using the same stone twice\n        for (let j = target; j >= stone; j--) {\n            dp[j] = dp[j] || dp[j - stone];\n        }\n    }\n    \n    // Find the largest sum <= target that is achievable\n    for (let i = target; i >= 0; i--) {\n        if (dp[i]) {\n            return totalSum - 2 * i;\n        }\n    }\n    \n    return 0;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int lastStoneWeightII(int[] stones) {\n        \n    }\n}",
      "solution_text": "**Dynamic Programming Approach:**\n\nThis problem can be transformed into finding two groups of stones where the difference between their sums is minimized. The key insight is that we want to partition the stones into two groups such that their weight difference is minimal.\n\n**Algorithm:**\n1. Calculate the total sum of all stones\n2. Use dynamic programming to find all possible subset sums up to sum//2\n3. Find the largest possible sum for one group that doesn't exceed sum//2\n4. The minimum weight is sum - 2 * largest_subset_sum\n\n**Time Complexity:** O(n * sum) where n is number of stones and sum is total weight\n**Space Complexity:** O(sum) for the DP array\n\n**Key Insight:** This is equivalent to the 0/1 knapsack problem where we want to find the subset closest to half the total sum.",
      "solution_code": "class Solution {\n    public int lastStoneWeightII(int[] stones) {\n        int totalSum = 0;\n        for (int stone : stones) {\n            totalSum += stone;\n        }\n        \n        int target = totalSum / 2;\n        \n        // DP array to track possible sums\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true; // Sum of 0 is always possible\n        \n        for (int stone : stones) {\n            // Traverse backwards to avoid using the same stone twice\n            for (int j = target; j >= stone; j--) {\n                dp[j] = dp[j] || dp[j - stone];\n            }\n        }\n        \n        // Find the largest sum <= target that is achievable\n        for (int i = target; i >= 0; i--) {\n            if (dp[i]) {\n                return totalSum - 2 * i;\n            }\n        }\n        \n        return 0;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "stones": [2, 4, 1, 5, 6, 3]
      },
      "output": 1
    },
    {
      "id": 2,
      "input": {
        "stones": [4, 4, 1, 7, 10]
      },
      "output": 2
    },
    {
      "id": 3,
      "input": {
        "stones": [31, 26, 33, 21, 40]
      },
      "output": 5
    },
    {
      "id": 4,
      "input": {
        "stones": [1]
      },
      "output": 1
    },
    {
      "id": 5,
      "input": {
        "stones": [2, 2]
      },
      "output": 0
    },
    {
      "id": 6,
      "input": {
        "stones": [1, 3, 5]
      },
      "output": 1
    },
    {
      "id": 7,
      "input": {
        "stones": [100, 1, 1, 1]
      },
      "output": 97
    },
    {
      "id": 8,
      "input": {
        "stones": [10, 20, 30, 40, 50]
      },
      "output": 10
    },
    {
      "id": 9,
      "input": {
        "stones": [5, 10, 15]
      },
      "output": 0
    },
    {
      "id": 10,
      "input": {
        "stones": [7, 11, 3, 1, 2]
      },
      "output": 0
    },
    {
      "id": 11,
      "input": {
        "stones": [50, 50]
      },
      "output": 0
    },
    {
      "id": 12,
      "input": {
        "stones": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      },
      "output": 1
    }
  ]
}