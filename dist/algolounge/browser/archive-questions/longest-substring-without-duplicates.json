{
  "filename": "longest-substring-without-duplicates",
  "title": "Longest Substring Without Repeating Characters",
  "keywords": [
    "longest",
    "substring",
    "without",
    "repeating",
    "characters",
    "leetcode",
    "given",
    "string",
    "find",
    "length"
  ],
  "description": "<h2>Longest Substring Without Repeating Characters</h2><p>Given a string <code>s</code>, find the length of the longest substring without duplicate characters.</p><p>A substring is a contiguous sequence of characters within a string.</p><h3>Examples</h3><ul><li><strong>Input:</strong> <code>s = \"abcabcbb\"</code><br><strong>Output:</strong> <code>3</code><br><strong>Explanation:</strong> The answer is \"abc\", with the length of 3.</li><li><strong>Input:</strong> <code>s = \"bbbbb\"</code><br><strong>Output:</strong> <code>1</code><br><strong>Explanation:</strong> The answer is \"b\", with the length of 1.</li><li><strong>Input:</strong> <code>s = \"pwwkew\"</code><br><strong>Output:</strong> <code>3</code><br><strong>Explanation:</strong> The answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring.</li></ul><h3>Constraints</h3><ul><li><code>0 <= s.length <= 5 * 10^4</code></li><li><code>s</code> consists of English letters, digits, symbols and spaces.</li></ul>",
  "languages": {
    "python": {
      "template": "def lengthOfLongestSubstring(s):\n    ",
      "solution_text": "**Algorithm: Sliding Window with Hash Map**\n\nWe use the sliding window technique with two pointers (left and right) and a hash map to track character positions.\n\n**Steps:**\n1. Use a hash map to store the most recent index of each character\n2. Expand the right pointer to include new characters\n3. When a duplicate is found, move the left pointer to skip the duplicate\n4. Keep track of the maximum window size seen so far\n\n**Time Complexity:** O(n) - we visit each character at most twice\n**Space Complexity:** O(min(m,n)) - where m is the character set size\n\n**Key Insights:**\n- Sliding window avoids recalculating from scratch\n- Hash map provides O(1) lookup for character positions\n- Handle edge cases like empty strings gracefully",
      "solution_code": "def lengthOfLongestSubstring(s):\n    if not s:\n        return 0\n    \n    char_map = {}\n    left = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        # If character is seen and is within current window\n        if s[right] in char_map and char_map[s[right]] >= left:\n            # Move left pointer to skip the duplicate\n            left = char_map[s[right]] + 1\n        \n        # Update character's latest position\n        char_map[s[right]] = right\n        \n        # Update max length if current window is larger\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length"
    },
    "javascript": {
      "template": "function lengthOfLongestSubstring(s) {\n  \n}",
      "solution_text": "**Algorithm: Sliding Window with Map**\n\nWe use the sliding window technique with two pointers (left and right) and a Map to track character positions.\n\n**Steps:**\n1. Use a Map to store the most recent index of each character\n2. Expand the right pointer to include new characters\n3. When a duplicate is found, move the left pointer to skip the duplicate\n4. Keep track of the maximum window size seen so far\n\n**Time Complexity:** O(n) - we visit each character at most twice\n**Space Complexity:** O(min(m,n)) - where m is the character set size\n\n**Key Insights:**\n- Sliding window avoids recalculating from scratch\n- Map provides O(1) lookup for character positions\n- Handle edge cases like empty strings gracefully",
      "solution_code": "function lengthOfLongestSubstring(s) {\n    if (!s || s.length === 0) {\n        return 0;\n    }\n    \n    const charMap = new Map();\n    let left = 0;\n    let maxLength = 0;\n    \n    for (let right = 0; right < s.length; right++) {\n        // If character is seen and is within current window\n        if (charMap.has(s[right]) && charMap.get(s[right]) >= left) {\n            // Move left pointer to skip the duplicate\n            left = charMap.get(s[right]) + 1;\n        }\n        \n        // Update character's latest position\n        charMap.set(s[right], right);\n        \n        // Update max length if current window is larger\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n    \n    return maxLength;\n}"
    },
    "typescript": {
      "template": "function lengthOfLongestSubstring(s: string): number {\n  \n}",
      "solution_text": "**Algorithm: Sliding Window with Map**\n\nWe use the sliding window technique with two pointers (left and right) and a Map to track character positions.\n\n**Steps:**\n1. Use a Map to store the most recent index of each character\n2. Expand the right pointer to include new characters\n3. When a duplicate is found, move the left pointer to skip the duplicate\n4. Keep track of the maximum window size seen so far\n\n**Time Complexity:** O(n) - we visit each character at most twice\n**Space Complexity:** O(min(m,n)) - where m is the character set size\n\n**Key Insights:**\n- Sliding window avoids recalculating from scratch\n- Map provides O(1) lookup for character positions\n- Handle edge cases like empty strings gracefully",
      "solution_code": "function lengthOfLongestSubstring(s: string): number {\n    if (!s || s.length === 0) {\n        return 0;\n    }\n    \n    const charMap = new Map<string, number>();\n    let left = 0;\n    let maxLength = 0;\n    \n    for (let right = 0; right < s.length; right++) {\n        // If character is seen and is within current window\n        if (charMap.has(s[right]) && charMap.get(s[right])! >= left) {\n            // Move left pointer to skip the duplicate\n            left = charMap.get(s[right])! + 1;\n        }\n        \n        // Update character's latest position\n        charMap.set(s[right], right);\n        \n        // Update max length if current window is larger\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n    \n    return maxLength;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        \n    }\n}",
      "solution_text": "**Algorithm: Sliding Window with HashMap**\n\nWe use the sliding window technique with two pointers (left and right) and a HashMap to track character positions.\n\n**Steps:**\n1. Use a HashMap to store the most recent index of each character\n2. Expand the right pointer to include new characters\n3. When a duplicate is found, move the left pointer to skip the duplicate\n4. Keep track of the maximum window size seen so far\n\n**Time Complexity:** O(n) - we visit each character at most twice\n**Space Complexity:** O(min(m,n)) - where m is the character set size\n\n**Key Insights:**\n- Sliding window avoids recalculating from scratch\n- HashMap provides O(1) lookup for character positions\n- Handle edge cases like empty strings gracefully",
      "solution_code": "import java.util.HashMap;\n\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if (s == null || s.length() == 0) {\n            return 0;\n        }\n        \n        HashMap<Character, Integer> charMap = new HashMap<>();\n        int left = 0;\n        int maxLength = 0;\n        \n        for (int right = 0; right < s.length(); right++) {\n            char currentChar = s.charAt(right);\n            \n            // If character is seen and is within current window\n            if (charMap.containsKey(currentChar) && charMap.get(currentChar) >= left) {\n                // Move left pointer to skip the duplicate\n                left = charMap.get(currentChar) + 1;\n            }\n            \n            // Update character's latest position\n            charMap.put(currentChar, right);\n            \n            // Update max length if current window is larger\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n        \n        return maxLength;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "s": "abcabcbb"
      },
      "output": 3
    },
    {
      "id": 2,
      "input": {
        "s": "bbbbb"
      },
      "output": 1
    },
    {
      "id": 3,
      "input": {
        "s": "pwwkew"
      },
      "output": 3
    },
    {
      "id": 4,
      "input": {
        "s": ""
      },
      "output": 0
    },
    {
      "id": 5,
      "input": {
        "s": "a"
      },
      "output": 1
    },
    {
      "id": 6,
      "input": {
        "s": "au"
      },
      "output": 2
    },
    {
      "id": 7,
      "input": {
        "s": "dvdf"
      },
      "output": 3
    },
    {
      "id": 8,
      "input": {
        "s": "anviaj"
      },
      "output": 5
    },
    {
      "id": 9,
      "input": {
        "s": "abba"
      },
      "output": 2
    },
    {
      "id": 10,
      "input": {
        "s": "tmmzuxt"
      },
      "output": 5
    },
    {
      "id": 11,
      "input": {
        "s": "abcdef"
      },
      "output": 6
    },
    {
      "id": 12,
      "input": {
        "s": " "
      },
      "output": 1
    },
    {
      "id": 13,
      "input": {
        "s": "abcabcdefg"
      },
      "output": 7
    },
    {
      "id": 14,
      "input": {
        "s": "aabaab!bb"
      },
      "output": 3
    }
  ]
}