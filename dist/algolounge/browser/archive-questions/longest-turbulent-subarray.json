{
  "filename": "longest-turbulent-subarray",
  "title": "Longest Turbulent Subarray",
  "keywords": [
    "longest",
    "turbulent",
    "subarray",
    "leetcode",
    "978",
    "given",
    "integer",
    "array",
    "arr",
    "return"
  ],
  "description": "<h2>Longest Turbulent Subarray</h2><p>Leetcode 978. Longest Turbulent Subarray</p><p>You are given an integer array <code>arr</code>, return the length of a maximum size turbulent subarray of <code>arr</code>.</p><p>A subarray is <strong>turbulent</strong> if the comparison sign flips between each adjacent pair of elements in the subarray.</p><p>More formally, a subarray <code>[arr[i], arr[i + 1], ..., arr[j]]</code> of <code>arr</code> is said to be turbulent if and only if:</p><ul><li>For <code>i <= k < j</code>:<ul><li><code>arr[k] > arr[k + 1]</code> when <code>k</code> is odd, and</li><li><code>arr[k] < arr[k + 1]</code> when <code>k</code> is even.</li></ul></li><li>Or, for <code>i <= k < j</code>:<ul><li><code>arr[k] > arr[k + 1]</code> when <code>k</code> is even, and</li><li><code>arr[k] < arr[k + 1]</code> when <code>k</code> is odd.</li></ul></li></ul><h3>Examples</h3><ul><li><strong>Input:</strong> <code>arr = [9,4,2,10,7,8,8,1,9]</code><br><strong>Output:</strong> <code>5</code><br><strong>Explanation:</strong> The turbulent subarray <code>[4,2,10,7,8]</code> has length 5.</li><li><strong>Input:</strong> <code>arr = [4,8,12,16]</code><br><strong>Output:</strong> <code>2</code><br><strong>Explanation:</strong> No turbulent subarray longer than 2.</li><li><strong>Input:</strong> <code>arr = [100]</code><br><strong>Output:</strong> <code>1</code></li></ul><h3>Constraints</h3><ul><li><code>1 <= arr.length <= 40,000</code></li><li><code>0 <= arr[i] <= 1,000,000,000</code></li></ul>",
  "languages": {
    "python": {
      "template": "def longestTurbulentSubarray(arr):\n    ",
      "solution_text": "**Algorithm: Two-Pointer Approach**\n\nWe use a two-pointer approach to track the length of turbulent subarrays. The key insight is that a turbulent subarray alternates between increasing and decreasing comparisons.\n\n**Approach:**\n1. Use two variables to track lengths: `inc` (ending with increasing) and `dec` (ending with decreasing)\n2. For each adjacent pair, update the counters based on the comparison\n3. Keep track of the maximum length seen so far\n\n**Time Complexity:** O(n) - single pass through the array\n**Space Complexity:** O(1) - only using constant extra space\n\n**Key Insights:**\n- A turbulent subarray must have alternating > and < comparisons\n- We can track both increasing and decreasing endings simultaneously\n- Handle edge cases: single element (length 1), equal elements break turbulence",
      "solution_code": "def longestTurbulentSubarray(arr):\n    if len(arr) <= 1:\n        return len(arr)\n    \n    # inc: length of turbulent subarray ending with arr[i-1] < arr[i]\n    # dec: length of turbulent subarray ending with arr[i-1] > arr[i]\n    inc = dec = 1\n    max_length = 1\n    \n    for i in range(1, len(arr)):\n        if arr[i - 1] < arr[i]:\n            # Current comparison is increasing\n            inc = dec + 1  # Extend decreasing sequence\n            dec = 1        # Reset decreasing counter\n        elif arr[i - 1] > arr[i]:\n            # Current comparison is decreasing\n            dec = inc + 1  # Extend increasing sequence\n            inc = 1        # Reset increasing counter\n        else:\n            # Elements are equal, reset both counters\n            inc = dec = 1\n        \n        max_length = max(max_length, max(inc, dec))\n    \n    return max_length"
    },
    "javascript": {
      "template": "function longestTurbulentSubarray(arr) {\n  \n}",
      "solution_text": "**Algorithm: Two-Pointer Approach**\n\nWe use a two-pointer approach to track the length of turbulent subarrays. The key insight is that a turbulent subarray alternates between increasing and decreasing comparisons.\n\n**Approach:**\n1. Use two variables to track lengths: `inc` (ending with increasing) and `dec` (ending with decreasing)\n2. For each adjacent pair, update the counters based on the comparison\n3. Keep track of the maximum length seen so far\n\n**Time Complexity:** O(n) - single pass through the array\n**Space Complexity:** O(1) - only using constant extra space\n\n**Key Insights:**\n- A turbulent subarray must have alternating > and < comparisons\n- We can track both increasing and decreasing endings simultaneously\n- Handle edge cases: single element (length 1), equal elements break turbulence",
      "solution_code": "function longestTurbulentSubarray(arr) {\n    if (arr.length <= 1) {\n        return arr.length;\n    }\n    \n    // inc: length of turbulent subarray ending with arr[i-1] < arr[i]\n    // dec: length of turbulent subarray ending with arr[i-1] > arr[i]\n    let inc = 1, dec = 1;\n    let maxLength = 1;\n    \n    for (let i = 1; i < arr.length; i++) {\n        if (arr[i - 1] < arr[i]) {\n            // Current comparison is increasing\n            inc = dec + 1;  // Extend decreasing sequence\n            dec = 1;        // Reset decreasing counter\n        } else if (arr[i - 1] > arr[i]) {\n            // Current comparison is decreasing\n            dec = inc + 1;  // Extend increasing sequence\n            inc = 1;        // Reset increasing counter\n        } else {\n            // Elements are equal, reset both counters\n            inc = dec = 1;\n        }\n        \n        maxLength = Math.max(maxLength, Math.max(inc, dec));\n    }\n    \n    return maxLength;\n}"
    },
    "typescript": {
      "template": "function longestTurbulentSubarray(arr: number[]): number {\n  \n}",
      "solution_text": "**Algorithm: Two-Pointer Approach**\n\nWe use a two-pointer approach to track the length of turbulent subarrays. The key insight is that a turbulent subarray alternates between increasing and decreasing comparisons.\n\n**Approach:**\n1. Use two variables to track lengths: `inc` (ending with increasing) and `dec` (ending with decreasing)\n2. For each adjacent pair, update the counters based on the comparison\n3. Keep track of the maximum length seen so far\n\n**Time Complexity:** O(n) - single pass through the array\n**Space Complexity:** O(1) - only using constant extra space\n\n**Key Insights:**\n- A turbulent subarray must have alternating > and < comparisons\n- We can track both increasing and decreasing endings simultaneously\n- Handle edge cases: single element (length 1), equal elements break turbulence",
      "solution_code": "function longestTurbulentSubarray(arr: number[]): number {\n    if (arr.length <= 1) {\n        return arr.length;\n    }\n    \n    // inc: length of turbulent subarray ending with arr[i-1] < arr[i]\n    // dec: length of turbulent subarray ending with arr[i-1] > arr[i]\n    let inc: number = 1, dec: number = 1;\n    let maxLength: number = 1;\n    \n    for (let i = 1; i < arr.length; i++) {\n        if (arr[i - 1] < arr[i]) {\n            // Current comparison is increasing\n            inc = dec + 1;  // Extend decreasing sequence\n            dec = 1;        // Reset decreasing counter\n        } else if (arr[i - 1] > arr[i]) {\n            // Current comparison is decreasing\n            dec = inc + 1;  // Extend increasing sequence\n            inc = 1;        // Reset increasing counter\n        } else {\n            // Elements are equal, reset both counters\n            inc = dec = 1;\n        }\n        \n        maxLength = Math.max(maxLength, Math.max(inc, dec));\n    }\n    \n    return maxLength;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int longestTurbulentSubarray(int[] arr) {\n        \n    }\n}",
      "solution_text": "**Algorithm: Two-Pointer Approach**\n\nWe use a two-pointer approach to track the length of turbulent subarrays. The key insight is that a turbulent subarray alternates between increasing and decreasing comparisons.\n\n**Approach:**\n1. Use two variables to track lengths: `inc` (ending with increasing) and `dec` (ending with decreasing)\n2. For each adjacent pair, update the counters based on the comparison\n3. Keep track of the maximum length seen so far\n\n**Time Complexity:** O(n) - single pass through the array\n**Space Complexity:** O(1) - only using constant extra space\n\n**Key Insights:**\n- A turbulent subarray must have alternating > and < comparisons\n- We can track both increasing and decreasing endings simultaneously\n- Handle edge cases: single element (length 1), equal elements break turbulence",
      "solution_code": "class Solution {\n    public int longestTurbulentSubarray(int[] arr) {\n        if (arr.length <= 1) {\n            return arr.length;\n        }\n        \n        // inc: length of turbulent subarray ending with arr[i-1] < arr[i]\n        // dec: length of turbulent subarray ending with arr[i-1] > arr[i]\n        int inc = 1, dec = 1;\n        int maxLength = 1;\n        \n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i - 1] < arr[i]) {\n                // Current comparison is increasing\n                inc = dec + 1;  // Extend decreasing sequence\n                dec = 1;        // Reset decreasing counter\n            } else if (arr[i - 1] > arr[i]) {\n                // Current comparison is decreasing\n                dec = inc + 1;  // Extend increasing sequence\n                inc = 1;        // Reset increasing counter\n            } else {\n                // Elements are equal, reset both counters\n                inc = dec = 1;\n            }\n            \n            maxLength = Math.max(maxLength, Math.max(inc, dec));\n        }\n        \n        return maxLength;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "arr": [9, 4, 2, 10, 7, 8, 8, 1, 9]
      },
      "output": 5
    },
    {
      "id": 2,
      "input": {
        "arr": [4, 8, 12, 16]
      },
      "output": 2
    },
    {
      "id": 3,
      "input": {
        "arr": [100]
      },
      "output": 1
    },
    {
      "id": 4,
      "input": {
        "arr": [1, 2, 1, 0, 1, 2, 1]
      },
      "output": 7
    },
    {
      "id": 5,
      "input": {
        "arr": [1, 1, 1, 1, 1]
      },
      "output": 1
    },
    {
      "id": 6,
      "input": {
        "arr": [1, 2]
      },
      "output": 2
    },
    {
      "id": 7,
      "input": {
        "arr": [2, 1]
      },
      "output": 2
    },
    {
      "id": 8,
      "input": {
        "arr": [1, 3, 2, 4, 1, 5, 0, 6]
      },
      "output": 8
    },
    {
      "id": 9,
      "input": {
        "arr": [5, 5, 7, 6, 8, 7, 9, 8]
      },
      "output": 6
    },
    {
      "id": 10,
      "input": {
        "arr": [0, 1, 0, 1, 0, 1, 0]
      },
      "output": 7
    },
    {
      "id": 11,
      "input": {
        "arr": [10, 5, 15, 3, 20, 1]
      },
      "output": 6
    },
    {
      "id": 12,
      "input": {
        "arr": [100, 200, 100, 200]
      },
      "output": 4
    }
  ]
}