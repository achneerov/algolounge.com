{
  "filename": "lowest-common-ancestor-in-binary-search-tree",
  "title": "Lowest Common Ancestor in Binary Search Tree",
  "keywords": [
    "lowest",
    "common",
    "ancestor",
    "binary",
    "search",
    "tree",
    "leetcode",
    "235",
    "given",
    "bst"
  ],
  "description": "<h2>Lowest Common Ancestor in Binary Search Tree</h2><p>LeetCode 235. Lowest Common Ancestor of a Binary Search Tree</p><p>Given a binary search tree (BST) where all node values are unique, and two nodes from the tree <code>p</code> and <code>q</code>, return the lowest common ancestor (LCA) of the two nodes.</p><p>The lowest common ancestor between two nodes <code>p</code> and <code>q</code> is the lowest node in a tree <code>T</code> such that both <code>p</code> and <code>q</code> are descendants. The ancestor is allowed to be a descendant of itself.</p><h3>Examples</h3><ul><li><strong>Example 1:</strong><br>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>Output: 6<br>Explanation: The LCA of nodes 2 and 8 is 6.</li><li><strong>Example 2:</strong><br>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>Output: 2<br>Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself.</li><li><strong>Example 3:</strong><br>Input: root = [2,1], p = 2, q = 1<br>Output: 2</li></ul><h3>Constraints</h3><ul><li>2 ≤ The number of nodes in the tree ≤ 100</li><li>-100 ≤ Node.val ≤ 100</li><li><code>p</code> ≠ <code>q</code></li><li><code>p</code> and <code>q</code> will both exist in the BST</li></ul>",
  "languages": {
    "python": {
      "template": "# Definition for a binary tree node\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef lowestCommonAncestorInBinarySearchTree(root, p, q):\n    ",
      "solution_text": "BST Property-based LCA Solution:\n\n**Algorithm:**\n1. Start from root node\n2. If both p and q values are less than current node, LCA is in left subtree\n3. If both p and q values are greater than current node, LCA is in right subtree\n4. Otherwise, current node is the LCA (values are on different sides)\n\n**Time Complexity:** O(h) where h is height of tree - O(log n) for balanced BST\n**Space Complexity:** O(1) - iterative approach uses constant space\n\n**Key Insights:**\n- Leverages BST property: left < root < right\n- No need to search both subtrees like in general binary tree\n- First node where paths diverge is the LCA",
      "solution_code": "def lowestCommonAncestorInBinarySearchTree(root, p, q):\n    current = root\n    \n    while current:\n        # If both p and q are smaller than current, go left\n        if p.val < current.val and q.val < current.val:\n            current = current.left\n        # If both p and q are larger than current, go right\n        elif p.val > current.val and q.val > current.val:\n            current = current.right\n        # If p and q are on different sides or one equals current\n        else:\n            return current\n    \n    return None"
    },
    "javascript": {
      "template": "// Definition for a binary tree node\nfunction TreeNode(val, left, right) {\n    this.val = (val === undefined ? 0 : val);\n    this.left = (left === undefined ? null : left);\n    this.right = (right === undefined ? null : right);\n}\n\nfunction lowestCommonAncestorInBinarySearchTree(root, p, q) {\n  \n}",
      "solution_text": "BST Property-based LCA Solution:\n\n**Algorithm:**\n1. Start from root node\n2. If both p and q values are less than current node, LCA is in left subtree\n3. If both p and q values are greater than current node, LCA is in right subtree\n4. Otherwise, current node is the LCA (values are on different sides)\n\n**Time Complexity:** O(h) where h is height of tree - O(log n) for balanced BST\n**Space Complexity:** O(1) - iterative approach uses constant space\n\n**Key Insights:**\n- Leverages BST property: left < root < right\n- No need to search both subtrees like in general binary tree\n- First node where paths diverge is the LCA",
      "solution_code": "function lowestCommonAncestorInBinarySearchTree(root, p, q) {\n    let current = root;\n    \n    while (current) {\n        // If both p and q are smaller than current, go left\n        if (p.val < current.val && q.val < current.val) {\n            current = current.left;\n        }\n        // If both p and q are larger than current, go right\n        else if (p.val > current.val && q.val > current.val) {\n            current = current.right;\n        }\n        // If p and q are on different sides or one equals current\n        else {\n            return current;\n        }\n    }\n    \n    return null;\n}"
    },
    "typescript": {
      "template": "// Definition for a binary tree node\nclass TreeNode {\n    val: number;\n    left: TreeNode | null;\n    right: TreeNode | null;\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = (val === undefined ? 0 : val);\n        this.left = (left === undefined ? null : left);\n        this.right = (right === undefined ? null : right);\n    }\n}\n\nfunction lowestCommonAncestorInBinarySearchTree(root: TreeNode | null, p: TreeNode, q: TreeNode): TreeNode | null {\n  \n}",
      "solution_text": "BST Property-based LCA Solution:\n\n**Algorithm:**\n1. Start from root node\n2. If both p and q values are less than current node, LCA is in left subtree\n3. If both p and q values are greater than current node, LCA is in right subtree\n4. Otherwise, current node is the LCA (values are on different sides)\n\n**Time Complexity:** O(h) where h is height of tree - O(log n) for balanced BST\n**Space Complexity:** O(1) - iterative approach uses constant space\n\n**Key Insights:**\n- Leverages BST property: left < root < right\n- No need to search both subtrees like in general binary tree\n- First node where paths diverge is the LCA",
      "solution_code": "function lowestCommonAncestorInBinarySearchTree(root: TreeNode | null, p: TreeNode, q: TreeNode): TreeNode | null {\n    let current: TreeNode | null = root;\n    \n    while (current) {\n        // If both p and q are smaller than current, go left\n        if (p.val < current.val && q.val < current.val) {\n            current = current.left;\n        }\n        // If both p and q are larger than current, go right\n        else if (p.val > current.val && q.val > current.val) {\n            current = current.right;\n        }\n        // If p and q are on different sides or one equals current\n        else {\n            return current;\n        }\n    }\n    \n    return null;\n}"
    },
    "java": {
      "template": "// Definition for a binary tree node\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\nclass Solution {\n    public TreeNode lowestCommonAncestorInBinarySearchTree(TreeNode root, TreeNode p, TreeNode q) {\n        \n    }\n}",
      "solution_text": "BST Property-based LCA Solution:\n\n**Algorithm:**\n1. Start from root node\n2. If both p and q values are less than current node, LCA is in left subtree\n3. If both p and q values are greater than current node, LCA is in right subtree\n4. Otherwise, current node is the LCA (values are on different sides)\n\n**Time Complexity:** O(h) where h is height of tree - O(log n) for balanced BST\n**Space Complexity:** O(1) - iterative approach uses constant space\n\n**Key Insights:**\n- Leverages BST property: left < root < right\n- No need to search both subtrees like in general binary tree\n- First node where paths diverge is the LCA",
      "solution_code": "class Solution {\n    public TreeNode lowestCommonAncestorInBinarySearchTree(TreeNode root, TreeNode p, TreeNode q) {\n        TreeNode current = root;\n        \n        while (current != null) {\n            // If both p and q are smaller than current, go left\n            if (p.val < current.val && q.val < current.val) {\n                current = current.left;\n            }\n            // If both p and q are larger than current, go right\n            else if (p.val > current.val && q.val > current.val) {\n                current = current.right;\n            }\n            // If p and q are on different sides or one equals current\n            else {\n                return current;\n            }\n        }\n        \n        return null;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "tree": [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5],
        "p_val": 2,
        "q_val": 8
      },
      "output": 6
    },
    {
      "id": 2,
      "input": {
        "tree": [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5],
        "p_val": 2,
        "q_val": 4
      },
      "output": 2
    },
    {
      "id": 3,
      "input": {
        "tree": [2, 1],
        "p_val": 2,
        "q_val": 1
      },
      "output": 2
    },
    {
      "id": 4,
      "input": {
        "tree": [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5],
        "p_val": 0,
        "q_val": 5
      },
      "output": 2
    },
    {
      "id": 5,
      "input": {
        "tree": [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5],
        "p_val": 7,
        "q_val": 9
      },
      "output": 8
    },
    {
      "id": 6,
      "input": {
        "tree": [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5],
        "p_val": 3,
        "q_val": 5
      },
      "output": 4
    },
    {
      "id": 7,
      "input": {
        "tree": [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5],
        "p_val": 6,
        "q_val": 8
      },
      "output": 6
    },
    {
      "id": 8,
      "input": {
        "tree": [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5],
        "p_val": 0,
        "q_val": 3
      },
      "output": 2
    },
    {
      "id": 9,
      "input": {
        "tree": [5, 3, 6, 2, 4, null, null, 1],
        "p_val": 1,
        "q_val": 4
      },
      "output": 3
    },
    {
      "id": 10,
      "input": {
        "tree": [10, 5, 15, 3, 7, 12, 20, 1, 4, 6, 8],
        "p_val": 1,
        "q_val": 8
      },
      "output": 5
    },
    {
      "id": 11,
      "input": {
        "tree": [10, 5, 15, 3, 7, 12, 20, 1, 4, 6, 8],
        "p_val": 12,
        "q_val": 20
      },
      "output": 15
    },
    {
      "id": 12,
      "input": {
        "tree": [4, 2, 6, 1, 3, 5, 7],
        "p_val": 1,
        "q_val": 7
      },
      "output": 4
    }
  ]
}