{
  "filename": "maximum-frequency-stack",
  "title": "Maximum Frequency Stack",
  "keywords": [
    "maximum",
    "frequency",
    "stack",
    "leetcode",
    "895",
    "design",
    "data",
    "structure",
    "hash",
    "map"
  ],
  "description": "<h2>Maximum Frequency Stack</h2><p>Leetcode 895. Maximum Frequency Stack</p><p>Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.</p><p>Implement the <code>FreqStack</code> class:</p><ul><li><code>FreqStack()</code> constructs an empty frequency stack.</li><li><code>void push(int val)</code> pushes an integer <code>val</code> onto the top of the stack.</li><li><code>int pop()</code> removes and returns the most frequent element in the stack.</li><li>If there is a <strong>tie</strong> for the <strong>most frequent element</strong>, the element closest to the stack's top is removed and returned.</li></ul><h3>Examples:</h3><ul><li><strong>Input:</strong> [\"FreqStack\", \"push\", \"push\", \"push\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"pop\"]<br>[[], [5], [7], [5], [7], [4], [5], [], [], [], []]<br><strong>Output:</strong> [null, null, null, null, null, null, null, 5, 7, 5, 4]<br><strong>Explanation:</strong><br>FreqStack freqStack = new FreqStack();<br>freqStack.push(5); // The stack is [5]<br>freqStack.push(7); // The stack is [5,7]<br>freqStack.push(5); // The stack is [5,7,5]<br>freqStack.push(7); // The stack is [5,7,5,7]<br>freqStack.push(4); // The stack is [5,7,5,7,4]<br>freqStack.push(5); // The stack is [5,7,5,7,4,5]<br>freqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].<br>freqStack.pop();   // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].<br>freqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,4].<br>freqStack.pop();   // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7].</li></ul><h3>Constraints:</h3><ul><li><code>0 <= val <= 10<sup>9</sup></code></li><li>At most <code>2 Ã— 10<sup>4</sup></code> calls will be made to <code>push</code> and <code>pop</code>.</li><li>It is guaranteed that there will be at least one element in the stack before calling <code>pop</code>.</li></ul>",
  "languages": {
    "python": {
      "template": "class FreqStack:\n\n    def __init__(self):\n        \n\n    def push(self, val: int) -> None:\n        \n\n    def pop(self) -> int:\n        ",
      "solution_text": "<h3>Hash Map + Stack of Stacks Solution</h3><p>Use frequency tracking with grouped stacks to efficiently find and remove most frequent elements.</p><h4>Algorithm:</h4><ol><li>Track frequency of each element with hash map</li><li>Maintain stacks grouped by frequency level</li><li>Push: increment frequency, add to appropriate frequency stack</li><li>Pop: remove from highest frequency stack, decrement frequency</li></ol><h4>Time Complexity:</h4><p>O(1) for both push and pop operations</p><h4>Space Complexity:</h4><p>O(n) for storing elements and frequency information</p><h4>Key Insights:</h4><ul><li>Separate stacks for each frequency level</li><li>Most recent element at given frequency is on top of its stack</li><li>Track maximum frequency to know which stack to pop from</li></ul>",
      "solution_code": "class FreqStack:\n\n    def __init__(self):\n        self.freq = {}  # element -> frequency\n        self.group = {}  # frequency -> stack of elements\n        self.max_freq = 0\n\n    def push(self, val: int) -> None:\n        # Update frequency\n        f = self.freq.get(val, 0) + 1\n        self.freq[val] = f\n        \n        # Update max frequency\n        if f > self.max_freq:\n            self.max_freq = f\n        \n        # Add to frequency group\n        if f not in self.group:\n            self.group[f] = []\n        self.group[f].append(val)\n\n    def pop(self) -> int:\n        # Pop from highest frequency group\n        val = self.group[self.max_freq].pop()\n        \n        # Update frequency\n        self.freq[val] -= 1\n        \n        # Update max frequency if needed\n        if not self.group[self.max_freq]:\n            self.max_freq -= 1\n        \n        return val"
    },
    "javascript": {
      "template": "class FreqStack {\n    constructor() {\n        \n    }\n    \n    push(val) {\n        \n    }\n    \n    pop() {\n        \n    }\n}",
      "solution_text": "<h3>Hash Map + Stack of Stacks Solution</h3><p>Use frequency tracking with grouped stacks to efficiently find and remove most frequent elements.</p><h4>Algorithm:</h4><ol><li>Track frequency of each element with hash map</li><li>Maintain stacks grouped by frequency level</li><li>Push: increment frequency, add to appropriate frequency stack</li><li>Pop: remove from highest frequency stack, decrement frequency</li></ol><h4>Time Complexity:</h4><p>O(1) for both push and pop operations</p><h4>Space Complexity:</h4><p>O(n) for storing elements and frequency information</p><h4>Key Insights:</h4><ul><li>Separate stacks for each frequency level</li><li>Most recent element at given frequency is on top of its stack</li><li>Track maximum frequency to know which stack to pop from</li></ul>",
      "solution_code": "class FreqStack {\n    constructor() {\n        this.freq = new Map(); // element -> frequency\n        this.group = new Map(); // frequency -> stack of elements\n        this.maxFreq = 0;\n    }\n    \n    push(val) {\n        // Update frequency\n        const f = (this.freq.get(val) || 0) + 1;\n        this.freq.set(val, f);\n        \n        // Update max frequency\n        if (f > this.maxFreq) {\n            this.maxFreq = f;\n        }\n        \n        // Add to frequency group\n        if (!this.group.has(f)) {\n            this.group.set(f, []);\n        }\n        this.group.get(f).push(val);\n    }\n    \n    pop() {\n        // Pop from highest frequency group\n        const val = this.group.get(this.maxFreq).pop();\n        \n        // Update frequency\n        this.freq.set(val, this.freq.get(val) - 1);\n        \n        // Update max frequency if needed\n        if (this.group.get(this.maxFreq).length === 0) {\n            this.maxFreq--;\n        }\n        \n        return val;\n    }\n}"
    },
    "typescript": {
      "template": "class FreqStack {\n    constructor() {\n        \n    }\n    \n    push(val: number): void {\n        \n    }\n    \n    pop(): number {\n        \n    }\n}",
      "solution_text": "<h3>Hash Map + Stack of Stacks Solution</h3><p>Use frequency tracking with grouped stacks to efficiently find and remove most frequent elements.</p><h4>Algorithm:</h4><ol><li>Track frequency of each element with hash map</li><li>Maintain stacks grouped by frequency level</li><li>Push: increment frequency, add to appropriate frequency stack</li><li>Pop: remove from highest frequency stack, decrement frequency</li></ol><h4>Time Complexity:</h4><p>O(1) for both push and pop operations</p><h4>Space Complexity:</h4><p>O(n) for storing elements and frequency information</p><h4>Key Insights:</h4><ul><li>Separate stacks for each frequency level</li><li>Most recent element at given frequency is on top of its stack</li><li>Track maximum frequency to know which stack to pop from</li></ul>",
      "solution_code": "class FreqStack {\n    private freq: Map<number, number>; // element -> frequency\n    private group: Map<number, number[]>; // frequency -> stack of elements\n    private maxFreq: number;\n    \n    constructor() {\n        this.freq = new Map();\n        this.group = new Map();\n        this.maxFreq = 0;\n    }\n    \n    push(val: number): void {\n        // Update frequency\n        const f = (this.freq.get(val) || 0) + 1;\n        this.freq.set(val, f);\n        \n        // Update max frequency\n        if (f > this.maxFreq) {\n            this.maxFreq = f;\n        }\n        \n        // Add to frequency group\n        if (!this.group.has(f)) {\n            this.group.set(f, []);\n        }\n        this.group.get(f)!.push(val);\n    }\n    \n    pop(): number {\n        // Pop from highest frequency group\n        const val = this.group.get(this.maxFreq)!.pop()!;\n        \n        // Update frequency\n        this.freq.set(val, this.freq.get(val)! - 1);\n        \n        // Update max frequency if needed\n        if (this.group.get(this.maxFreq)!.length === 0) {\n            this.maxFreq--;\n        }\n        \n        return val;\n    }\n}"
    },
    "java": {
      "template": "class FreqStack {\n\n    public FreqStack() {\n        \n    }\n    \n    public void push(int val) {\n        \n    }\n    \n    public int pop() {\n        \n    }\n}",
      "solution_text": "<h3>Hash Map + Stack of Stacks Solution</h3><p>Use frequency tracking with grouped stacks to efficiently find and remove most frequent elements.</p><h4>Algorithm:</h4><ol><li>Track frequency of each element with hash map</li><li>Maintain stacks grouped by frequency level</li><li>Push: increment frequency, add to appropriate frequency stack</li><li>Pop: remove from highest frequency stack, decrement frequency</li></ol><h4>Time Complexity:</h4><p>O(1) for both push and pop operations</p><h4>Space Complexity:</h4><p>O(n) for storing elements and frequency information</p><h4>Key Insights:</h4><ul><li>Separate stacks for each frequency level</li><li>Most recent element at given frequency is on top of its stack</li><li>Track maximum frequency to know which stack to pop from</li></ul>",
      "solution_code": "import java.util.*;\n\nclass FreqStack {\n    private Map<Integer, Integer> freq; // element -> frequency\n    private Map<Integer, Stack<Integer>> group; // frequency -> stack of elements\n    private int maxFreq;\n\n    public FreqStack() {\n        freq = new HashMap<>();\n        group = new HashMap<>();\n        maxFreq = 0;\n    }\n    \n    public void push(int val) {\n        // Update frequency\n        int f = freq.getOrDefault(val, 0) + 1;\n        freq.put(val, f);\n        \n        // Update max frequency\n        if (f > maxFreq) {\n            maxFreq = f;\n        }\n        \n        // Add to frequency group\n        group.computeIfAbsent(f, k -> new Stack<>()).push(val);\n    }\n    \n    public int pop() {\n        // Pop from highest frequency group\n        int val = group.get(maxFreq).pop();\n        \n        // Update frequency\n        freq.put(val, freq.get(val) - 1);\n        \n        // Update max frequency if needed\n        if (group.get(maxFreq).isEmpty()) {\n            maxFreq--;\n        }\n        \n        return val;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "operations": ["FreqStack", "push", "push", "push", "push", "push", "push", "pop", "pop", "pop", "pop"],
        "values": [[], [5], [7], [5], [7], [4], [5], [], [], [], []]
      },
      "output": [null, null, null, null, null, null, null, 5, 7, 5, 4]
    },
    {
      "id": 2,
      "input": {
        "operations": ["FreqStack", "push", "push", "push", "pop", "pop", "pop"],
        "values": [[], [1], [1], [2], [], [], []]
      },
      "output": [null, null, null, null, 1, 1, 2]
    },
    {
      "id": 3,
      "input": {
        "operations": ["FreqStack", "push", "push", "push", "push", "push", "pop", "pop"],
        "values": [[], [4], [1], [4], [2], [3], [], []]
      },
      "output": [null, null, null, null, null, null, 4, 3]
    },
    {
      "id": 4,
      "input": {
        "operations": ["FreqStack", "push", "pop"],
        "values": [[], [1], []]
      },
      "output": [null, null, 1]
    },
    {
      "id": 5,
      "input": {
        "operations": ["FreqStack", "push", "push", "push", "push", "pop", "pop", "pop", "pop"],
        "values": [[], [1], [2], [3], [4], [], [], [], []]
      },
      "output": [null, null, null, null, null, 4, 3, 2, 1]
    },
    {
      "id": 6,
      "input": {
        "operations": ["FreqStack", "push", "push", "push", "push", "push", "push", "pop", "push", "pop", "pop"],
        "values": [[], [5], [5], [5], [1], [2], [3], [], [4], [], []]
      },
      "output": [null, null, null, null, null, null, null, 5, null, 4, 3]
    },
    {
      "id": 7,
      "input": {
        "operations": ["FreqStack", "push", "push", "push", "push", "push", "pop", "pop", "pop", "push", "pop"],
        "values": [[], [1], [1], [1], [2], [2], [], [], [], [3], []]
      },
      "output": [null, null, null, null, null, null, 1, 2, 1, null, 3]
    },
    {
      "id": 8,
      "input": {
        "operations": ["FreqStack", "push", "push", "pop", "push", "pop", "pop"],
        "values": [[], [10], [20], [], [10], [], []]
      },
      "output": [null, null, null, 20, null, 10, 10]
    },
    {
      "id": 9,
      "input": {
        "operations": ["FreqStack", "push", "push", "push", "push", "push", "pop", "pop", "pop", "pop", "pop"],
        "values": [[], [7], [8], [7], [8], [9], [], [], [], [], []]
      },
      "output": [null, null, null, null, null, null, 8, 7, 9, 8, 7]
    },
    {
      "id": 10,
      "input": {
        "operations": ["FreqStack", "push", "push", "push", "push", "push", "push", "push", "pop", "pop", "pop"],
        "values": [[], [1], [2], [1], [3], [2], [1], [4], [], [], []]
      },
      "output": [null, null, null, null, null, null, null, null, 1, 4, 2]
    }
  ]
}