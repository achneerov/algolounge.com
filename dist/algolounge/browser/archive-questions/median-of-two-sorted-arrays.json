{
  "filename": "median-of-two-sorted-arrays",
  "title": "Median of Two Sorted Arrays",
  "keywords": [
    "median",
    "two",
    "sorted",
    "arrays",
    "leetcode",
    "given",
    "integer",
    "nums1",
    "nums2",
    "size"
  ],
  "description": "<h2>Median of Two Sorted Arrays</h2><p>Leetcode 4. Median of Two Sorted Arrays</p><p></p><p>You are given two integer arrays `nums1` and `nums2` of size `m` and `n` respectively, where each is sorted in ascending order. Return the [median](https://en.wikipedia.org/wiki/Median) value among all elements of the two arrays.</p><p></p><p>Your solution must run in $O(log (m+n))$ time.</p><h3>Examples:</h3><ul><li>Input: nums1 = [1,2], nums2 = [3]<br><br>Output: 2.0<br>Among `[1, 2, 3]` the median is 2.</li><li>Input: nums1 = [1,3], nums2 = [2,4]<br><br>Output: 2.5<br>Among `[1, 2, 3, 4]` the median is (2 + 3) / 2 = 2.5.</li></ul><h3>Constraints:</h3><ul><li> `nums1.length == m`</li><li> `nums2.length == n`</li><li> `0 <= m <= 1000`</li><li> `0 <= n <= 1000`</li><li> `-10^6 <= nums1[i], nums2[i] <= 10^6`</li></ul>",
  "languages": {
    "python": {
      "template": "def medianOfTwoSortedArrays(nums1, nums2):\n    ",
      "solution_text": "<h2>Median of Two Sorted Arrays - Binary Search Solution</h2><p>This problem requires finding the median in O(log(m+n)) time, which can be achieved using binary search on the smaller array.</p><h3>Algorithm:</h3><ul><li>Ensure nums1 is the smaller array for optimization</li><li>Use binary search on nums1 to find the correct partition</li><li>The partition divides both arrays such that left part has (m+n+1)//2 elements</li><li>Check if partition is valid: max_left <= min_right for both sides</li><li>Calculate median based on total length (odd/even)</li></ul><h3>Time & Space Complexity:</h3><ul><li><strong>Time Complexity:</strong> O(log(min(m,n))) - binary search on smaller array</li><li><strong>Space Complexity:</strong> O(1) - constant extra space</li></ul><h3>Key Insights:</h3><ul><li>Binary search on partitions, not elements</li><li>Handle edge cases with infinity values</li><li>Median calculation differs for odd/even total length</li></ul>",
      "solution_code": "def medianOfTwoSortedArrays(nums1, nums2):\n    # Ensure nums1 is the smaller array\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    \n    m, n = len(nums1), len(nums2)\n    left, right = 0, m\n    \n    while left <= right:\n        partition1 = (left + right) // 2\n        partition2 = (m + n + 1) // 2 - partition1\n        \n        # Handle edge cases with infinity\n        max_left1 = float('-inf') if partition1 == 0 else nums1[partition1 - 1]\n        min_right1 = float('inf') if partition1 == m else nums1[partition1]\n        \n        max_left2 = float('-inf') if partition2 == 0 else nums2[partition2 - 1]\n        min_right2 = float('inf') if partition2 == n else nums2[partition2]\n        \n        if max_left1 <= min_right2 and max_left2 <= min_right1:\n            # Found the correct partition\n            if (m + n) % 2 == 0:\n                return (max(max_left1, max_left2) + min(min_right1, min_right2)) / 2.0\n            else:\n                return max(max_left1, max_left2)\n        elif max_left1 > min_right2:\n            right = partition1 - 1\n        else:\n            left = partition1 + 1\n    \n    return 0.0"
    },
    "javascript": {
      "template": "function medianOfTwoSortedArrays(nums1, nums2) {\n  \n}",
      "solution_text": "<h2>Median of Two Sorted Arrays - Binary Search Solution</h2><p>This problem requires finding the median in O(log(m+n)) time, which can be achieved using binary search on the smaller array.</p><h3>Algorithm:</h3><ul><li>Ensure nums1 is the smaller array for optimization</li><li>Use binary search on nums1 to find the correct partition</li><li>The partition divides both arrays such that left part has (m+n+1)//2 elements</li><li>Check if partition is valid: max_left <= min_right for both sides</li><li>Calculate median based on total length (odd/even)</li></ul><h3>Time & Space Complexity:</h3><ul><li><strong>Time Complexity:</strong> O(log(min(m,n))) - binary search on smaller array</li><li><strong>Space Complexity:</strong> O(1) - constant extra space</li></ul><h3>Key Insights:</h3><ul><li>Binary search on partitions, not elements</li><li>Handle edge cases with infinity values</li><li>Median calculation differs for odd/even total length</li></ul>",
      "solution_code": "function medianOfTwoSortedArrays(nums1, nums2) {\n    // Ensure nums1 is the smaller array\n    if (nums1.length > nums2.length) {\n        [nums1, nums2] = [nums2, nums1];\n    }\n    \n    const m = nums1.length, n = nums2.length;\n    let left = 0, right = m;\n    \n    while (left <= right) {\n        const partition1 = Math.floor((left + right) / 2);\n        const partition2 = Math.floor((m + n + 1) / 2) - partition1;\n        \n        // Handle edge cases with infinity\n        const maxLeft1 = partition1 === 0 ? -Infinity : nums1[partition1 - 1];\n        const minRight1 = partition1 === m ? Infinity : nums1[partition1];\n        \n        const maxLeft2 = partition2 === 0 ? -Infinity : nums2[partition2 - 1];\n        const minRight2 = partition2 === n ? Infinity : nums2[partition2];\n        \n        if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {\n            // Found the correct partition\n            if ((m + n) % 2 === 0) {\n                return (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2.0;\n            } else {\n                return Math.max(maxLeft1, maxLeft2);\n            }\n        } else if (maxLeft1 > minRight2) {\n            right = partition1 - 1;\n        } else {\n            left = partition1 + 1;\n        }\n    }\n    \n    return 0.0;\n}"
    },
    "typescript": {
      "template": "function medianOfTwoSortedArrays(nums1: number[], nums2: number[]): number {\n  \n}",
      "solution_text": "<h2>Median of Two Sorted Arrays - Binary Search Solution</h2><p>This problem requires finding the median in O(log(m+n)) time, which can be achieved using binary search on the smaller array.</p><h3>Algorithm:</h3><ul><li>Ensure nums1 is the smaller array for optimization</li><li>Use binary search on nums1 to find the correct partition</li><li>The partition divides both arrays such that left part has (m+n+1)//2 elements</li><li>Check if partition is valid: max_left <= min_right for both sides</li><li>Calculate median based on total length (odd/even)</li></ul><h3>Time & Space Complexity:</h3><ul><li><strong>Time Complexity:</strong> O(log(min(m,n))) - binary search on smaller array</li><li><strong>Space Complexity:</strong> O(1) - constant extra space</li></ul><h3>Key Insights:</h3><ul><li>Binary search on partitions, not elements</li><li>Handle edge cases with infinity values</li><li>Median calculation differs for odd/even total length</li></ul>",
      "solution_code": "function medianOfTwoSortedArrays(nums1: number[], nums2: number[]): number {\n    // Ensure nums1 is the smaller array\n    if (nums1.length > nums2.length) {\n        [nums1, nums2] = [nums2, nums1];\n    }\n    \n    const m = nums1.length, n = nums2.length;\n    let left = 0, right = m;\n    \n    while (left <= right) {\n        const partition1 = Math.floor((left + right) / 2);\n        const partition2 = Math.floor((m + n + 1) / 2) - partition1;\n        \n        // Handle edge cases with infinity\n        const maxLeft1 = partition1 === 0 ? -Infinity : nums1[partition1 - 1];\n        const minRight1 = partition1 === m ? Infinity : nums1[partition1];\n        \n        const maxLeft2 = partition2 === 0 ? -Infinity : nums2[partition2 - 1];\n        const minRight2 = partition2 === n ? Infinity : nums2[partition2];\n        \n        if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {\n            // Found the correct partition\n            if ((m + n) % 2 === 0) {\n                return (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2.0;\n            } else {\n                return Math.max(maxLeft1, maxLeft2);\n            }\n        } else if (maxLeft1 > minRight2) {\n            right = partition1 - 1;\n        } else {\n            left = partition1 + 1;\n        }\n    }\n    \n    return 0.0;\n}"
    },
    "java": {
      "template": "class Solution {\n    public double medianOfTwoSortedArrays(int[] nums1, int[] nums2) {\n        \n    }\n}",
      "solution_text": "<h2>Median of Two Sorted Arrays - Binary Search Solution</h2><p>This problem requires finding the median in O(log(m+n)) time, which can be achieved using binary search on the smaller array.</p><h3>Algorithm:</h3><ul><li>Ensure nums1 is the smaller array for optimization</li><li>Use binary search on nums1 to find the correct partition</li><li>The partition divides both arrays such that left part has (m+n+1)//2 elements</li><li>Check if partition is valid: max_left <= min_right for both sides</li><li>Calculate median based on total length (odd/even)</li></ul><h3>Time & Space Complexity:</h3><ul><li><strong>Time Complexity:</strong> O(log(min(m,n))) - binary search on smaller array</li><li><strong>Space Complexity:</strong> O(1) - constant extra space</li></ul><h3>Key Insights:</h3><ul><li>Binary search on partitions, not elements</li><li>Handle edge cases with infinity values</li><li>Median calculation differs for odd/even total length</li></ul>",
      "solution_code": "class Solution {\n    public double medianOfTwoSortedArrays(int[] nums1, int[] nums2) {\n        // Ensure nums1 is the smaller array\n        if (nums1.length > nums2.length) {\n            int[] temp = nums1;\n            nums1 = nums2;\n            nums2 = temp;\n        }\n        \n        int m = nums1.length, n = nums2.length;\n        int left = 0, right = m;\n        \n        while (left <= right) {\n            int partition1 = (left + right) / 2;\n            int partition2 = (m + n + 1) / 2 - partition1;\n            \n            // Handle edge cases with infinity\n            int maxLeft1 = partition1 == 0 ? Integer.MIN_VALUE : nums1[partition1 - 1];\n            int minRight1 = partition1 == m ? Integer.MAX_VALUE : nums1[partition1];\n            \n            int maxLeft2 = partition2 == 0 ? Integer.MIN_VALUE : nums2[partition2 - 1];\n            int minRight2 = partition2 == n ? Integer.MAX_VALUE : nums2[partition2];\n            \n            if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {\n                // Found the correct partition\n                if ((m + n) % 2 == 0) {\n                    return (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2.0;\n                } else {\n                    return Math.max(maxLeft1, maxLeft2);\n                }\n            } else if (maxLeft1 > minRight2) {\n                right = partition1 - 1;\n            } else {\n                left = partition1 + 1;\n            }\n        }\n        \n        return 0.0;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "nums1": [1, 2],
        "nums2": [3]
      },
      "output": 2.0
    },
    {
      "id": 2,
      "input": {
        "nums1": [1, 3],
        "nums2": [2, 4]
      },
      "output": 2.5
    },
    {
      "id": 3,
      "input": {
        "nums1": [],
        "nums2": [1]
      },
      "output": 1.0
    },
    {
      "id": 4,
      "input": {
        "nums1": [2],
        "nums2": []
      },
      "output": 2.0
    },
    {
      "id": 5,
      "input": {
        "nums1": [1, 2],
        "nums2": [3, 4]
      },
      "output": 2.5
    },
    {
      "id": 6,
      "input": {
        "nums1": [0, 0],
        "nums2": [0, 0]
      },
      "output": 0.0
    },
    {
      "id": 7,
      "input": {
        "nums1": [],
        "nums2": [2, 3]
      },
      "output": 2.5
    },
    {
      "id": 8,
      "input": {
        "nums1": [1],
        "nums2": [2, 3, 4]
      },
      "output": 2.5
    },
    {
      "id": 9,
      "input": {
        "nums1": [1, 2, 3],
        "nums2": [4, 5, 6]
      },
      "output": 3.5
    },
    {
      "id": 10,
      "input": {
        "nums1": [1, 3, 8],
        "nums2": [7, 9, 10, 11]
      },
      "output": 8.0
    }
  ]
}