{
  "filename": "merge-intervals",
  "title": "Merge Intervals",
  "keywords": [
    "merge",
    "intervals",
    "leetcode",
    "given",
    "array",
    "where",
    "start_i",
    "end_i",
    "all",
    "overlapping"
  ],
  "description": "<h2>Merge Intervals</h2><p>Leetcode 56. Merge Intervals</p><p></p><p>Given an array of `intervals` where `intervals[i] = [start_i, end_i]`, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.</p><p></p><p>You may return the answer in **any order**.</p><p></p><p>Note: Intervals are *non-overlapping* if they have no common point. For example, `[1, 2]` and `[3, 4]` are non-overlapping, but `[1, 2]` and `[2, 3]` are overlapping.</p><h3>Examples:</h3><ul><li>Input: intervals = [[1,3],[1,5],[6,7]]<br><br>Output: [[1,5],[6,7]]</li><li>Input: intervals = [[1,2],[2,3]]<br><br>Output: [[1,3]]</li></ul><h3>Constraints:</h3><ul><li> `1 <= intervals.length <= 1000`</li><li> `intervals[i].length == 2`</li><li> `0 <= start <= end <= 1000`</li></ul>",
  "languages": {
    "python": {
      "template": "def mergeIntervals(intervals):\n    ",
      "solution_text": "<h2>Solution: Sort and Merge Overlapping Intervals</h2>\n\n<h3>Algorithm:</h3>\n<ul>\n<li>Sort intervals by start time</li>\n<li>Iterate through sorted intervals</li>\n<li>If current interval overlaps with the last merged interval, merge them</li>\n<li>Otherwise, add current interval to result</li>\n</ul>\n\n<h3>Time Complexity:</h3>\n<p>O(n log n) - dominated by sorting step</p>\n\n<h3>Space Complexity:</h3>\n<p>O(n) - result array in worst case</p>\n\n<h3>Key Insights:</h3>\n<ul>\n<li>Two intervals [a,b] and [c,d] overlap if b >= c</li>\n<li>Sorting enables linear scan for merging</li>\n<li>Merged interval: [min(start1,start2), max(end1,end2)]</li>\n</ul>",
      "solution_code": "def mergeIntervals(intervals):\n    if not intervals:\n        return []\n    \n    # Sort intervals by start time\n    intervals.sort(key=lambda x: x[0])\n    \n    merged = [intervals[0]]\n    \n    for current in intervals[1:]:\n        last_merged = merged[-1]\n        \n        # Check if current interval overlaps with the last merged interval\n        if current[0] <= last_merged[1]:\n            # Merge intervals by extending the end time\n            merged[-1] = [last_merged[0], max(last_merged[1], current[1])]\n        else:\n            # No overlap, add current interval to result\n            merged.append(current)\n    \n    return merged"
    },
    "javascript": {
      "template": "function mergeIntervals(intervals) {\n  \n}",
      "solution_text": "<h2>Solution: Sort and Merge Overlapping Intervals</h2>\n\n<h3>Algorithm:</h3>\n<ul>\n<li>Sort intervals by start time</li>\n<li>Iterate through sorted intervals</li>\n<li>If current interval overlaps with the last merged interval, merge them</li>\n<li>Otherwise, add current interval to result</li>\n</ul>\n\n<h3>Time Complexity:</h3>\n<p>O(n log n) - dominated by sorting step</p>\n\n<h3>Space Complexity:</h3>\n<p>O(n) - result array in worst case</p>\n\n<h3>Key Insights:</h3>\n<ul>\n<li>Two intervals [a,b] and [c,d] overlap if b >= c</li>\n<li>Sorting enables linear scan for merging</li>\n<li>Merged interval: [min(start1,start2), max(end1,end2)]</li>\n</ul>",
      "solution_code": "function mergeIntervals(intervals) {\n    if (!intervals || intervals.length === 0) {\n        return [];\n    }\n    \n    // Sort intervals by start time\n    intervals.sort((a, b) => a[0] - b[0]);\n    \n    const merged = [intervals[0]];\n    \n    for (let i = 1; i < intervals.length; i++) {\n        const current = intervals[i];\n        const lastMerged = merged[merged.length - 1];\n        \n        // Check if current interval overlaps with the last merged interval\n        if (current[0] <= lastMerged[1]) {\n            // Merge intervals by extending the end time\n            merged[merged.length - 1] = [lastMerged[0], Math.max(lastMerged[1], current[1])];\n        } else {\n            // No overlap, add current interval to result\n            merged.push(current);\n        }\n    }\n    \n    return merged;\n}"
    },
    "typescript": {
      "template": "function mergeIntervals(intervals: number[][]): number[][] {\n  \n}",
      "solution_text": "<h2>Solution: Sort and Merge Overlapping Intervals</h2>\n\n<h3>Algorithm:</h3>\n<ul>\n<li>Sort intervals by start time</li>\n<li>Iterate through sorted intervals</li>\n<li>If current interval overlaps with the last merged interval, merge them</li>\n<li>Otherwise, add current interval to result</li>\n</ul>\n\n<h3>Time Complexity:</h3>\n<p>O(n log n) - dominated by sorting step</p>\n\n<h3>Space Complexity:</h3>\n<p>O(n) - result array in worst case</p>\n\n<h3>Key Insights:</h3>\n<ul>\n<li>Two intervals [a,b] and [c,d] overlap if b >= c</li>\n<li>Sorting enables linear scan for merging</li>\n<li>Merged interval: [min(start1,start2), max(end1,end2)]</li>\n</ul>",
      "solution_code": "function mergeIntervals(intervals: number[][]): number[][] {\n    if (!intervals || intervals.length === 0) {\n        return [];\n    }\n    \n    // Sort intervals by start time\n    intervals.sort((a, b) => a[0] - b[0]);\n    \n    const merged: number[][] = [intervals[0]];\n    \n    for (let i = 1; i < intervals.length; i++) {\n        const current = intervals[i];\n        const lastMerged = merged[merged.length - 1];\n        \n        // Check if current interval overlaps with the last merged interval\n        if (current[0] <= lastMerged[1]) {\n            // Merge intervals by extending the end time\n            merged[merged.length - 1] = [lastMerged[0], Math.max(lastMerged[1], current[1])];\n        } else {\n            // No overlap, add current interval to result\n            merged.push(current);\n        }\n    }\n    \n    return merged;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int[][] mergeIntervals(int[][] intervals) {\n        \n    }\n}",
      "solution_text": "<h2>Solution: Sort and Merge Overlapping Intervals</h2>\n\n<h3>Algorithm:</h3>\n<ul>\n<li>Sort intervals by start time</li>\n<li>Iterate through sorted intervals</li>\n<li>If current interval overlaps with the last merged interval, merge them</li>\n<li>Otherwise, add current interval to result</li>\n</ul>\n\n<h3>Time Complexity:</h3>\n<p>O(n log n) - dominated by sorting step</p>\n\n<h3>Space Complexity:</h3>\n<p>O(n) - result array in worst case</p>\n\n<h3>Key Insights:</h3>\n<ul>\n<li>Two intervals [a,b] and [c,d] overlap if b >= c</li>\n<li>Sorting enables linear scan for merging</li>\n<li>Merged interval: [min(start1,start2), max(end1,end2)]</li>\n</ul>",
      "solution_code": "import java.util.*;\n\nclass Solution {\n    public int[][] mergeIntervals(int[][] intervals) {\n        if (intervals == null || intervals.length == 0) {\n            return new int[0][];\n        }\n        \n        // Sort intervals by start time\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n        \n        List<int[]> merged = new ArrayList<>();\n        merged.add(intervals[0]);\n        \n        for (int i = 1; i < intervals.length; i++) {\n            int[] current = intervals[i];\n            int[] lastMerged = merged.get(merged.size() - 1);\n            \n            // Check if current interval overlaps with the last merged interval\n            if (current[0] <= lastMerged[1]) {\n                // Merge intervals by extending the end time\n                lastMerged[1] = Math.max(lastMerged[1], current[1]);\n            } else {\n                // No overlap, add current interval to result\n                merged.add(current);\n            }\n        }\n        \n        return merged.toArray(new int[merged.size()][]);\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "intervals": [[1, 3], [2, 6], [8, 10], [15, 18]]
      },
      "output": [[1, 6], [8, 10], [15, 18]]
    },
    {
      "id": 2,
      "input": {
        "intervals": [[1, 4], [4, 5]]
      },
      "output": [[1, 5]]
    },
    {
      "id": 3,
      "input": {
        "intervals": [[1, 3], [2, 6], [8, 10], [9, 12], [15, 18]]
      },
      "output": [[1, 6], [8, 12], [15, 18]]
    },
    {
      "id": 4,
      "input": {
        "intervals": [[1, 2], [3, 4], [5, 6]]
      },
      "output": [[1, 2], [3, 4], [5, 6]]
    },
    {
      "id": 5,
      "input": {
        "intervals": [[1, 10]]
      },
      "output": [[1, 10]]
    },
    {
      "id": 6,
      "input": {
        "intervals": []
      },
      "output": []
    },
    {
      "id": 7,
      "input": {
        "intervals": [[1, 3], [0, 2], [4, 6]]
      },
      "output": [[0, 3], [4, 6]]
    },
    {
      "id": 8,
      "input": {
        "intervals": [[1, 4], [2, 3]]
      },
      "output": [[1, 4]]
    },
    {
      "id": 9,
      "input": {
        "intervals": [[0, 0], [1, 2], [1, 4]]
      },
      "output": [[0, 0], [1, 4]]
    },
    {
      "id": 10,
      "input": {
        "intervals": [[1, 1000], [2, 3], [500, 600]]
      },
      "output": [[1, 1000]]
    }
  ]
}