{
  "filename": "merge-sorted-array",
  "title": "Merge Sorted Array",
  "keywords": [
    "merge",
    "sorted",
    "array",
    "leetcode",
    "given",
    "two",
    "integer",
    "arrays",
    "nums1",
    "nums2"
  ],
  "description": "<h2>Merge Sorted Array</h2><p>Leetcode 88. Merge Sorted Array</p><p></p><p>You are given two integer arrays `nums1` and `nums2`, both sorted in **non-decreasing order**, along with two integers `m` and `n`, where:</p><p></p><p>- `m` is the number of valid elements in `nums1`,</p><p></p><p>- `n` is the number of elements in `nums2`.</p><p></p><p>The array `nums1` has a total length of `(m+n)`, with the first `m` elements containing the values to be merged, and the last `n` elements set to `0` as placeholders.</p><p></p><p>Your task is to merge the two arrays such that the final merged array is also sorted in **non-decreasing order** and stored entirely within `nums1`.</p><p>You must modify nums1 in-place and do not return anything from the function.</p><h3>Examples:</h3><ul><li>Input: nums1 = [10,20,20,40,0,0], m = 4, nums2 = [1,2], n = 2<br><br>Output: [1,2,10,20,20,40]</li><li>Input: nums1 = [0,0], m = 0, nums2 = [1,2], n = 2<br><br>Output: [1,2]</li></ul><h3>Constraints:</h3><ul><li> `0 <= m, n <= 200`</li><li> `1 <= (m + n) <= 200`</li><li> `nums1.length == (m + n)`</li><li> `nums2.length == n`</li><li> `-1,000,000,000 <= nums1[i], nums2[i] <= 1,000,000,000`</li></ul>",
  "languages": {
    "python": {
      "template": "def mergeSortedArray(nums1, m, nums2, n):\n    ",
      "solution_text": "<h2>Solution: In-place Merge from End</h2>\n\n<h3>Algorithm:</h3>\n<ul>\n<li>Use three pointers: i (end of nums1 valid elements), j (end of nums2), k (end of nums1 total)</li>\n<li>Compare elements from end and place larger element at position k</li>\n<li>Move backwards to avoid overwriting unprocessed elements</li>\n<li>Continue until all elements from nums2 are processed</li>\n</ul>\n\n<h3>Time Complexity:</h3>\n<p>O(m + n) - visit each element once</p>\n\n<h3>Space Complexity:</h3>\n<p>O(1) - constant extra space, in-place modification</p>\n\n<h3>Key Insights:</h3>\n<ul>\n<li>Working backwards prevents overwriting unprocessed elements</li>\n<li>nums1 has enough space to hold all elements</li>\n<li>No extra space needed for merging</li>\n</ul>",
      "solution_code": "def mergeSortedArray(nums1, m, nums2, n):\n    # Pointers for nums1, nums2, and merged array\n    i = m - 1  # Last element in nums1\n    j = n - 1  # Last element in nums2\n    k = m + n - 1  # Last position in nums1\n    \n    # Merge from end to beginning\n    while j >= 0:\n        if i >= 0 and nums1[i] > nums2[j]:\n            nums1[k] = nums1[i]\n            i -= 1\n        else:\n            nums1[k] = nums2[j]\n            j -= 1\n        k -= 1\n    \n    # Return modified nums1 for testing purposes\n    return nums1"
    },
    "javascript": {
      "template": "function mergeSortedArray(nums1, m, nums2, n) {\n  \n}",
      "solution_text": "<h2>Solution: In-place Merge from End</h2>\n\n<h3>Algorithm:</h3>\n<ul>\n<li>Use three pointers: i (end of nums1 valid elements), j (end of nums2), k (end of nums1 total)</li>\n<li>Compare elements from end and place larger element at position k</li>\n<li>Move backwards to avoid overwriting unprocessed elements</li>\n<li>Continue until all elements from nums2 are processed</li>\n</ul>\n\n<h3>Time Complexity:</h3>\n<p>O(m + n) - visit each element once</p>\n\n<h3>Space Complexity:</h3>\n<p>O(1) - constant extra space, in-place modification</p>\n\n<h3>Key Insights:</h3>\n<ul>\n<li>Working backwards prevents overwriting unprocessed elements</li>\n<li>nums1 has enough space to hold all elements</li>\n<li>No extra space needed for merging</li>\n</ul>",
      "solution_code": "function mergeSortedArray(nums, target) {\n    let left = 0, right = nums.length - 1;\n    \n    while (left <= right) {\n        // Avoid integer overflow\n        const mid = left + Math.floor((right - left) / 2);\n        \n        if (nums[mid] === target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return -1;\n}"
    },
    "typescript": {
      "template": "function mergeSortedArray(nums1: number[], m: string, nums2: number[], n: number): number[] {\n  \n}",
      "solution_text": "<h2>Solution: In-place Merge from End</h2>\n\n<h3>Algorithm:</h3>\n<ul>\n<li>Use three pointers: i (end of nums1 valid elements), j (end of nums2), k (end of nums1 total)</li>\n<li>Compare elements from end and place larger element at position k</li>\n<li>Move backwards to avoid overwriting unprocessed elements</li>\n<li>Continue until all elements from nums2 are processed</li>\n</ul>\n\n<h3>Time Complexity:</h3>\n<p>O(m + n) - visit each element once</p>\n\n<h3>Space Complexity:</h3>\n<p>O(1) - constant extra space, in-place modification</p>\n\n<h3>Key Insights:</h3>\n<ul>\n<li>Working backwards prevents overwriting unprocessed elements</li>\n<li>nums1 has enough space to hold all elements</li>\n<li>No extra space needed for merging</li>\n</ul>",
      "solution_code": "function mergeSortedArray(nums: number[], target: number): number {\n    let left = 0, right = nums.length - 1;\n    \n    while (left <= right) {\n        // Avoid integer overflow\n        const mid = left + Math.floor((right - left) / 2);\n        \n        if (nums[mid] === target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return -1;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int[] mergeSortedArray(int[] nums1, String m, int[] nums2, int n) {\n        \n    }\n}",
      "solution_text": "<h2>Solution: In-place Merge from End</h2>\n\n<h3>Algorithm:</h3>\n<ul>\n<li>Use three pointers: i (end of nums1 valid elements), j (end of nums2), k (end of nums1 total)</li>\n<li>Compare elements from end and place larger element at position k</li>\n<li>Move backwards to avoid overwriting unprocessed elements</li>\n<li>Continue until all elements from nums2 are processed</li>\n</ul>\n\n<h3>Time Complexity:</h3>\n<p>O(m + n) - visit each element once</p>\n\n<h3>Space Complexity:</h3>\n<p>O(1) - constant extra space, in-place modification</p>\n\n<h3>Key Insights:</h3>\n<ul>\n<li>Working backwards prevents overwriting unprocessed elements</li>\n<li>nums1 has enough space to hold all elements</li>\n<li>No extra space needed for merging</li>\n</ul>",
      "solution_code": "class Solution {\n    public int mergeSortedArray(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        \n        while (left <= right) {\n            // Avoid integer overflow\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return -1;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "nums1": [
          10,
          20,
          20,
          40,
          0,
          0
        ],
        "m": "4,",
        "nums2": [
          1,
          2
        ],
        "n": 2
      },
      "output": [
        1,
        2,
        10,
        20,
        20,
        40
      ]
    },
    {
      "id": 2,
      "input": {
        "nums1": [
          0,
          0
        ],
        "m": "0,",
        "nums2": [
          1,
          2
        ],
        "n": 2
      },
      "output": [
        1,
        2
      ]
    }
  ]
}