{
  "filename": "merge-two-sorted-linked-lists",
  "title": "Merge Two Sorted Linked Lists",
  "keywords": [
    "merge",
    "two",
    "sorted",
    "linked",
    "lists",
    "leetcode",
    "given",
    "heads",
    "list1",
    "list2"
  ],
  "description": "<h2>Merge Two Sorted Linked Lists</h2><p>Leetcode 21. Merge Two Sorted Lists</p><p></p><p>You are given the heads of two sorted linked lists `list1` and `list2`.</p><p></p><p>Merge the two lists into one **sorted** linked list and return the head of the new sorted linked list.</p><p></p><p>The new list should be made up of nodes from `list1` and `list2`.</p><h3>Examples:</h3><ul><li>Input: list1 = [], list2 = [1,2]<br><br>Output: [1,2]</li><li>Input: list1 = [], list2 = []<br><br>Output: []</li></ul><h3>Constraints:</h3><ul><li> `0 <= The length of the each list <= 100`.</li><li> `-100 <= Node.val <= 100`</li></ul>",
  "languages": {
    "python": {
      "template": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef mergeTwoSortedLinkedLists(list1, list2):\n    ",
      "solution_text": "<h2>Two-Pointer Approach for Merging Sorted Linked Lists</h2>\n\n<p><strong>Algorithm:</strong></p>\n<ul>\n<li>Create a dummy node to simplify edge case handling</li>\n<li>Use two pointers to traverse both linked lists</li>\n<li>Compare current values and attach smaller node to result</li>\n<li>Append remaining nodes from non-exhausted list</li>\n</ul>\n\n<p><strong>Time Complexity:</strong> O(m + n) - visit each node once</p>\n<p><strong>Space Complexity:</strong> O(1) - only using pointers</p>\n\n<p><strong>Key Insights:</strong></p>\n<ul>\n<li>Dummy node simplifies head management</li>\n<li>Two-pointer technique for sorted data</li>\n<li>Handle different length lists efficiently</li>\n</ul>",
      "solution_code": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef mergeTwoSortedLinkedLists(list1, list2):\n    # Create dummy node to simplify logic\n    dummy = ListNode(0)\n    current = dummy\n    \n    # Merge while both lists have nodes\n    while list1 and list2:\n        if list1.val <= list2.val:\n            current.next = list1\n            list1 = list1.next\n        else:\n            current.next = list2\n            list2 = list2.next\n        current = current.next\n    \n    # Attach remaining nodes\n    current.next = list1 or list2\n    \n    return dummy.next"
    },
    "javascript": {
      "template": "// Definition for singly-linked list.\n// function ListNode(val, next) {\n//     this.val = (val===undefined ? 0 : val)\n//     this.next = (next===undefined ? null : next)\n// }\nfunction mergeTwoSortedLinkedLists(list1, list2) {\n  \n}",
      "solution_text": "<h2>Two-Pointer Approach for Merging Sorted Linked Lists</h2>\n\n<p><strong>Algorithm:</strong></p>\n<ul>\n<li>Create a dummy node to simplify edge case handling</li>\n<li>Use two pointers to traverse both linked lists</li>\n<li>Compare current values and attach smaller node to result</li>\n<li>Append remaining nodes from non-exhausted list</li>\n</ul>\n\n<p><strong>Time Complexity:</strong> O(m + n) - visit each node once</p>\n<p><strong>Space Complexity:</strong> O(1) - only using pointers</p>\n\n<p><strong>Key Insights:</strong></p>\n<ul>\n<li>Dummy node simplifies head management</li>\n<li>Two-pointer technique for sorted data</li>\n<li>Handle different length lists efficiently</li>\n</ul>",
      "solution_code": "// Definition for singly-linked list.\nfunction ListNode(val, next) {\n    this.val = (val === undefined ? 0 : val);\n    this.next = (next === undefined ? null : next);\n}\n\nfunction mergeTwoSortedLinkedLists(list1, list2) {\n    // Create dummy node to simplify logic\n    const dummy = new ListNode(0);\n    let current = dummy;\n    \n    // Merge while both lists have nodes\n    while (list1 !== null && list2 !== null) {\n        if (list1.val <= list2.val) {\n            current.next = list1;\n            list1 = list1.next;\n        } else {\n            current.next = list2;\n            list2 = list2.next;\n        }\n        current = current.next;\n    }\n    \n    // Attach remaining nodes\n    current.next = list1 || list2;\n    \n    return dummy.next;\n}"
    },
    "typescript": {
      "template": "// Definition for singly-linked list.\n// class ListNode {\n//     val: number\n//     next: ListNode | null\n//     constructor(val?: number, next?: ListNode | null) {\n//         this.val = (val===undefined ? 0 : val)\n//         this.next = (next===undefined ? null : next)\n//     }\n// }\nfunction mergeTwoSortedLinkedLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {\n  \n}",
      "solution_text": "<h2>Two-Pointer Approach for Merging Sorted Linked Lists</h2>\n\n<p><strong>Algorithm:</strong></p>\n<ul>\n<li>Create a dummy node to simplify edge case handling</li>\n<li>Use two pointers to traverse both linked lists</li>\n<li>Compare current values and attach smaller node to result</li>\n<li>Append remaining nodes from non-exhausted list</li>\n</ul>\n\n<p><strong>Time Complexity:</strong> O(m + n) - visit each node once</p>\n<p><strong>Space Complexity:</strong> O(1) - only using pointers</p>\n\n<p><strong>Key Insights:</strong></p>\n<ul>\n<li>Dummy node simplifies head management</li>\n<li>Two-pointer technique for sorted data</li>\n<li>Handle different length lists efficiently</li>\n</ul>",
      "solution_code": "// Definition for singly-linked list.\nclass ListNode {\n    val: number;\n    next: ListNode | null;\n    constructor(val?: number, next?: ListNode | null) {\n        this.val = (val === undefined ? 0 : val);\n        this.next = (next === undefined ? null : next);\n    }\n}\n\nfunction mergeTwoSortedLinkedLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {\n    // Create dummy node to simplify logic\n    const dummy = new ListNode(0);\n    let current = dummy;\n    \n    // Merge while both lists have nodes\n    while (list1 !== null && list2 !== null) {\n        if (list1.val <= list2.val) {\n            current.next = list1;\n            list1 = list1.next;\n        } else {\n            current.next = list2;\n            list2 = list2.next;\n        }\n        current = current.next;\n    }\n    \n    // Attach remaining nodes\n    current.next = list1 || list2;\n    \n    return dummy.next;\n}"
    },
    "java": {
      "template": "// Definition for singly-linked list.\n// public class ListNode {\n//     int val;\n//     ListNode next;\n//     ListNode() {}\n//     ListNode(int val) { this.val = val; }\n//     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n// }\nclass Solution {\n    public ListNode mergeTwoSortedLinkedLists(ListNode list1, ListNode list2) {\n        \n    }\n}",
      "solution_text": "<h2>Two-Pointer Approach for Merging Sorted Linked Lists</h2>\n\n<p><strong>Algorithm:</strong></p>\n<ul>\n<li>Create a dummy node to simplify edge case handling</li>\n<li>Use two pointers to traverse both linked lists</li>\n<li>Compare current values and attach smaller node to result</li>\n<li>Append remaining nodes from non-exhausted list</li>\n</ul>\n\n<p><strong>Time Complexity:</strong> O(m + n) - visit each node once</p>\n<p><strong>Space Complexity:</strong> O(1) - only using pointers</p>\n\n<p><strong>Key Insights:</strong></p>\n<ul>\n<li>Dummy node simplifies head management</li>\n<li>Two-pointer technique for sorted data</li>\n<li>Handle different length lists efficiently</li>\n</ul>",
      "solution_code": "// Definition for singly-linked list.\npublic class ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    public ListNode mergeTwoSortedLinkedLists(ListNode list1, ListNode list2) {\n        // Create dummy node to simplify logic\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        \n        // Merge while both lists have nodes\n        while (list1 != null && list2 != null) {\n            if (list1.val <= list2.val) {\n                current.next = list1;\n                list1 = list1.next;\n            } else {\n                current.next = list2;\n                list2 = list2.next;\n            }\n            current = current.next;\n        }\n        \n        // Attach remaining nodes\n        current.next = (list1 != null) ? list1 : list2;\n        \n        return dummy.next;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "list1": [1,2,4],
        "list2": [1,3,4]
      },
      "output": [1,1,2,3,4,4]
    },
    {
      "id": 2,
      "input": {
        "list1": [],
        "list2": []
      },
      "output": []
    },
    {
      "id": 3,
      "input": {
        "list1": [],
        "list2": [0]
      },
      "output": [0]
    },
    {
      "id": 4,
      "input": {
        "list1": [1],
        "list2": [2]
      },
      "output": [1,2]
    },
    {
      "id": 5,
      "input": {
        "list1": [1,3,5],
        "list2": [2,4,6]
      },
      "output": [1,2,3,4,5,6]
    },
    {
      "id": 6,
      "input": {
        "list1": [1,1,1],
        "list2": [2,2,2]
      },
      "output": [1,1,1,2,2,2]
    },
    {
      "id": 7,
      "input": {
        "list1": [5],
        "list2": [1,2,3,4]
      },
      "output": [1,2,3,4,5]
    },
    {
      "id": 8,
      "input": {
        "list1": [-10,-5,0],
        "list2": [-8,-2,4]
      },
      "output": [-10,-8,-5,-2,0,4]
    },
    {
      "id": 9,
      "input": {
        "list1": [1,2,3],
        "list2": []
      },
      "output": [1,2,3]
    },
    {
      "id": 10,
      "input": {
        "list1": [1,100],
        "list2": [50]
      },
      "output": [1,50,100]
    }
  ]
}