{
  "filename": "minimum-path-sum",
  "title": "Minimum Path Sum",
  "keywords": [
    "minimum",
    "path",
    "sum",
    "leetcode",
    "given",
    "grid",
    "filled",
    "non",
    "negative",
    "numbers"
  ],
  "description": "<h2>Minimum Path Sum</h2><p>Leetcode 64. Minimum Path Sum</p><p></p><p>You are given a `m x n` `grid` filled with **non-negative numbers**, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.</p><p></p><p>**Note:** You can only move either down or right at any point in time.</p><h3>Examples:</h3><ul><li>Input: grid = [<br>    [1,2,0],<br>    [5,4,2],<br>    [1,1,3]<br>]<br><br>Output: 8<br>The path with minimum sum is 1 -> 2 -> 0 -> 2 -> 3.</li><li>Input: grid = [<br>    [2,2],<br>    [1,0]<br>]<br><br>Output: 3</li></ul><h3>Constraints:</h3><ul><li> `m == grid.length`</li><li> `n == grid[i].length`</li><li> `1 <= m, n <= 200`</li><li> `0 <= grid[i][j] <= 200`</li></ul>",
  "languages": {
    "python": {
      "template": "def minimumPathSum(grid):\n    ",
      "solution_text": "Min/Max finding algorithm:\n\n**Algorithm:**\n1. Initialize min/max with first element\n2. Iterate through remaining elements\n3. Update min/max as needed\n\n**Time Complexity:** O(n) - single pass through array\n**Space Complexity:** O(1) - constant extra space\n\n**Key Insights:**\n- Handle empty arrays with appropriate defaults\n- Consider both positive and negative numbers\n- Single pass optimization",
      "solution_code": "def minimumPathSum(nums):\n    if not nums:\n        return 0  # or appropriate default\n    \n    result = nums[0]\n    \n    for num in nums[1:]:\n        if 'max' in 'minimumPathSum'.lower():\n            result = max(result, num)\n        else:\n            result = min(result, num)\n    \n    return result"
    },
    "javascript": {
      "template": "function minimumPathSum(grid) {\n  \n}",
      "solution_text": "Min/Max finding algorithm:\n\n**Algorithm:**\n1. Initialize min/max with first element\n2. Iterate through remaining elements\n3. Update min/max as needed\n\n**Time Complexity:** O(n) - single pass through array\n**Space Complexity:** O(1) - constant extra space\n\n**Key Insights:**\n- Handle empty arrays with appropriate defaults\n- Consider both positive and negative numbers\n- Single pass optimization",
      "solution_code": "function minimumPathSum(nums) {\n    if (!nums || nums.length === 0) return 0;\n    \n    let result = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        if ('minimumPathSum'.toLowerCase().includes('max')) {\n            result = Math.max(result, nums[i]);\n        } else {\n            result = Math.min(result, nums[i]);\n        }\n    }\n    \n    return result;\n}"
    },
    "typescript": {
      "template": "function minimumPathSum(grid: number[]): number {\n  \n}",
      "solution_text": "Min/Max finding algorithm:\n\n**Algorithm:**\n1. Initialize min/max with first element\n2. Iterate through remaining elements\n3. Update min/max as needed\n\n**Time Complexity:** O(n) - single pass through array\n**Space Complexity:** O(1) - constant extra space\n\n**Key Insights:**\n- Handle empty arrays with appropriate defaults\n- Consider both positive and negative numbers\n- Single pass optimization",
      "solution_code": "function minimumPathSum(nums: number[]): number {\n    if (!nums || nums.length === 0) return 0;\n    \n    let result = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        if ('minimumPathSum'.toLowerCase().includes('max')) {\n            result = Math.max(result, nums[i]);\n        } else {\n            result = Math.min(result, nums[i]);\n        }\n    }\n    \n    return result;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int minimumPathSum(int[] grid) {\n        \n    }\n}",
      "solution_text": "Min/Max finding algorithm:\n\n**Algorithm:**\n1. Initialize min/max with first element\n2. Iterate through remaining elements\n3. Update min/max as needed\n\n**Time Complexity:** O(n) - single pass through array\n**Space Complexity:** O(1) - constant extra space\n\n**Key Insights:**\n- Handle empty arrays with appropriate defaults\n- Consider both positive and negative numbers\n- Single pass optimization",
      "solution_code": "class Solution {\n    public int minimumPathSum(int[] nums) {\n        if (nums == null || nums.length == 0) return 0;\n        \n        int result = nums[0];\n        \n        for (int i = 1; i < nums.length; i++) {\n            if (\"minimumPathSum\".toLowerCase().contains(\"max\")) {\n                result = Math.max(result, nums[i]);\n            } else {\n                result = Math.min(result, nums[i]);\n            }\n        }\n        \n        return result;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "grid": [
          "[1",
          2,
          0
        ]
      },
      "output": 8
    },
    {
      "id": 2,
      "input": {
        "grid": [
          "[2",
          2
        ]
      },
      "output": 3
    }
  ]
}