{
  "filename": "minimum-stack",
  "title": "Minimum Stack",
  "keywords": [
    "minimum",
    "stack",
    "leetcode",
    "155",
    "min",
    "design",
    "class",
    "supports",
    "push",
    "pop"
  ],
  "description": "<h2>Minimum Stack</h2><p>Leetcode 155. Min Stack</p><p></p><p>Design a stack class that supports the `push`, `pop`, `top`, and `getMin` operations.</p><p></p><p>* `MinStack()` initializes the stack object.</p><p>* `void push(int val)` pushes the element `val` onto the stack.</p><p>* `void pop()` removes the element on the top of the stack.</p><p>* `int top()` gets the top element of the stack.</p><p>* `int getMin()` retrieves the minimum element in the stack.</p><p></p><p>Each function should run in $O(1)$ time.</p><h3>Examples:</h3><ul><li>Input: [\"MinStack\", \"push\", 1, \"push\", 2, \"push\", 0, \"getMin\", \"pop\", \"top\", \"getMin\"]<br><br>Output: [null,null,null,null,0,null,2,1]<br><br>Explanation:<br>MinStack minStack = new MinStack();<br>minStack.push(1);<br>minStack.push(2);<br>minStack.push(0);<br>minStack.getMin(); // return 0<br>minStack.pop();<br>minStack.top();    // return 2<br>minStack.getMin(); // return 1</li></ul><h3>Constraints:</h3><ul><li> `-2^31 <= val <= 2^31 - 1`.</li><li> `pop`, `top` and `getMin` will always be called on **non-empty** stacks.</li></ul>",
  "languages": {
    "python": {
      "template": "def minimumStack(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10):\n    ",
      "solution_text": "Min/Max finding algorithm:\n\n**Algorithm:**\n1. Initialize min/max with first element\n2. Iterate through remaining elements\n3. Update min/max as needed\n\n**Time Complexity:** O(n) - single pass through array\n**Space Complexity:** O(1) - constant extra space\n\n**Key Insights:**\n- Handle empty arrays with appropriate defaults\n- Consider both positive and negative numbers\n- Single pass optimization",
      "solution_code": "def minimumStack(nums):\n    if not nums:\n        return 0  # or appropriate default\n    \n    result = nums[0]\n    \n    for num in nums[1:]:\n        if 'max' in 'minimumStack'.lower():\n            result = max(result, num)\n        else:\n            result = min(result, num)\n    \n    return result"
    },
    "javascript": {
      "template": "function minimumStack(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10) {\n  \n}",
      "solution_text": "Min/Max finding algorithm:\n\n**Algorithm:**\n1. Initialize min/max with first element\n2. Iterate through remaining elements\n3. Update min/max as needed\n\n**Time Complexity:** O(n) - single pass through array\n**Space Complexity:** O(1) - constant extra space\n\n**Key Insights:**\n- Handle empty arrays with appropriate defaults\n- Consider both positive and negative numbers\n- Single pass optimization",
      "solution_code": "function minimumStack(nums) {\n    if (!nums || nums.length === 0) return 0;\n    \n    let result = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        if ('minimumStack'.toLowerCase().includes('max')) {\n            result = Math.max(result, nums[i]);\n        } else {\n            result = Math.min(result, nums[i]);\n        }\n    }\n    \n    return result;\n}"
    },
    "typescript": {
      "template": "function minimumStack(0: string, 1: string, 2: number, 3: string, 4: number, 5: string, 6: number, 7: string, 8: string, 9: string, 10: string): number[] {\n  \n}",
      "solution_text": "Min/Max finding algorithm:\n\n**Algorithm:**\n1. Initialize min/max with first element\n2. Iterate through remaining elements\n3. Update min/max as needed\n\n**Time Complexity:** O(n) - single pass through array\n**Space Complexity:** O(1) - constant extra space\n\n**Key Insights:**\n- Handle empty arrays with appropriate defaults\n- Consider both positive and negative numbers\n- Single pass optimization",
      "solution_code": "function minimumStack(nums: number[]): number {\n    if (!nums || nums.length === 0) return 0;\n    \n    let result = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        if ('minimumStack'.toLowerCase().includes('max')) {\n            result = Math.max(result, nums[i]);\n        } else {\n            result = Math.min(result, nums[i]);\n        }\n    }\n    \n    return result;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int[] minimumStack(String 0, String 1, int 2, String 3, int 4, String 5, int 6, String 7, String 8, String 9, String 10) {\n        \n    }\n}",
      "solution_text": "Min/Max finding algorithm:\n\n**Algorithm:**\n1. Initialize min/max with first element\n2. Iterate through remaining elements\n3. Update min/max as needed\n\n**Time Complexity:** O(n) - single pass through array\n**Space Complexity:** O(1) - constant extra space\n\n**Key Insights:**\n- Handle empty arrays with appropriate defaults\n- Consider both positive and negative numbers\n- Single pass optimization",
      "solution_code": "class Solution {\n    public int minimumStack(int[] nums) {\n        if (nums == null || nums.length == 0) return 0;\n        \n        int result = nums[0];\n        \n        for (int i = 1; i < nums.length; i++) {\n            if (\"minimumStack\".toLowerCase().contains(\"max\")) {\n                result = Math.max(result, nums[i]);\n            } else {\n                result = Math.min(result, nums[i]);\n            }\n        }\n        \n        return result;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": [
        "MinStack",
        "push",
        1,
        "push",
        2,
        "push",
        0,
        "getMin",
        "pop",
        "top",
        "getMin"
      ],
      "output": [
        null,
        null,
        null,
        null,
        0,
        null,
        2,
        1
      ]
    }
  ]
}