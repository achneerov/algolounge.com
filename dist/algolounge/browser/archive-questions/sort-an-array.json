{
  "filename": "sort-an-array",
  "title": "Sort an Array",
  "keywords": [
    "sort",
    "array",
    "leetcode",
    "912",
    "given",
    "integers",
    "nums",
    "ascending",
    "order",
    "return"
  ],
  "description": "<h2>Sort an Array</h2><p>Leetcode 912. Sort an Array</p><p></p><p>You are given an array of integers `nums`, sort the array in ascending order and return it.</p><p></p><p>You must solve the problem **without using any built-in functions** in `O(nlog(n))` time complexity and with the smallest space complexity possible.</p><h3>Examples:</h3><ul><li>Input: nums = [10,9,1,1,1,2,3,1]<br><br>Output: [1,1,1,1,2,3,9,10]</li><li>Input: nums = [5,10,2,1,3]<br><br>Output: [1,2,3,5,10]</li></ul><h3>Constraints:</h3><ul><li> `1 <= nums.length <= 50,000`.</li><li> `-50,000 <= nums[i] <= 50,000`</li></ul>",
  "languages": {
    "python": {
      "template": "def sortAnArray(nums):\n    ",
      "solution_text": "Efficient sorting algorithm implementation:\n\n**Algorithm:**\n1. Choose appropriate sorting algorithm based on constraints\n2. For general case, use optimized comparison-based sort\n3. Handle edge cases like empty arrays\n4. Maintain stability if required\n\n**Time Complexity:** O(n log n) - optimal for comparison-based sorting\n**Space Complexity:** O(log n) - recursion stack for quicksort/mergesort\n\n**Key Insights:**\n- Built-in sorts are highly optimized\n- Consider counting sort for limited range integers\n- Stable sorts preserve relative order of equal elements",
      "solution_code": "def sortAnArray(arr):\n    if not arr or len(arr) <= 1:\n        return arr\n    \n    # Use built-in optimized sort (Timsort)\n    return sorted(arr)\n    \n    # Alternative: in-place sorting\n    # arr.sort()\n    # return arr"
    },
    "javascript": {
      "template": "function sortAnArray(nums) {\n  \n}",
      "solution_text": "Efficient sorting algorithm implementation:\n\n**Algorithm:**\n1. Choose appropriate sorting algorithm based on constraints\n2. For general case, use optimized comparison-based sort\n3. Handle edge cases like empty arrays\n4. Maintain stability if required\n\n**Time Complexity:** O(n log n) - optimal for comparison-based sorting\n**Space Complexity:** O(log n) - recursion stack for quicksort/mergesort\n\n**Key Insights:**\n- Built-in sorts are highly optimized\n- Consider counting sort for limited range integers\n- Stable sorts preserve relative order of equal elements",
      "solution_code": "function sortAnArray(arr) {\n    if (!arr || arr.length <= 1) return arr;\n    \n    // Use built-in optimized sort\n    return [...arr].sort((a, b) => {\n        if (typeof a === 'number' && typeof b === 'number') {\n            return a - b;\n        }\n        return String(a).localeCompare(String(b));\n    });\n}"
    },
    "typescript": {
      "template": "function sortAnArray(nums: number[]): number[] {\n  \n}",
      "solution_text": "Efficient sorting algorithm implementation:\n\n**Algorithm:**\n1. Choose appropriate sorting algorithm based on constraints\n2. For general case, use optimized comparison-based sort\n3. Handle edge cases like empty arrays\n4. Maintain stability if required\n\n**Time Complexity:** O(n log n) - optimal for comparison-based sorting\n**Space Complexity:** O(log n) - recursion stack for quicksort/mergesort\n\n**Key Insights:**\n- Built-in sorts are highly optimized\n- Consider counting sort for limited range integers\n- Stable sorts preserve relative order of equal elements",
      "solution_code": "function sortAnArray(arr: any[]): any[] {\n    if (!arr || arr.length <= 1) return arr;\n    \n    // Use built-in optimized sort\n    return [...arr].sort((a, b) => {\n        if (typeof a === 'number' && typeof b === 'number') {\n            return a - b;\n        }\n        return String(a).localeCompare(String(b));\n    });\n}"
    },
    "java": {
      "template": "class Solution {\n    public int[] sortAnArray(int[] nums) {\n        \n    }\n}",
      "solution_text": "Efficient sorting algorithm implementation:\n\n**Algorithm:**\n1. Choose appropriate sorting algorithm based on constraints\n2. For general case, use optimized comparison-based sort\n3. Handle edge cases like empty arrays\n4. Maintain stability if required\n\n**Time Complexity:** O(n log n) - optimal for comparison-based sorting\n**Space Complexity:** O(log n) - recursion stack for quicksort/mergesort\n\n**Key Insights:**\n- Built-in sorts are highly optimized\n- Consider counting sort for limited range integers\n- Stable sorts preserve relative order of equal elements",
      "solution_code": "class Solution {\n    public int[] sortAnArray(int[] arr) {\n        if (arr == null || arr.length <= 1) return arr;\n        \n        // Create copy to avoid modifying original\n        int[] result = arr.clone();\n        \n        // Use built-in optimized sort (dual-pivot quicksort)\n        Arrays.sort(result);\n        \n        return result;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "nums": [
          10,
          9,
          1,
          1,
          1,
          2,
          3,
          1
        ]
      },
      "output": [
        1,
        1,
        1,
        1,
        2,
        3,
        9,
        10
      ]
    },
    {
      "id": 2,
      "input": {
        "nums": [
          5,
          10,
          2,
          1,
          3
        ]
      },
      "output": [
        1,
        2,
        3,
        5,
        10
      ]
    }
  ]
}