{
  "filename": "valid-sudoku",
  "title": "Valid Sudoku",
  "keywords": [
    "valid",
    "sudoku",
    "leetcode",
    "given",
    "board",
    "following",
    "rules",
    "followed",
    "each",
    "row"
  ],
  "description": "<h2>Valid Sudoku</h2><p>Leetcode 36. Valid Sudoku</p><p></p><p>You are given a `9 x 9` Sudoku board `board`. A Sudoku board is valid if the following rules are followed:</p><p></p><p>1. Each row must contain the digits `1-9` without duplicates.</p><p>2. Each column must contain the digits `1-9` without duplicates.</p><p>3. Each of the nine `3 x 3` sub-boxes of the grid must contain the digits `1-9` without duplicates.</p><p></p><p>Return `true` if the Sudoku board is valid, otherwise return `false`</p><p></p><p>Note: A board does not need to be full or be solvable to be valid.</p><h3>Examples:</h3><ul><li>Input: board = <br>[[\"1\",\"2\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\"],<br> [\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],<br> [\".\",\"9\",\"1\",\".\",\".\",\".\",\".\",\".\",\"3\"],<br> [\"5\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"4\"],<br> [\".\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"5\"],<br> [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],<br> [\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\"],<br> [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"8\"],<br> [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]<br><br>Output: false<br>There are two 1's in the top-left 3x3 sub-box.</li></ul><h3>Constraints:</h3><ul><li> `board.length == 9`</li><li> `board[i].length == 9`</li><li> `board[i][j]` is a digit `1-9` or `'.'`.</li></ul>",
  "languages": {
    "python": {
      "template": "def validSudoku(board):\n    ",
      "solution_text": "Parentheses validation using stack data structure:\n\n**Algorithm:**\n1. Use stack to track opening brackets\n2. For each character, if opening bracket, push to stack\n3. If closing bracket, check if matches top of stack\n4. String is valid if stack is empty at end\n\n**Time Complexity:** O(n) - single pass through string\n**Space Complexity:** O(n) - stack storage in worst case\n\n**Key Insights:**\n- Stack naturally handles nested structure\n- Early return false for unmatched closing brackets\n- Must check stack emptiness at end",
      "solution_code": "def validSudoku(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping:\n            # Closing bracket\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            # Opening bracket\n            stack.append(char)\n    \n    return len(stack) == 0"
    },
    "javascript": {
      "template": "function validSudoku(board) {\n  \n}",
      "solution_text": "Parentheses validation using stack data structure:\n\n**Algorithm:**\n1. Use stack to track opening brackets\n2. For each character, if opening bracket, push to stack\n3. If closing bracket, check if matches top of stack\n4. String is valid if stack is empty at end\n\n**Time Complexity:** O(n) - single pass through string\n**Space Complexity:** O(n) - stack storage in worst case\n\n**Key Insights:**\n- Stack naturally handles nested structure\n- Early return false for unmatched closing brackets\n- Must check stack emptiness at end",
      "solution_code": "function validSudoku(s) {\n    const stack = [];\n    const mapping = {')': '(', '}': '{', ']': '['};\n    \n    for (const char of s) {\n        if (char in mapping) {\n            // Closing bracket\n            if (stack.length === 0 || stack.pop() !== mapping[char]) {\n                return false;\n            }\n        } else {\n            // Opening bracket\n            stack.push(char);\n        }\n    }\n    \n    return stack.length === 0;\n}"
    },
    "typescript": {
      "template": "function validSudoku(board: number[]): string {\n  \n}",
      "solution_text": "Parentheses validation using stack data structure:\n\n**Algorithm:**\n1. Use stack to track opening brackets\n2. For each character, if opening bracket, push to stack\n3. If closing bracket, check if matches top of stack\n4. String is valid if stack is empty at end\n\n**Time Complexity:** O(n) - single pass through string\n**Space Complexity:** O(n) - stack storage in worst case\n\n**Key Insights:**\n- Stack naturally handles nested structure\n- Early return false for unmatched closing brackets\n- Must check stack emptiness at end",
      "solution_code": "function validSudoku(s: string): boolean {\n    const stack: string[] = [];\n    const mapping: {[key: string]: string} = {')': '(', '}': '{', ']': '['};\n    \n    for (const char of s) {\n        if (char in mapping) {\n            // Closing bracket\n            if (stack.length === 0 || stack.pop() !== mapping[char]) {\n                return false;\n            }\n        } else {\n            // Opening bracket\n            stack.push(char);\n        }\n    }\n    \n    return stack.length === 0;\n}"
    },
    "java": {
      "template": "class Solution {\n    public String validSudoku(int[] board) {\n        \n    }\n}",
      "solution_text": "Parentheses validation using stack data structure:\n\n**Algorithm:**\n1. Use stack to track opening brackets\n2. For each character, if opening bracket, push to stack\n3. If closing bracket, check if matches top of stack\n4. String is valid if stack is empty at end\n\n**Time Complexity:** O(n) - single pass through string\n**Space Complexity:** O(n) - stack storage in worst case\n\n**Key Insights:**\n- Stack naturally handles nested structure\n- Early return false for unmatched closing brackets\n- Must check stack emptiness at end",
      "solution_code": "class Solution {\n    public boolean validSudoku(String s) {\n        Stack<Character> stack = new Stack<>();\n        Map<Character, Character> mapping = new HashMap<>();\n        mapping.put(')', '(');\n        mapping.put('}', '{');\n        mapping.put(']', '[');\n        \n        for (char c : s.toCharArray()) {\n            if (mapping.containsKey(c)) {\n                // Closing bracket\n                if (stack.isEmpty() || stack.pop() != mapping.get(c)) {\n                    return false;\n                }\n            } else {\n                // Opening bracket\n                stack.push(c);\n            }\n        }\n        \n        return stack.isEmpty();\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "board": [
          "[\"1\"",
          "2",
          ".",
          ".",
          "3",
          ".",
          ".",
          ".",
          "."
        ]
      },
      "output": "false"
    }
  ]
}