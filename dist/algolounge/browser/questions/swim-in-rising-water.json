{
  "index": 86,
  "filename": "swim-in-rising-water",
  "title": "Swim in Rising Water",
  "keywords": [
    "swim",
    "rising",
    "water",
    "grid",
    "matrix",
    "dijkstra",
    "heap",
    "priority",
    "queue",
    "path",
    "minimum",
    "time"
  ],
  "description": "<h2>Swim in Rising Water</h2><p>LeetCode 778. Swim in Rising Water</p><p>You are given an <code>n x n</code> integer matrix <code>grid</code> where each value <code>grid[i][j]</code> represents the elevation at that point <code>(i, j)</code>.</p><p>The rain starts to fall. At time <code>t</code>, the depth of the water everywhere is <code>t</code>. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most <code>t</code>. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.</p><p>Return <em>the least time until you can reach the bottom right square <code>(n - 1, n - 1)</code> if you start at the top left square <code>(0, 0)</code></em>.</p><h3>Examples:</h3><ul><li>Input: grid = [[0,2],[1,3]]<br>Output: 3<br>Explanation:<br>At time 0, you are in grid location (0, 0).<br>You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than time 0.<br>You cannot reach point (1, 1) until time 3.<br>When the depth of water is 3, we can swim anywhere inside the grid.</li><li>Input: grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]<br>Output: 16<br>Explanation: The final route is shown.<br>We need to wait until time 16 so that (0, 0) and (4, 4) are connected.</li></ul><h3>Constraints:</h3><ul><li><code>n == grid.length == grid[i].length</code></li><li><code>1 &lt;= n &lt;= 50</code></li><li><code>0 &lt;= grid[i][j] &lt; n<sup>2</sup></code></li><li>Each value <code>grid[i][j]</code> is <strong>unique</strong></li></ul>",
  "entry_function": "swimInWater",
  "template": "def swimInWater(grid):\n    ",
  "solution_text": "<h3>Swim in Rising Water</h3><p><strong>Algorithm:</strong></p><ol><li>Use Dijkstra's algorithm with a min-heap to track minimum time needed to reach each cell</li><li>Start from (0, 0) with initial time equal to grid[0][0]</li><li>For each cell, try all 4 directions (up, down, left, right)</li><li>The time needed to reach a neighbor is the maximum of current time and neighbor's elevation</li><li>Use visited set to avoid processing cells multiple times</li><li>Return the time when we reach (n-1, n-1)</li></ol><p><strong>Time Complexity:</strong> O(n<sup>2</sup> log n) - each cell processed once, heap operations are O(log n<sup>2</sup>)</p><p><strong>Space Complexity:</strong> O(n<sup>2</sup>) - heap and visited set can contain all cells</p><p><strong>Key Insights:</strong></p><ul><li>This is a variant of shortest path problem where \"cost\" is maximum elevation encountered</li><li>Min-heap ensures we always explore the path with minimum time first</li><li>The answer is the maximum elevation on the optimal path from start to end</li><li>Cannot use simple BFS because we need to minimize the maximum elevation, not path length</li></ul>",
  "solution_code": "def swimInWater(grid):\n    import heapq\n    \n    n = len(grid)\n    visited = set()\n    min_heap = [(grid[0][0], 0, 0)]  # (time, row, col)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    while min_heap:\n        time, row, col = heapq.heappop(min_heap)\n        \n        # If we reached the destination\n        if row == n - 1 and col == n - 1:\n            return time\n        \n        # Skip if already visited\n        if (row, col) in visited:\n            continue\n        \n        visited.add((row, col))\n        \n        # Explore all 4 directions\n        for dr, dc in directions:\n            new_row, new_col = row + dr, col + dc\n            \n            # Check bounds and if not visited\n            if (0 <= new_row < n and 0 <= new_col < n and \n                (new_row, new_col) not in visited):\n                # Time needed is max of current time and neighbor's elevation\n                new_time = max(time, grid[new_row][new_col])\n                heapq.heappush(min_heap, (new_time, new_row, new_col))\n    \n    return -1  # Should never reach here with valid input",
  "prepare": "def prepare(test_case_input):\n    \"\"\"Prepare arguments for swimInWater function\"\"\"\n    return (test_case_input['grid'],)",
  "verify": "def verify(actual_output, expected_output):\n    \"\"\"Verify the swim in water result\"\"\"\n    passed = actual_output == expected_output\n    return [passed, str(actual_output)]",
  "test_cases": [
    {
      "id": 1,
      "input": {
        "grid": [
          [
            0,
            2
          ],
          [
            1,
            3
          ]
        ]
      },
      "output": 3
    },
    {
      "id": 2,
      "input": {
        "grid": [
          [
            0,
            1,
            2,
            3,
            4
          ],
          [
            24,
            23,
            22,
            21,
            5
          ],
          [
            12,
            13,
            14,
            15,
            16
          ],
          [
            11,
            17,
            18,
            19,
            20
          ],
          [
            10,
            9,
            8,
            7,
            6
          ]
        ]
      },
      "output": 16
    },
    {
      "id": 3,
      "input": {
        "grid": [
          [
            0
          ]
        ]
      },
      "output": 0
    },
    {
      "id": 4,
      "input": {
        "grid": [
          [
            0,
            1
          ],
          [
            2,
            3
          ]
        ]
      },
      "output": 3
    },
    {
      "id": 5,
      "input": {
        "grid": [
          [
            3,
            2
          ],
          [
            0,
            1
          ]
        ]
      },
      "output": 3
    },
    {
      "id": 6,
      "input": {
        "grid": [
          [
            0,
            1,
            2
          ],
          [
            5,
            4,
            3
          ],
          [
            6,
            7,
            8
          ]
        ]
      },
      "output": 8
    },
    {
      "id": 7,
      "input": {
        "grid": [
          [
            10,
            12,
            4,
            6
          ],
          [
            9,
            11,
            3,
            5
          ],
          [
            1,
            7,
            13,
            8
          ],
          [
            2,
            0,
            15,
            14
          ]
        ]
      },
      "output": 14
    },
    {
      "id": 8,
      "input": {
        "grid": [
          [
            0,
            2,
            5
          ],
          [
            1,
            4,
            8
          ],
          [
            3,
            6,
            7
          ]
        ]
      },
      "output": 7
    }
  ]
}
