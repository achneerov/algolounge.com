{
  "filename": "combinations",
  "title": "Combinations",
  "keywords": [
    "combinations",
    "leetcode",
    "given",
    "two",
    "integers",
    "return",
    "all",
    "possible",
    "numbers",
    "chosen"
  ],
  "description": "<h2>Combinations</h2><p>Leetcode 77. Combinations</p><p></p><p>You are given two integers `n` and `k`, return all possible **combinations** of `k` numbers chosen from the range `[1, n]`.</p><p></p><p>You may return the answer in **any order**.</p><h3>Examples:</h3><ul><li>Input: n = 3, k = 2<br><br>Output: [<br>    [1,2],<br>    [1,3],<br>    [2,3]<br>]</li><li>Input: n = 3, k = 3<br><br>Output: [[1,2,3]]</li></ul><h3>Constraints:</h3><ul><li> `1 <= k <= n <= 20`</li></ul>",
  "languages": {
    "python": {
      "template": "def combinations(n, k):\n    ",
      "solution_text": "<h3>Combinations Solution</h3><p><strong>Algorithm:</strong> Backtracking approach to generate all possible combinations of k numbers from range [1, n].</p><p><strong>Time Complexity:</strong> O(C(n,k)) where C(n,k) is the number of combinations</p><p><strong>Space Complexity:</strong> O(k) for recursion depth and current combination</p><p><strong>Key Insights:</strong></p><ul><li>Use backtracking to build combinations incrementally</li><li>Start from number 1 and try each possible number</li><li>Avoid duplicates by only considering numbers greater than the last added</li><li>Backtrack when combination reaches size k</li></ul>",
      "solution_code": "def combinations(n, k):\n    result = []\n    \n    def backtrack(start, current_combination):\n        # Base case: we have k numbers in our combination\n        if len(current_combination) == k:\n            result.append(current_combination[:])\n            return\n        \n        # Try each number from start to n\n        for num in range(start, n + 1):\n            current_combination.append(num)\n            backtrack(num + 1, current_combination)  # Start from num + 1 to avoid duplicates\n            current_combination.pop()  # Backtrack\n    \n    backtrack(1, [])\n    return result"
    },
    "javascript": {
      "template": "function combinations(n, k) {\n  \n}",
      "solution_text": "<h3>Combinations Solution</h3><p><strong>Algorithm:</strong> Backtracking approach to generate all possible combinations of k numbers from range [1, n].</p><p><strong>Time Complexity:</strong> O(C(n,k)) where C(n,k) is the number of combinations</p><p><strong>Space Complexity:</strong> O(k) for recursion depth and current combination</p><p><strong>Key Insights:</strong></p><ul><li>Use backtracking to build combinations incrementally</li><li>Start from number 1 and try each possible number</li><li>Avoid duplicates by only considering numbers greater than the last added</li><li>Backtrack when combination reaches size k</li></ul>",
      "solution_code": "function combinations(n, k) {\n    const result = [];\n    \n    function backtrack(start, currentCombination) {\n        // Base case: we have k numbers in our combination\n        if (currentCombination.length === k) {\n            result.push([...currentCombination]);\n            return;\n        }\n        \n        // Try each number from start to n\n        for (let num = start; num <= n; num++) {\n            currentCombination.push(num);\n            backtrack(num + 1, currentCombination); // Start from num + 1 to avoid duplicates\n            currentCombination.pop(); // Backtrack\n        }\n    }\n    \n    backtrack(1, []);\n    return result;\n}"
    },
    "typescript": {
      "template": "function combinations(n: number, k: number): number[][] {\n  \n}",
      "solution_text": "<h3>Combinations Solution</h3><p><strong>Algorithm:</strong> Backtracking approach to generate all possible combinations of k numbers from range [1, n].</p><p><strong>Time Complexity:</strong> O(C(n,k)) where C(n,k) is the number of combinations</p><p><strong>Space Complexity:</strong> O(k) for recursion depth and current combination</p><p><strong>Key Insights:</strong></p><ul><li>Use backtracking to build combinations incrementally</li><li>Start from number 1 and try each possible number</li><li>Avoid duplicates by only considering numbers greater than the last added</li><li>Backtrack when combination reaches size k</li></ul>",
      "solution_code": "function combinations(n: number, k: number): number[][] {\n    const result: number[][] = [];\n    \n    function backtrack(start: number, currentCombination: number[]): void {\n        // Base case: we have k numbers in our combination\n        if (currentCombination.length === k) {\n            result.push([...currentCombination]);\n            return;\n        }\n        \n        // Try each number from start to n\n        for (let num = start; num <= n; num++) {\n            currentCombination.push(num);\n            backtrack(num + 1, currentCombination); // Start from num + 1 to avoid duplicates\n            currentCombination.pop(); // Backtrack\n        }\n    }\n    \n    backtrack(1, []);\n    return result;\n}"
    },
    "java": {
      "template": "class Solution {\n    public List<List<Integer>> combinations(int n, int k) {\n        \n    }\n}",
      "solution_text": "<h3>Combinations Solution</h3><p><strong>Algorithm:</strong> Backtracking approach to generate all possible combinations of k numbers from range [1, n].</p><p><strong>Time Complexity:</strong> O(C(n,k)) where C(n,k) is the number of combinations</p><p><strong>Space Complexity:</strong> O(k) for recursion depth and current combination</p><p><strong>Key Insights:</strong></p><ul><li>Use backtracking to build combinations incrementally</li><li>Start from number 1 and try each possible number</li><li>Avoid duplicates by only considering numbers greater than the last added</li><li>Backtrack when combination reaches size k</li></ul>",
      "solution_code": "class Solution {\n    public List<List<Integer>> combinations(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        backtrack(result, new ArrayList<>(), 1, n, k);\n        return result;\n    }\n    \n    private void backtrack(List<List<Integer>> result, List<Integer> currentCombination, \n                          int start, int n, int k) {\n        // Base case: we have k numbers in our combination\n        if (currentCombination.size() == k) {\n            result.add(new ArrayList<>(currentCombination));\n            return;\n        }\n        \n        // Try each number from start to n\n        for (int num = start; num <= n; num++) {\n            currentCombination.add(num);\n            backtrack(result, currentCombination, num + 1, n, k); // Start from num + 1 to avoid duplicates\n            currentCombination.remove(currentCombination.size() - 1); // Backtrack\n        }\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "n": 3,
        "k": 2
      },
      "output": [[1,2],[1,3],[2,3]]
    },
    {
      "id": 2,
      "input": {
        "n": 3,
        "k": 3
      },
      "output": [
        [
          1,
          2,
          3
        ]
      ]
    }
  ]
}