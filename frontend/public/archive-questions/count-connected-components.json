{
  "filename": "count-connected-components",
  "title": "Number of Connected Components in an Undirected Graph",
  "keywords": [
    "number",
    "connected",
    "components",
    "undirected",
    "graph",
    "leetcode",
    "323",
    "there",
    "nodes",
    "also"
  ],
  "description": "<h2>Number of Connected Components in an Undirected Graph</h2><p>Leetcode 323. Number of Connected Components In An Undirected Graph</p><p></p><p>There is an undirected graph with `n` nodes. There is also an `edges` array, where `edges[i] = [a, b]` means that there is an edge between node `a` and node `b` in the graph.</p><p></p><p>The nodes are numbered from `0` to `n - 1`.</p><p></p><p>Return the total number of connected components in that graph.</p><h3>Examples:</h3><ul><li>Input:<br>n=3<br>edges=[[0,1], [0,2]]<br><br>Output:<br>1</li><li>Input:<br>n=6<br>edges=[[0,1], [1,2], [2,3], [4,5]]<br><br>Output:<br>2</li></ul><h3>Constraints:</h3><ul><li> `1 <= n <= 100`</li><li> `0 <= edges.length <= n * (n - 1) / 2`</li></ul>",
  "languages": {
    "python": {
      "template": "def numberOfConnectedComponentsInAnUndirectedGraph(n, edges):\n    ",
      "solution_text": "<p><strong>Union-Find Solution for Connected Components:</strong></p><p>Count connected components in undirected graph using Union-Find data structure.</p><p><strong>Algorithm:</strong></p><ol><li>Initialize Union-Find with n components</li><li>For each edge, union the two nodes</li><li>Count remaining components</li></ol><p><strong>Time Complexity:</strong> O(E × α(n)) where α is inverse Ackermann</p><p><strong>Space Complexity:</strong> O(n) for parent array</p>",
      "solution_code": "def numberOfConnectedComponentsInAnUndirectedGraph(n, edges):\n    # Union-Find data structure\n    def find(parent, x):\n        if parent[x] != x:\n            parent[x] = find(parent, parent[x])  # Path compression\n        return parent[x]\n    \n    def union(parent, rank, x, y):\n        px, py = find(parent, x), find(parent, y)\n        if px == py:\n            return False\n        \n        # Union by rank\n        if rank[px] < rank[py]:\n            parent[px] = py\n        elif rank[px] > rank[py]:\n            parent[py] = px\n        else:\n            parent[py] = px\n            rank[px] += 1\n        return True\n    \n    # Initialize parent and rank arrays\n    parent = list(range(n))\n    rank = [0] * n\n    components = n\n    \n    # Process all edges\n    for u, v in edges:\n        if union(parent, rank, u, v):\n            components -= 1\n    \n    return components"
    },
    "javascript": {
      "template": "function numberOfConnectedComponentsInAnUndirectedGraph(n, edges) {\n  \n}",
      "solution_text": "<p><strong>Union-Find Solution for Connected Components:</strong></p><p>Count connected components in undirected graph using Union-Find data structure.</p><p><strong>Algorithm:</strong></p><ol><li>Initialize Union-Find with n components</li><li>For each edge, union the two nodes</li><li>Count remaining components</li></ol><p><strong>Time Complexity:</strong> O(E × α(n)) where α is inverse Ackermann</p><p><strong>Space Complexity:</strong> O(n) for parent array</p>",
      "solution_code": "function numberOfConnectedComponentsInAnUndirectedGraph(n, edges) {\n    // Union-Find helper functions\n    function find(parent, x) {\n        if (parent[x] !== x) {\n            parent[x] = find(parent, parent[x]); // Path compression\n        }\n        return parent[x];\n    }\n    \n    function union(parent, rank, x, y) {\n        const px = find(parent, x);\n        const py = find(parent, y);\n        if (px === py) {\n            return false;\n        }\n        \n        // Union by rank\n        if (rank[px] < rank[py]) {\n            parent[px] = py;\n        } else if (rank[px] > rank[py]) {\n            parent[py] = px;\n        } else {\n            parent[py] = px;\n            rank[px]++;\n        }\n        return true;\n    }\n    \n    // Initialize parent and rank arrays\n    const parent = Array.from({length: n}, (_, i) => i);\n    const rank = new Array(n).fill(0);\n    let components = n;\n    \n    // Process all edges\n    for (const [u, v] of edges) {\n        if (union(parent, rank, u, v)) {\n            components--;\n        }\n    }\n    \n    return components;\n}"
    },
    "typescript": {
      "template": "function numberOfConnectedComponentsInAnUndirectedGraph(n: number, edges: number[][]): number {\n  \n}",
      "solution_text": "<p><strong>Union-Find Solution for Connected Components:</strong></p><p>Count connected components in undirected graph using Union-Find data structure.</p><p><strong>Algorithm:</strong></p><ol><li>Initialize Union-Find with n components</li><li>For each edge, union the two nodes</li><li>Count remaining components</li></ol><p><strong>Time Complexity:</strong> O(E × α(n)) where α is inverse Ackermann</p><p><strong>Space Complexity:</strong> O(n) for parent array</p>",
      "solution_code": "function numberOfConnectedComponentsInAnUndirectedGraph(n: number, edges: number[][]): number {\n    // Union-Find helper functions\n    function find(parent: number[], x: number): number {\n        if (parent[x] !== x) {\n            parent[x] = find(parent, parent[x]); // Path compression\n        }\n        return parent[x];\n    }\n    \n    function union(parent: number[], rank: number[], x: number, y: number): boolean {\n        const px = find(parent, x);\n        const py = find(parent, y);\n        if (px === py) {\n            return false;\n        }\n        \n        // Union by rank\n        if (rank[px] < rank[py]) {\n            parent[px] = py;\n        } else if (rank[px] > rank[py]) {\n            parent[py] = px;\n        } else {\n            parent[py] = px;\n            rank[px]++;\n        }\n        return true;\n    }\n    \n    // Initialize parent and rank arrays\n    const parent: number[] = Array.from({length: n}, (_, i) => i);\n    const rank: number[] = new Array(n).fill(0);\n    let components = n;\n    \n    // Process all edges\n    for (const [u, v] of edges) {\n        if (union(parent, rank, u, v)) {\n            components--;\n        }\n    }\n    \n    return components;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int numberOfConnectedComponentsInAnUndirectedGraph(int n, int[][] edges) {\n        \n    }\n}",
      "solution_text": "<p><strong>Union-Find Solution for Connected Components:</strong></p><p>Count connected components in undirected graph using Union-Find data structure.</p><p><strong>Algorithm:</strong></p><ol><li>Initialize Union-Find with n components</li><li>For each edge, union the two nodes</li><li>Count remaining components</li></ol><p><strong>Time Complexity:</strong> O(E × α(n)) where α is inverse Ackermann</p><p><strong>Space Complexity:</strong> O(n) for parent array</p>",
      "solution_code": "class Solution {\n    private int find(int[] parent, int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent, parent[x]); // Path compression\n        }\n        return parent[x];\n    }\n    \n    private boolean union(int[] parent, int[] rank, int x, int y) {\n        int px = find(parent, x);\n        int py = find(parent, y);\n        if (px == py) {\n            return false;\n        }\n        \n        // Union by rank\n        if (rank[px] < rank[py]) {\n            parent[px] = py;\n        } else if (rank[px] > rank[py]) {\n            parent[py] = px;\n        } else {\n            parent[py] = px;\n            rank[px]++;\n        }\n        return true;\n    }\n    \n    public int numberOfConnectedComponentsInAnUndirectedGraph(int n, int[][] edges) {\n        // Initialize parent and rank arrays\n        int[] parent = new int[n];\n        int[] rank = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n        \n        int components = n;\n        \n        // Process all edges\n        for (int[] edge : edges) {\n            if (union(parent, rank, edge[0], edge[1])) {\n                components--;\n            }\n        }\n        \n        return components;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "n": 3,
        "edges": [[0, 1], [0, 2]]
      },
      "output": 1
    },
    {
      "id": 2,
      "input": {
        "n": 6,
        "edges": [[0, 1], [1, 2], [2, 3], [4, 5]]
      },
      "output": 2
    },
    {
      "id": 3,
      "input": {
        "n": 5,
        "edges": []
      },
      "output": 5
    },
    {
      "id": 4,
      "input": {
        "n": 1,
        "edges": []
      },
      "output": 1
    },
    {
      "id": 5,
      "input": {
        "n": 4,
        "edges": [[0, 1], [2, 3]]
      },
      "output": 2
    },
    {
      "id": 6,
      "input": {
        "n": 4,
        "edges": [[0, 1], [1, 2], [2, 3]]
      },
      "output": 1
    },
    {
      "id": 7,
      "input": {
        "n": 7,
        "edges": [[0, 1], [1, 2], [3, 4], [5, 6]]
      },
      "output": 3
    },
    {
      "id": 8,
      "input": {
        "n": 2,
        "edges": [[0, 1]]
      },
      "output": 1
    },
    {
      "id": 9,
      "input": {
        "n": 10,
        "edges": [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]
      },
      "output": 5
    },
    {
      "id": 10,
      "input": {
        "n": 8,
        "edges": [[0, 1], [1, 2], [1, 3], [4, 5], [5, 6], [5, 7]]
      },
      "output": 2
    }
  ]
}