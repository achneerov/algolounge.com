{
  "filename": "count-good-nodes-in-binary-tree",
  "title": "Count Good Nodes in Binary Tree",
  "keywords": [
    "count",
    "good",
    "nodes",
    "binary",
    "tree",
    "leetcode",
    "1448",
    "within",
    "node",
    "considered"
  ],
  "description": "<h2>Count Good Nodes in Binary Tree</h2><p>Leetcode 1448. Count Good Nodes In Binary Tree</p><p></p><p>Within a binary tree, a node `x` is considered **good** if the path from the root of the tree to the node `x` contains no nodes with a value greater than the value of node `x`</p><p></p><p>Given the root of a binary tree `root`, return the number of **good** nodes within the tree.</p><h3>Examples:</h3><ul><li>Input: root = [1,2,-1,3,4]<br><br>Output: 4</li></ul><h3>Constraints:</h3><ul><li> `1 <= number of nodes in the tree <= 100`</li><li> `-100 <= Node.val <= 100`</li></ul>",
  "languages": {
    "python": {
      "template": "def countGoodNodesInBinaryTree(root):\n    ",
      "solution_text": "<h3>Count Good Nodes in Binary Tree</h3><p><strong>Algorithm:</strong></p><ol><li>Traverse the tree using DFS, tracking the maximum value seen so far on the path</li><li>At each node, check if current node value >= maximum value on path</li><li>If yes, increment count and update maximum for children</li><li>Recursively process left and right subtrees with updated maximum</li><li>Return total count of good nodes</li></ol><p><strong>Time Complexity:</strong> O(n) - visit each node once</p><p><strong>Space Complexity:</strong> O(h) - recursion stack depth where h is tree height</p><p><strong>Key Insights:</strong></p><ul><li>A node is good if no ancestor has a greater value</li><li>Track maximum value along path from root to current node</li><li>Root is always good (no ancestors)</li></ul>",
      "solution_code": "def countGoodNodesInBinaryTree(root):\n    def dfs(node, max_val):\n        if not node:\n            return 0\n        \n        # Count current node if it's good (>= max value seen so far)\n        count = 1 if node.val >= max_val else 0\n        \n        # Update max value for children\n        new_max = max(max_val, node.val)\n        \n        # Recursively count good nodes in left and right subtrees\n        count += dfs(node.left, new_max)\n        count += dfs(node.right, new_max)\n        \n        return count\n    \n    return dfs(root, float('-inf')) if root else 0"
    },
    "javascript": {
      "template": "function countGoodNodesInBinaryTree(root) {\n  \n}",
      "solution_text": "<h3>Count Good Nodes in Binary Tree</h3><p><strong>Algorithm:</strong></p><ol><li>Traverse the tree using DFS, tracking the maximum value seen so far on the path</li><li>At each node, check if current node value >= maximum value on path</li><li>If yes, increment count and update maximum for children</li><li>Recursively process left and right subtrees with updated maximum</li><li>Return total count of good nodes</li></ol><p><strong>Time Complexity:</strong> O(n) - visit each node once</p><p><strong>Space Complexity:</strong> O(h) - recursion stack depth where h is tree height</p><p><strong>Key Insights:</strong></p><ul><li>A node is good if no ancestor has a greater value</li><li>Track maximum value along path from root to current node</li><li>Root is always good (no ancestors)</li></ul>",
      "solution_code": "function countGoodNodesInBinaryTree(root) {\n    function dfs(node, maxVal) {\n        if (!node) return 0;\n        \n        // Count current node if it's good (>= max value seen so far)\n        let count = node.val >= maxVal ? 1 : 0;\n        \n        // Update max value for children\n        const newMax = Math.max(maxVal, node.val);\n        \n        // Recursively count good nodes in left and right subtrees\n        count += dfs(node.left, newMax);\n        count += dfs(node.right, newMax);\n        \n        return count;\n    }\n    \n    return root ? dfs(root, -Infinity) : 0;\n}"
    },
    "typescript": {
      "template": "function countGoodNodesInBinaryTree(root: TreeNode | null): number {\n  \n}",
      "solution_text": "<h3>Count Good Nodes in Binary Tree</h3><p><strong>Algorithm:</strong></p><ol><li>Traverse the tree using DFS, tracking the maximum value seen so far on the path</li><li>At each node, check if current node value >= maximum value on path</li><li>If yes, increment count and update maximum for children</li><li>Recursively process left and right subtrees with updated maximum</li><li>Return total count of good nodes</li></ol><p><strong>Time Complexity:</strong> O(n) - visit each node once</p><p><strong>Space Complexity:</strong> O(h) - recursion stack depth where h is tree height</p><p><strong>Key Insights:</strong></p><ul><li>A node is good if no ancestor has a greater value</li><li>Track maximum value along path from root to current node</li><li>Root is always good (no ancestors)</li></ul>",
      "solution_code": "function countGoodNodesInBinaryTree(root: TreeNode | null): number {\n    function dfs(node: TreeNode | null, maxVal: number): number {\n        if (!node) return 0;\n        \n        // Count current node if it's good (>= max value seen so far)\n        let count = node.val >= maxVal ? 1 : 0;\n        \n        // Update max value for children\n        const newMax = Math.max(maxVal, node.val);\n        \n        // Recursively count good nodes in left and right subtrees\n        count += dfs(node.left, newMax);\n        count += dfs(node.right, newMax);\n        \n        return count;\n    }\n    \n    return root ? dfs(root, -Infinity) : 0;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int countGoodNodesInBinaryTree(TreeNode root) {\n        \n    }\n}",
      "solution_text": "<h3>Count Good Nodes in Binary Tree</h3><p><strong>Algorithm:</strong></p><ol><li>Traverse the tree using DFS, tracking the maximum value seen so far on the path</li><li>At each node, check if current node value >= maximum value on path</li><li>If yes, increment count and update maximum for children</li><li>Recursively process left and right subtrees with updated maximum</li><li>Return total count of good nodes</li></ol><p><strong>Time Complexity:</strong> O(n) - visit each node once</p><p><strong>Space Complexity:</strong> O(h) - recursion stack depth where h is tree height</p><p><strong>Key Insights:</strong></p><ul><li>A node is good if no ancestor has a greater value</li><li>Track maximum value along path from root to current node</li><li>Root is always good (no ancestors)</li></ul>",
      "solution_code": "class Solution {\n    public int countGoodNodesInBinaryTree(TreeNode root) {\n        return root != null ? dfs(root, Integer.MIN_VALUE) : 0;\n    }\n    \n    private int dfs(TreeNode node, int maxVal) {\n        if (node == null) return 0;\n        \n        // Count current node if it's good (>= max value seen so far)\n        int count = node.val >= maxVal ? 1 : 0;\n        \n        // Update max value for children\n        int newMax = Math.max(maxVal, node.val);\n        \n        // Recursively count good nodes in left and right subtrees\n        count += dfs(node.left, newMax);\n        count += dfs(node.right, newMax);\n        \n        return count;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "root": [
          1,
          2,
          -1,
          3,
          4
        ]
      },
      "output": 4
    }
  ]
}