{
  "filename": "counting-bits",
  "title": "Counting Bits",
  "keywords": [
    "counting",
    "bits",
    "leetcode",
    "338",
    "given",
    "integer",
    "count",
    "number",
    "binary",
    "representation"
  ],
  "description": "<h2>Counting Bits</h2><p>Leetcode 338. Counting Bits</p><p></p><p>Given an integer `n`, count the number of `1`'s in the binary representation of every number in the range `[0, n]`.</p><p>    </p><p>Return an array `output` where `output[i]` is the number of `1`'s in the binary representation of `i`.</p><h3>Examples:</h3><ul><li>Input: n = 4<br><br>Output: [0,1,1,2,1]<br>0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100</li></ul><h3>Constraints:</h3><ul><li> `0 <= n <= 1000`</li></ul>",
  "languages": {
    "python": {
      "template": "def countingBits(n):\n    ",
      "solution_text": "<p><strong>Dynamic Programming Solution for Counting Bits:</strong></p><p>This problem asks us to compute the number of set bits (1s) for all integers from 0 to <code>n</code>. A dynamic programming approach is highly efficient for this.</p><p><strong>Algorithm:</strong></p><ol><li>Initialize an array, let's call it <code>ans</code>, of size <code>n + 1</code> with all elements set to 0. This array will store our results.</li><li>The base case is <code>ans[0] = 0</code>, as the number 0 has zero set bits.</li><li>Iterate from <code>i = 1</code> to <code>n</code>. For each number <code>i</code>, we can calculate the number of set bits by using the result of a previously computed smaller number.</li><li>The key insight is the relationship between the number of set bits in <code>i</code> and <code>i / 2</code> (or <code>i >> 1</code> in bitwise operations).<ul><li>The bits of <code>i</code> are the same as the bits of <code>i / 2</code>, just shifted to the left by one position.</li><li>A new least significant bit is added.</li></ul></li><li>This gives us the recurrence relation: <code>ans[i] = ans[i >> 1] + (i & 1)</code>.<ul><li><code>i >> 1</code> is the integer division of <code>i</code> by 2, effectively dropping the last bit. The count of set bits for this number is already computed as <code>ans[i >> 1]</code>.</li><li><code>i & 1</code> gives us the last bit of <code>i</code> (it's 1 if <code>i</code> is odd, and 0 if <code>i</code> is even).</li></ul></li><li>By adding these two parts, we get the total number of set bits for <code>i</code>.</li></ol><p><strong>Time Complexity:</strong> O(n), as we iterate from 0 to n once.</p><p><strong>Space Complexity:</strong> O(n), for the output array. If we don't count the output array, it's O(1).</p>",
      "solution_code": "def countingBits(n):\n    ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        ans[i] = ans[i >> 1] + (i & 1)\n    return ans"
    },
    "javascript": {
      "template": "function countingBits(n) {\n  \n}",
      "solution_text": "<p><strong>Dynamic Programming Solution for Counting Bits:</strong></p><p>This problem asks us to compute the number of set bits (1s) for all integers from 0 to <code>n</code>. A dynamic programming approach is highly efficient for this.</p><p><strong>Algorithm:</strong></p><ol><li>Initialize an array, let's call it <code>ans</code>, of size <code>n + 1</code> with all elements set to 0. This array will store our results.</li><li>The base case is <code>ans[0] = 0</code>, as the number 0 has zero set bits.</li><li>Iterate from <code>i = 1</code> to <code>n</code>. For each number <code>i</code>, we can calculate the number of set bits by using the result of a previously computed smaller number.</li><li>The key insight is the relationship between the number of set bits in <code>i</code> and <code>i / 2</code> (or <code>i >> 1</code> in bitwise operations).<ul><li>The bits of <code>i</code> are the same as the bits of <code>i / 2</code>, just shifted to the left by one position.</li><li>A new least significant bit is added.</li></ul></li><li>This gives us the recurrence relation: <code>ans[i] = ans[i >> 1] + (i & 1)</code>.<ul><li><code>i >> 1</code> is the integer division of <code>i</code> by 2, effectively dropping the last bit. The count of set bits for this number is already computed as <code>ans[i >> 1]</code>.</li><li><code>i & 1</code> gives us the last bit of <code>i</code> (it's 1 if <code>i</code> is odd, and 0 if <code>i</code> is even).</li></ul></li><li>By adding these two parts, we get the total number of set bits for <code>i</code>.</li></ol><p><strong>Time Complexity:</strong> O(n), as we iterate from 0 to n once.</p><p><strong>Space Complexity:</strong> O(n), for the output array. If we don't count the output array, it's O(1).</p>",
      "solution_code": "function countingBits(n) {\n    const ans = new Array(n + 1).fill(0);\n    for (let i = 1; i <= n; i++) {\n        ans[i] = ans[i >> 1] + (i & 1);\n    }\n    return ans;\n}"
    },
    "typescript": {
      "template": "function countingBits(n: number): number[] {\n  \n}",
      "solution_text": "<p><strong>Dynamic Programming Solution for Counting Bits:</strong></p><p>This problem asks us to compute the number of set bits (1s) for all integers from 0 to <code>n</code>. A dynamic programming approach is highly efficient for this.</p><p><strong>Algorithm:</strong></p><ol><li>Initialize an array, let's call it <code>ans</code>, of size <code>n + 1</code> with all elements set to 0. This array will store our results.</li><li>The base case is <code>ans[0] = 0</code>, as the number 0 has zero set bits.</li><li>Iterate from <code>i = 1</code> to <code>n</code>. For each number <code>i</code>, we can calculate the number of set bits by using the result of a previously computed smaller number.</li><li>The key insight is the relationship between the number of set bits in <code>i</code> and <code>i / 2</code> (or <code>i >> 1</code> in bitwise operations).<ul><li>The bits of <code>i</code> are the same as the bits of <code>i / 2</code>, just shifted to the left by one position.</li><li>A new least significant bit is added.</li></ul></li><li>This gives us the recurrence relation: <code>ans[i] = ans[i >> 1] + (i & 1)</code>.<ul><li><code>i >> 1</code> is the integer division of <code>i</code> by 2, effectively dropping the last bit. The count of set bits for this number is already computed as <code>ans[i >> 1]</code>.</li><li><code>i & 1</code> gives us the last bit of <code>i</code> (it's 1 if <code>i</code> is odd, and 0 if <code>i</code> is even).</li></ul></li><li>By adding these two parts, we get the total number of set bits for <code>i</code>.</li></ol><p><strong>Time Complexity:</strong> O(n), as we iterate from 0 to n once.</p><p><strong>Space Complexity:</strong> O(n), for the output array. If we don't count the output array, it's O(1).</p>",
      "solution_code": "function countingBits(n: number): number[] {\n    const ans = new Array(n + 1).fill(0);\n    for (let i = 1; i <= n; i++) {\n        ans[i] = ans[i >> 1] + (i & 1);\n    }\n    return ans;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int[] countingBits(int n) {\n        \n    }\n}",
      "solution_text": "<p><strong>Dynamic Programming Solution for Counting Bits:</strong></p><p>This problem asks us to compute the number of set bits (1s) for all integers from 0 to <code>n</code>. A dynamic programming approach is highly efficient for this.</p><p><strong>Algorithm:</strong></p><ol><li>Initialize an array, let's call it <code>ans</code>, of size <code>n + 1</code> with all elements set to 0. This array will store our results.</li><li>The base case is <code>ans[0] = 0</code>, as the number 0 has zero set bits.</li><li>Iterate from <code>i = 1</code> to <code>n</code>. For each number <code>i</code>, we can calculate the number of set bits by using the result of a previously computed smaller number.</li><li>The key insight is the relationship between the number of set bits in <code>i</code> and <code>i / 2</code> (or <code>i >> 1</code> in bitwise operations).<ul><li>The bits of <code>i</code> are the same as the bits of <code>i / 2</code>, just shifted to the left by one position.</li><li>A new least significant bit is added.</li></ul></li><li>This gives us the recurrence relation: <code>ans[i] = ans[i >> 1] + (i & 1)</code>.<ul><li><code>i >> 1</code> is the integer division of <code>i</code> by 2, effectively dropping the last bit. The count of set bits for this number is already computed as <code>ans[i >> 1]</code>.</li><li><code>i & 1</code> gives us the last bit of <code>i</code> (it's 1 if <code>i</code> is odd, and 0 if <code>i</code> is even).</li></ul></li><li>By adding these two parts, we get the total number of set bits for <code>i</code>.</li></ol><p><strong>Time Complexity:</strong> O(n), as we iterate from 0 to n once.</p><p><strong>Space Complexity:</strong> O(n), for the output array. If we don't count the output array, it's O(1).</p>",
      "solution_code": "class Solution {\n    public int[] countingBits(int n) {\n        int[] ans = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            ans[i] = ans[i >> 1] + (i & 1);\n        }\n        return ans;\n    }\n}"
    }
  },
  "order_matters": true,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "n": 0
      },
      "output": [
        0
      ]
    },
    {
      "id": 2,
      "input": {
        "n": 1
      },
      "output": [
        0,
        1
      ]
    },
    {
      "id": 3,
      "input": {
        "n": 2
      },
      "output": [
        0,
        1,
        1
      ]
    },
    {
      "id": 4,
      "input": {
        "n": 3
      },
      "output": [
        0,
        1,
        1,
        2
      ]
    },
    {
      "id": 5,
      "input": {
        "n": 4
      },
      "output": [
        0,
        1,
        1,
        2,
        1
      ]
    },
    {
      "id": 6,
      "input": {
        "n": 5
      },
      "output": [
        0,
        1,
        1,
        2,
        1,
        2
      ]
    },
    {
      "id": 7,
      "input": {
        "n": 8
      },
      "output": [
        0,
        1,
        1,
        2,
        1,
        2,
        2,
        3,
        1
      ]
    },
    {
      "id": 8,
      "input": {
        "n": 10
      },
      "output": [
        0,
        1,
        1,
        2,
        1,
        2,
        2,
        3,
        1,
        2,
        2
      ]
    },
    {
      "id": 9,
      "input": {
        "n": 15
      },
      "output": [
        0,
        1,
        1,
        2,
        1,
        2,
        2,
        3,
        1,
        2,
        2,
        3,
        2,
        3,
        3,
        4
      ]
    },
    {
      "id": 10,
      "input": {
        "n": 16
      },
      "output": [
        0,
        1,
        1,
        2,
        1,
        2,
        2,
        3,
        1,
        2,
        2,
        3,
        2,
        3,
        3,
        4,
        1
      ]
    }
  ]
}