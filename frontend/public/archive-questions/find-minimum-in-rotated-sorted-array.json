{
  "filename": "find-minimum-in-rotated-sorted-array",
  "title": "Find Minimum in Rotated Sorted Array",
  "keywords": [
    "find",
    "minimum",
    "rotated",
    "sorted",
    "array",
    "leetcode",
    "153",
    "given",
    "length",
    "which"
  ],
  "description": "<h2>Find Minimum in Rotated Sorted Array</h2><p>Leetcode 153. Find Minimum In Rotated Sorted Array</p><p></p><p>You are given an array of length `n` which was originally sorted in ascending order. It has now been **rotated** between `1` and `n` times. For example, the array `nums = [1,2,3,4,5,6]` might become:</p><p></p><p>* `[3,4,5,6,1,2]` if it was rotated `4` times.</p><p>* `[1,2,3,4,5,6]` if it was rotated `6` times.</p><p></p><p>Notice that rotating the array `4` times moves the last four elements of the array to the beginning. Rotating the array `6` times produces the original array.</p><p></p><p>Assuming all elements in the rotated sorted array `nums` are **unique**, return the minimum element of this array.</p><p></p><p>A solution that runs in `O(n)` time is trivial, can you write an algorithm that runs in `O(log n) time`?</p><h3>Examples:</h3><ul><li>Input: nums = [3,4,5,6,1,2]<br><br>Output: 1</li><li>Input: nums = [4,5,0,1,2,3]<br><br>Output: 0</li><li>Input: nums = [4,5,6,7]<br><br>Output: 4</li></ul><h3>Constraints:</h3><ul><li> `1 <= nums.length <= 1000`</li><li> `-1000 <= nums[i] <= 1000`</li></ul>",
  "languages": {
    "python": {
      "template": "def findMinimumInRotatedSortedArray(nums):\n    ",
      "solution_text": "<h3>Find Minimum in Rotated Sorted Array</h3><p><strong>Algorithm:</strong></p><ol><li>Use binary search to find the pivot point (minimum element)</li><li>Compare middle element with rightmost element</li><li>If mid > right, minimum is in right half</li><li>If mid < right, minimum is in left half (including mid)</li><li>Continue until left == right</li></ol><p><strong>Time Complexity:</strong> O(log n) - binary search approach</p><p><strong>Space Complexity:</strong> O(1) - constant extra space</p><p><strong>Key Insights:</strong></p><ul><li>Rotation creates exactly one point where order breaks</li><li>Compare with rightmost element to determine search direction</li><li>Minimum element is at the rotation pivot</li></ul>",
      "solution_code": "def findMinimumInRotatedSortedArray(nums):\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        # If mid element is greater than rightmost,\n        # minimum must be in the right half\n        if nums[mid] > nums[right]:\n            left = mid + 1\n        else:\n            # If mid element is less than or equal to rightmost,\n            # minimum could be mid or in the left half\n            right = mid\n    \n    # When left == right, we found the minimum\n    return nums[left]"
    },
    "javascript": {
      "template": "function findMinimumInRotatedSortedArray(nums) {\n  \n}",
      "solution_text": "<h3>Find Minimum in Rotated Sorted Array</h3><p><strong>Algorithm:</strong></p><ol><li>Use binary search to find the pivot point (minimum element)</li><li>Compare middle element with rightmost element</li><li>If mid > right, minimum is in right half</li><li>If mid < right, minimum is in left half (including mid)</li><li>Continue until left == right</li></ol><p><strong>Time Complexity:</strong> O(log n) - binary search approach</p><p><strong>Space Complexity:</strong> O(1) - constant extra space</p><p><strong>Key Insights:</strong></p><ul><li>Rotation creates exactly one point where order breaks</li><li>Compare with rightmost element to determine search direction</li><li>Minimum element is at the rotation pivot</li></ul>",
      "solution_code": "function findMinimumInRotatedSortedArray(nums) {\n    let left = 0, right = nums.length - 1;\n    \n    while (left < right) {\n        const mid = Math.floor((left + right) / 2);\n        \n        // If mid element is greater than rightmost,\n        // minimum must be in the right half\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            // If mid element is less than or equal to rightmost,\n            // minimum could be mid or in the left half\n            right = mid;\n        }\n    }\n    \n    // When left == right, we found the minimum\n    return nums[left];\n}"
    },
    "typescript": {
      "template": "function findMinimumInRotatedSortedArray(nums: number[]): number {\n  \n}",
      "solution_text": "<h3>Find Minimum in Rotated Sorted Array</h3><p><strong>Algorithm:</strong></p><ol><li>Use binary search to find the pivot point (minimum element)</li><li>Compare middle element with rightmost element</li><li>If mid > right, minimum is in right half</li><li>If mid < right, minimum is in left half (including mid)</li><li>Continue until left == right</li></ol><p><strong>Time Complexity:</strong> O(log n) - binary search approach</p><p><strong>Space Complexity:</strong> O(1) - constant extra space</p><p><strong>Key Insights:</strong></p><ul><li>Rotation creates exactly one point where order breaks</li><li>Compare with rightmost element to determine search direction</li><li>Minimum element is at the rotation pivot</li></ul>",
      "solution_code": "function findMinimumInRotatedSortedArray(nums: number[]): number {\n    let left = 0, right = nums.length - 1;\n    \n    while (left < right) {\n        const mid = Math.floor((left + right) / 2);\n        \n        // If mid element is greater than rightmost,\n        // minimum must be in the right half\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            // If mid element is less than or equal to rightmost,\n            // minimum could be mid or in the left half\n            right = mid;\n        }\n    }\n    \n    // When left == right, we found the minimum\n    return nums[left];\n}"
    },
    "java": {
      "template": "class Solution {\n    public int findMinimumInRotatedSortedArray(int[] nums) {\n        \n    }\n}",
      "solution_text": "<h3>Find Minimum in Rotated Sorted Array</h3><p><strong>Algorithm:</strong></p><ol><li>Use binary search to find the pivot point (minimum element)</li><li>Compare middle element with rightmost element</li><li>If mid > right, minimum is in right half</li><li>If mid < right, minimum is in left half (including mid)</li><li>Continue until left == right</li></ol><p><strong>Time Complexity:</strong> O(log n) - binary search approach</p><p><strong>Space Complexity:</strong> O(1) - constant extra space</p><p><strong>Key Insights:</strong></p><ul><li>Rotation creates exactly one point where order breaks</li><li>Compare with rightmost element to determine search direction</li><li>Minimum element is at the rotation pivot</li></ul>",
      "solution_code": "class Solution {\n    public int findMinimumInRotatedSortedArray(int[] nums) {\n        int left = 0, right = nums.length - 1;\n        \n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            \n            // If mid element is greater than rightmost,\n            // minimum must be in the right half\n            if (nums[mid] > nums[right]) {\n                left = mid + 1;\n            } else {\n                // If mid element is less than or equal to rightmost,\n                // minimum could be mid or in the left half\n                right = mid;\n            }\n        }\n        \n        // When left == right, we found the minimum\n        return nums[left];\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "nums": [
          3,
          4,
          5,
          6,
          1,
          2
        ]
      },
      "output": 1
    },
    {
      "id": 2,
      "input": {
        "nums": [
          4,
          5,
          0,
          1,
          2,
          3
        ]
      },
      "output": 0
    },
    {
      "id": 3,
      "input": {
        "nums": [
          4,
          5,
          6,
          7
        ]
      },
      "output": 4
    }
  ]
}