{
  "filename": "longest-consecutive-sequence",
  "title": "Longest Consecutive Sequence",
  "keywords": [
    "longest",
    "consecutive",
    "sequence",
    "leetcode",
    "128",
    "given",
    "array",
    "integers",
    "nums",
    "return"
  ],
  "description": "<h2>Longest Consecutive Sequence</h2><p>Leetcode 128. Longest Consecutive Sequence</p><p>Given an array of integers <code>nums</code>, return <em>the length</em> of the longest consecutive sequence of elements that can be formed.</p><p>A <em>consecutive sequence</em> is a sequence of elements in which each element is exactly <code>1</code> greater than the previous element. The elements do <em>not</em> have to be consecutive in the original array.</p><p>You must write an algorithm that runs in <code>O(n)</code> time.</p><h3>Examples:</h3><ul><li><strong>Input:</strong> <code>nums = [2,20,4,10,3,4,5]</code><br><strong>Output:</strong> <code>4</code><br><strong>Explanation:</strong> The longest consecutive sequence is <code>[2, 3, 4, 5]</code>.</li><li><strong>Input:</strong> <code>nums = [0,3,2,5,4,6,1,1]</code><br><strong>Output:</strong> <code>7</code><br><strong>Explanation:</strong> The longest consecutive sequence is <code>[0, 1, 2, 3, 4, 5, 6]</code>.</li></ul><h3>Constraints:</h3><ul><li><code>0 <= nums.length <= 1000</code></li><li><code>-10^9 <= nums[i] <= 10^9</code></li></ul>",
  "languages": {
    "python": {
      "template": "def longestConsecutiveSequence(nums):\n    ",
      "solution_text": "**Algorithm: HashSet Approach**\n\nThe key insight is to use a HashSet for O(1) lookup and only start counting from the beginning of each sequence.\n\n**Steps:**\n1. Convert array to HashSet for O(1) lookup\n2. For each number, check if it's the start of a sequence (num-1 not in set)\n3. If it's the start, count consecutive numbers\n4. Keep track of the maximum length\n\n**Time Complexity:** O(n) - each number is visited at most twice\n**Space Complexity:** O(n) - for the HashSet\n\n**Key Insights:**\n- Only count from sequence starts to avoid redundant work\n- HashSet provides O(1) lookup for consecutive number checking\n- Handles duplicates naturally through set operations",
      "solution_code": "def longestConsecutiveSequence(nums):\n    if not nums:\n        return 0\n    \n    # Convert to set for O(1) lookup\n    num_set = set(nums)\n    max_length = 0\n    \n    for num in num_set:\n        # Only start counting if this is the beginning of a sequence\n        if num - 1 not in num_set:\n            current_num = num\n            current_length = 1\n            \n            # Count consecutive numbers\n            while current_num + 1 in num_set:\n                current_num += 1\n                current_length += 1\n            \n            max_length = max(max_length, current_length)\n    \n    return max_length"
    },
    "javascript": {
      "template": "function longestConsecutiveSequence(nums) {\n  \n}",
      "solution_text": "**Algorithm: HashSet Approach**\n\nThe key insight is to use a Set for O(1) lookup and only start counting from the beginning of each sequence.\n\n**Steps:**\n1. Convert array to Set for O(1) lookup\n2. For each number, check if it's the start of a sequence (num-1 not in set)\n3. If it's the start, count consecutive numbers\n4. Keep track of the maximum length\n\n**Time Complexity:** O(n) - each number is visited at most twice\n**Space Complexity:** O(n) - for the Set\n\n**Key Insights:**\n- Only count from sequence starts to avoid redundant work\n- Set provides O(1) lookup for consecutive number checking\n- Handles duplicates naturally through set operations",
      "solution_code": "function longestConsecutiveSequence(nums) {\n    if (nums.length === 0) {\n        return 0;\n    }\n    \n    // Convert to Set for O(1) lookup\n    const numSet = new Set(nums);\n    let maxLength = 0;\n    \n    for (const num of numSet) {\n        // Only start counting if this is the beginning of a sequence\n        if (!numSet.has(num - 1)) {\n            let currentNum = num;\n            let currentLength = 1;\n            \n            // Count consecutive numbers\n            while (numSet.has(currentNum + 1)) {\n                currentNum++;\n                currentLength++;\n            }\n            \n            maxLength = Math.max(maxLength, currentLength);\n        }\n    }\n    \n    return maxLength;\n}"
    },
    "typescript": {
      "template": "function longestConsecutiveSequence(nums: number[]): number {\n  \n}",
      "solution_text": "**Algorithm: HashSet Approach**\n\nThe key insight is to use a Set for O(1) lookup and only start counting from the beginning of each sequence.\n\n**Steps:**\n1. Convert array to Set for O(1) lookup\n2. For each number, check if it's the start of a sequence (num-1 not in set)\n3. If it's the start, count consecutive numbers\n4. Keep track of the maximum length\n\n**Time Complexity:** O(n) - each number is visited at most twice\n**Space Complexity:** O(n) - for the Set\n\n**Key Insights:**\n- Only count from sequence starts to avoid redundant work\n- Set provides O(1) lookup for consecutive number checking\n- Handles duplicates naturally through set operations",
      "solution_code": "function longestConsecutiveSequence(nums: number[]): number {\n    if (nums.length === 0) {\n        return 0;\n    }\n    \n    // Convert to Set for O(1) lookup\n    const numSet = new Set(nums);\n    let maxLength = 0;\n    \n    for (const num of numSet) {\n        // Only start counting if this is the beginning of a sequence\n        if (!numSet.has(num - 1)) {\n            let currentNum = num;\n            let currentLength = 1;\n            \n            // Count consecutive numbers\n            while (numSet.has(currentNum + 1)) {\n                currentNum++;\n                currentLength++;\n            }\n            \n            maxLength = Math.max(maxLength, currentLength);\n        }\n    }\n    \n    return maxLength;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int longestConsecutiveSequence(int[] nums) {\n        \n    }\n}",
      "solution_text": "**Algorithm: HashSet Approach**\n\nThe key insight is to use a HashSet for O(1) lookup and only start counting from the beginning of each sequence.\n\n**Steps:**\n1. Convert array to HashSet for O(1) lookup\n2. For each number, check if it's the start of a sequence (num-1 not in set)\n3. If it's the start, count consecutive numbers\n4. Keep track of the maximum length\n\n**Time Complexity:** O(n) - each number is visited at most twice\n**Space Complexity:** O(n) - for the HashSet\n\n**Key Insights:**\n- Only count from sequence starts to avoid redundant work\n- HashSet provides O(1) lookup for consecutive number checking\n- Handles duplicates naturally through set operations",
      "solution_code": "import java.util.*;\n\nclass Solution {\n    public int longestConsecutiveSequence(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n        \n        // Convert to HashSet for O(1) lookup\n        Set<Integer> numSet = new HashSet<>();\n        for (int num : nums) {\n            numSet.add(num);\n        }\n        \n        int maxLength = 0;\n        \n        for (int num : numSet) {\n            // Only start counting if this is the beginning of a sequence\n            if (!numSet.contains(num - 1)) {\n                int currentNum = num;\n                int currentLength = 1;\n                \n                // Count consecutive numbers\n                while (numSet.contains(currentNum + 1)) {\n                    currentNum++;\n                    currentLength++;\n                }\n                \n                maxLength = Math.max(maxLength, currentLength);\n            }\n        }\n        \n        return maxLength;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "nums": [2, 20, 4, 10, 3, 4, 5]
      },
      "output": 4
    },
    {
      "id": 2,
      "input": {
        "nums": [0, 3, 2, 5, 4, 6, 1, 1]
      },
      "output": 7
    },
    {
      "id": 3,
      "input": {
        "nums": []
      },
      "output": 0
    },
    {
      "id": 4,
      "input": {
        "nums": [1]
      },
      "output": 1
    },
    {
      "id": 5,
      "input": {
        "nums": [1, 2, 0, 1]
      },
      "output": 3
    },
    {
      "id": 6,
      "input": {
        "nums": [9, 1, 4, 7, 3, -1, 0, 5, 8, -1, 6]
      },
      "output": 7
    },
    {
      "id": 7,
      "input": {
        "nums": [1, 3, 5, 7, 9]
      },
      "output": 1
    },
    {
      "id": 8,
      "input": {
        "nums": [100, 4, 200, 1, 3, 2]
      },
      "output": 4
    },
    {
      "id": 9,
      "input": {
        "nums": [-1, -2, -3, 0, 1]
      },
      "output": 5
    },
    {
      "id": 10,
      "input": {
        "nums": [1000000000, -1000000000]
      },
      "output": 1
    },
    {
      "id": 11,
      "input": {
        "nums": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      },
      "output": 10
    },
    {
      "id": 12,
      "input": {
        "nums": [5, 5, 5, 5, 5]
      },
      "output": 1
    }
  ]
}