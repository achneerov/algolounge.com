{
  "filename": "max-area-of-island",
  "title": "Max Area of Island",
  "keywords": [
    "max",
    "area",
    "island",
    "leetcode",
    "695",
    "given",
    "matrix",
    "grid",
    "where",
    "either"
  ],
  "description": "<h2>Max Area of Island</h2><p>Leetcode 695. Max Area of Island</p><p>You are given a matrix <code>grid</code> where <code>grid[i][j]</code> is either a <code>0</code> (representing water) or <code>1</code> (representing land).</p><p>An island is defined as a group of <code>1</code>s connected horizontally or vertically. You may assume all four edges of the grid are surrounded by water.</p><p>The <strong>area</strong> of an island is defined as the number of cells within the island.</p><p>Return the maximum <strong>area</strong> of an island in <code>grid</code>. If no island exists, return <code>0</code>.</p><h3>Examples:</h3><ul><li><strong>Input:</strong> grid = [[1,1,0,0,0],[1,1,0,0,0],[0,0,0,1,1],[0,0,0,1,1]]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> The largest island has area 4.</li><li><strong>Input:</strong> grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]<br><strong>Output:</strong> 6<br><strong>Explanation:</strong> The largest connected component of 1s has area 6.</li></ul><h3>Constraints:</h3><ul><li><code>1 <= grid.length, grid[i].length <= 50</code></li><li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code></li></ul>",
  "languages": {
    "python": {
      "template": "def maxAreaOfIsland(grid):\n    ",
      "solution_text": "<h3>DFS Island Area Calculation</h3><p>Find the maximum area of connected land cells (1s) in a 2D grid using depth-first search.</p><h4>Algorithm:</h4><ol><li>Iterate through each cell in the grid</li><li>When finding unvisited land (1), start DFS to calculate island area</li><li>Mark visited cells to avoid double counting</li><li>Track maximum area found across all islands</li></ol><h4>Time Complexity:</h4><p>O(m × n) - visit each cell at most once</p><h4>Space Complexity:</h4><p>O(m × n) - recursion stack in worst case</p><h4>Key Insights:</h4><ul><li>DFS explores all connected land cells from starting point</li><li>Each cell contributes exactly 1 to island area</li><li>Grid modification avoids need for separate visited array</li></ul>",
      "solution_code": "def maxAreaOfIsland(grid):\n    if not grid or not grid[0]:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    max_area = 0\n    \n    def dfs(r, c):\n        if (r < 0 or r >= rows or c < 0 or c >= cols or \n            grid[r][c] != 1):\n            return 0\n        \n        grid[r][c] = 0  # Mark as visited\n        area = 1\n        \n        # Explore 4 directions\n        area += dfs(r + 1, c)\n        area += dfs(r - 1, c)\n        area += dfs(r, c + 1)\n        area += dfs(r, c - 1)\n        \n        return area\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                max_area = max(max_area, dfs(i, j))\n    \n    return max_area"
    },
    "javascript": {
      "template": "function maxAreaOfIsland(grid) {\n  \n}",
      "solution_text": "<h3>DFS Island Area Calculation</h3><p>Find the maximum area of connected land cells (1s) in a 2D grid using depth-first search.</p><h4>Algorithm:</h4><ol><li>Iterate through each cell in the grid</li><li>When finding unvisited land (1), start DFS to calculate island area</li><li>Mark visited cells to avoid double counting</li><li>Track maximum area found across all islands</li></ol><h4>Time Complexity:</h4><p>O(m × n) - visit each cell at most once</p><h4>Space Complexity:</h4><p>O(m × n) - recursion stack in worst case</p><h4>Key Insights:</h4><ul><li>DFS explores all connected land cells from starting point</li><li>Each cell contributes exactly 1 to island area</li><li>Grid modification avoids need for separate visited array</li></ul>",
      "solution_code": "function maxAreaOfIsland(grid) {\n    if (!grid || !grid.length || !grid[0].length) {\n        return 0;\n    }\n    \n    const rows = grid.length;\n    const cols = grid[0].length;\n    let maxArea = 0;\n    \n    function dfs(r, c) {\n        if (r < 0 || r >= rows || c < 0 || c >= cols || \n            grid[r][c] !== 1) {\n            return 0;\n        }\n        \n        grid[r][c] = 0; // Mark as visited\n        let area = 1;\n        \n        // Explore 4 directions\n        area += dfs(r + 1, c);\n        area += dfs(r - 1, c);\n        area += dfs(r, c + 1);\n        area += dfs(r, c - 1);\n        \n        return area;\n    }\n    \n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (grid[i][j] === 1) {\n                maxArea = Math.max(maxArea, dfs(i, j));\n            }\n        }\n    }\n    \n    return maxArea;\n}"
    },
    "typescript": {
      "template": "function maxAreaOfIsland(grid: number[][]): number {\n  \n}",
      "solution_text": "<h3>DFS Island Area Calculation</h3><p>Find the maximum area of connected land cells (1s) in a 2D grid using depth-first search.</p><h4>Algorithm:</h4><ol><li>Iterate through each cell in the grid</li><li>When finding unvisited land (1), start DFS to calculate island area</li><li>Mark visited cells to avoid double counting</li><li>Track maximum area found across all islands</li></ol><h4>Time Complexity:</h4><p>O(m × n) - visit each cell at most once</p><h4>Space Complexity:</h4><p>O(m × n) - recursion stack in worst case</p><h4>Key Insights:</h4><ul><li>DFS explores all connected land cells from starting point</li><li>Each cell contributes exactly 1 to island area</li><li>Grid modification avoids need for separate visited array</li></ul>",
      "solution_code": "function maxAreaOfIsland(grid: number[][]): number {\n    if (!grid || !grid.length || !grid[0].length) {\n        return 0;\n    }\n    \n    const rows = grid.length;\n    const cols = grid[0].length;\n    let maxArea = 0;\n    \n    function dfs(r: number, c: number): number {\n        if (r < 0 || r >= rows || c < 0 || c >= cols || \n            grid[r][c] !== 1) {\n            return 0;\n        }\n        \n        grid[r][c] = 0; // Mark as visited\n        let area = 1;\n        \n        // Explore 4 directions\n        area += dfs(r + 1, c);\n        area += dfs(r - 1, c);\n        area += dfs(r, c + 1);\n        area += dfs(r, c - 1);\n        \n        return area;\n    }\n    \n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (grid[i][j] === 1) {\n                maxArea = Math.max(maxArea, dfs(i, j));\n            }\n        }\n    }\n    \n    return maxArea;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int maxAreaOfIsland(int[][] grid) {\n        \n    }\n}",
      "solution_text": "<h3>DFS Island Area Calculation</h3><p>Find the maximum area of connected land cells (1s) in a 2D grid using depth-first search.</p><h4>Algorithm:</h4><ol><li>Iterate through each cell in the grid</li><li>When finding unvisited land (1), start DFS to calculate island area</li><li>Mark visited cells to avoid double counting</li><li>Track maximum area found across all islands</li></ol><h4>Time Complexity:</h4><p>O(m × n) - visit each cell at most once</p><h4>Space Complexity:</h4><p>O(m × n) - recursion stack in worst case</p><h4>Key Insights:</h4><ul><li>DFS explores all connected land cells from starting point</li><li>Each cell contributes exactly 1 to island area</li><li>Grid modification avoids need for separate visited array</li></ul>",
      "solution_code": "class Solution {\n    public int maxAreaOfIsland(int[][] grid) {\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\n            return 0;\n        }\n        \n        int rows = grid.length;\n        int cols = grid[0].length;\n        int maxArea = 0;\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == 1) {\n                    maxArea = Math.max(maxArea, dfs(grid, i, j));\n                }\n            }\n        }\n        \n        return maxArea;\n    }\n    \n    private int dfs(int[][] grid, int r, int c) {\n        if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || \n            grid[r][c] != 1) {\n            return 0;\n        }\n        \n        grid[r][c] = 0; // Mark as visited\n        int area = 1;\n        \n        // Explore 4 directions\n        area += dfs(grid, r + 1, c);\n        area += dfs(grid, r - 1, c);\n        area += dfs(grid, r, c + 1);\n        area += dfs(grid, r, c - 1);\n        \n        return area;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "grid": [[1,1,0,0,0],[1,1,0,0,0],[0,0,0,1,1],[0,0,0,1,1]]
      },
      "output": 4
    },
    {
      "id": 2,
      "input": {
        "grid": [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
      },
      "output": 6
    },
    {
      "id": 3,
      "input": {
        "grid": [[0,0,0,0,0,0,0,0]]
      },
      "output": 0
    },
    {
      "id": 4,
      "input": {
        "grid": [[1]]
      },
      "output": 1
    },
    {
      "id": 5,
      "input": {
        "grid": [[1,1,1],[1,0,1],[1,1,1]]
      },
      "output": 8
    },
    {
      "id": 6,
      "input": {
        "grid": [[1,0,1],[0,1,0],[1,0,1]]
      },
      "output": 1
    },
    {
      "id": 7,
      "input": {
        "grid": [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]
      },
      "output": 16
    },
    {
      "id": 8,
      "input": {
        "grid": [[0,1,0],[1,1,1],[0,1,0]]
      },
      "output": 5
    },
    {
      "id": 9,
      "input": {
        "grid": [[1,0,0,1,1],[0,0,1,1,0],[0,1,0,0,1]]
      },
      "output": 3
    },
    {
      "id": 10,
      "input": {
        "grid": [[0,0,0],[0,0,0],[0,0,0]]
      },
      "output": 0
    }
  ]
}