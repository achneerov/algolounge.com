{
  "filename": "path-with-minimum-effort",
  "title": "Path with Minimum Effort",
  "keywords": [
    "path",
    "minimum",
    "effort",
    "leetcode",
    "1631",
    "given",
    "heights",
    "array",
    "size",
    "rows"
  ],
  "description": "<h2>Path with Minimum Effort</h2><p>Leetcode 1631. Path with Minimum Effort</p><p></p><p>You are given `heights`, a `2D` array of size `rows x columns`, where `heights[row][col]` represents the height of cell `(row, col)`. You are situated in the top-left cell, `(0, 0)`, and you hope to travel to the bottom-right cell, `(rows-1, columns-1)` (i.e., **0-indexed**). You can move **up**, **down**, **left**, or **right**, and you wish to find a route that requires the **minimum effort**.</p><p></p><p>A route's **effort** is the **maximum absolute difference** in heights between two consecutive cells of the route.</p><p></p><p>Return the **minimum effort** required to travel from the top-left cell to the bottom-right cell.</p><h3>Examples:</h3><ul><li>Input: heights = [<br>    [1,1,1],<br>    [3,2,4],<br>    [2,5,4]<br>]<br><br>Output: 2<br>The route of `[1,1,2,4,4]` has a maximum absolute difference of 2 in consecutive cells.</li><li>Input: heights = [<br>    [1,1,1],<br>    [1,1,2],<br>    [6,5,2]<br>]<br><br>Output: 1<br>The route of `[1,1,1,1,1,2,2]` has a maximum absolute difference of 1 in consecutive cells.</li></ul><h3>Constraints:</h3><ul><li> `row == heights.length`</li><li> `col == heights[i].length`</li><li> `1 <= row, col <= 100`</li><li> `1 <= heights[i][j].length <= 1,000,000` .</li></ul>",
  "languages": {
    "python": {
      "template": "def pathWithMinimumEffort(heights):\n    ",
      "solution_text": "Min/Max finding algorithm:\n\n**Algorithm:**\n1. Initialize min/max with first element\n2. Iterate through remaining elements\n3. Update min/max as needed\n\n**Time Complexity:** O(n) - single pass through array\n**Space Complexity:** O(1) - constant extra space\n\n**Key Insights:**\n- Handle empty arrays with appropriate defaults\n- Consider both positive and negative numbers\n- Single pass optimization",
      "solution_code": "def pathWithMinimumEffort(nums):\n    if not nums:\n        return 0  # or appropriate default\n    \n    result = nums[0]\n    \n    for num in nums[1:]:\n        if 'max' in 'pathWithMinimumEffort'.lower():\n            result = max(result, num)\n        else:\n            result = min(result, num)\n    \n    return result"
    },
    "javascript": {
      "template": "function pathWithMinimumEffort(heights) {\n  \n}",
      "solution_text": "Min/Max finding algorithm:\n\n**Algorithm:**\n1. Initialize min/max with first element\n2. Iterate through remaining elements\n3. Update min/max as needed\n\n**Time Complexity:** O(n) - single pass through array\n**Space Complexity:** O(1) - constant extra space\n\n**Key Insights:**\n- Handle empty arrays with appropriate defaults\n- Consider both positive and negative numbers\n- Single pass optimization",
      "solution_code": "function pathWithMinimumEffort(nums) {\n    if (!nums || nums.length === 0) return 0;\n    \n    let result = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        if ('pathWithMinimumEffort'.toLowerCase().includes('max')) {\n            result = Math.max(result, nums[i]);\n        } else {\n            result = Math.min(result, nums[i]);\n        }\n    }\n    \n    return result;\n}"
    },
    "typescript": {
      "template": "function pathWithMinimumEffort(heights: number[]): number {\n  \n}",
      "solution_text": "Min/Max finding algorithm:\n\n**Algorithm:**\n1. Initialize min/max with first element\n2. Iterate through remaining elements\n3. Update min/max as needed\n\n**Time Complexity:** O(n) - single pass through array\n**Space Complexity:** O(1) - constant extra space\n\n**Key Insights:**\n- Handle empty arrays with appropriate defaults\n- Consider both positive and negative numbers\n- Single pass optimization",
      "solution_code": "function pathWithMinimumEffort(nums: number[]): number {\n    if (!nums || nums.length === 0) return 0;\n    \n    let result = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        if ('pathWithMinimumEffort'.toLowerCase().includes('max')) {\n            result = Math.max(result, nums[i]);\n        } else {\n            result = Math.min(result, nums[i]);\n        }\n    }\n    \n    return result;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int pathWithMinimumEffort(int[] heights) {\n        \n    }\n}",
      "solution_text": "Min/Max finding algorithm:\n\n**Algorithm:**\n1. Initialize min/max with first element\n2. Iterate through remaining elements\n3. Update min/max as needed\n\n**Time Complexity:** O(n) - single pass through array\n**Space Complexity:** O(1) - constant extra space\n\n**Key Insights:**\n- Handle empty arrays with appropriate defaults\n- Consider both positive and negative numbers\n- Single pass optimization",
      "solution_code": "class Solution {\n    public int pathWithMinimumEffort(int[] nums) {\n        if (nums == null || nums.length == 0) return 0;\n        \n        int result = nums[0];\n        \n        for (int i = 1; i < nums.length; i++) {\n            if (\"pathWithMinimumEffort\".toLowerCase().contains(\"max\")) {\n                result = Math.max(result, nums[i]);\n            } else {\n                result = Math.min(result, nums[i]);\n            }\n        }\n        \n        return result;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "heights": [
          "[1",
          1,
          1
        ]
      },
      "output": 2
    },
    {
      "id": 2,
      "input": {
        "heights": [
          "[1",
          1,
          1
        ]
      },
      "output": 1
    }
  ]
}