{
  "index": 18,
  "filename": "binary-tree-maximum-path-sum",
  "title": "Binary Tree Maximum Path Sum",
  "difficulty": "Hard",
  "tags": ["Trees"],
  "keywords": [
    "binary",
    "tree",
    "maximum",
    "path",
    "sum",
    "leetcode",
    "124",
    "given",
    "root",
    "non"
  ],
  "description": "<h2>Binary Tree Maximum Path Sum</h2><p><em>LeetCode 124. Binary Tree Maximum Path Sum</em></p><p>Given the <code>root</code> of a non-empty binary tree, return the maximum <strong>path sum</strong> of any non-empty path.</p><p>A <strong>path</strong> in a binary tree is a sequence of nodes where each pair of adjacent nodes has an edge connecting them. A node can only appear in the sequence once. The path does not necessarily need to include the root.</p><p>The <strong>path sum</strong> of a path is the sum of the node's values in the path.</p><h3>Examples:</h3><ul><li><strong>Input:</strong> root = [1,2,3]<br><pre>    1\n   / \\\n  2   3</pre><strong>Output:</strong> 6<br><strong>Explanation:</strong> Path 2 → 1 → 3 has maximum sum 2 + 1 + 3 = 6</li><li><strong>Input:</strong> root = [-10,9,20,null,null,15,7]<br><strong>Output:</strong> 42<br><strong>Explanation:</strong> Path 15 → 20 → 7 has maximum sum 15 + 20 + 7 = 42</li></ul><h3>Constraints:</h3><ul><li><code>1 <= The number of nodes in the tree <= 1000</code></li><li><code>-1000 <= Node.val <= 1000</code></li></ul>",
  "entry_function": "binaryTreeMaximumPathSum",
  "template": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef binaryTreeMaximumPathSum(root):\n    ",
  "solution_text": "<h3>Binary Tree Maximum Path Sum</h3><p><strong>Algorithm:</strong></p><ol><li>Use DFS to traverse the tree and track maximum path sum</li><li>For each node, calculate maximum path sum including that node</li><li>Update global maximum with path passing through current node</li><li>Return maximum single path sum for parent's calculation</li></ol><p><strong>Time Complexity:</strong> O(n) - visit each node once</p><p><strong>Space Complexity:</strong> O(h) - recursion stack depth</p><p><strong>Key Insights:</strong></p><ul><li>Path can start and end at any nodes</li><li>At each node, consider paths: left-node-right, node-right, node-left, or just node</li><li>Track global maximum separately from returned value</li></ul>",
  "solution_code": "def binaryTreeMaximumPathSum(root):\n    if not root:\n        return 0\n    \n    max_sum = float('-inf')\n    \n    def max_gain(node):\n        nonlocal max_sum\n        if not node:\n            return 0\n        \n        # Get maximum sum from left and right subtrees (ignore negative gains)\n        left_gain = max(max_gain(node.left), 0)\n        right_gain = max(max_gain(node.right), 0)\n        \n        # Current path sum including this node as highest point\n        current_max = node.val + left_gain + right_gain\n        \n        # Update global maximum\n        max_sum = max(max_sum, current_max)\n        \n        # Return maximum gain for parent (can only use one side)\n        return node.val + max(left_gain, right_gain)\n    \n    max_gain(root)\n    return max_sum",
  "prepare": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n    \n    def __repr__(self):\n        return f'TreeNode({self.val})'\n\ndef prepare(test_case_input):\n    \"\"\"Convert array representation to TreeNode structure\"\"\"\n    root_array = test_case_input['root']\n    if not root_array or root_array[0] is None:\n        return (None,)\n\n    def build_tree(arr):\n        from collections import deque\n        \n        root = TreeNode(arr[0])\n        queue = deque([root])\n        i = 1\n        \n        while queue and i < len(arr):\n            node = queue.popleft()\n            \n            # Add left child\n            if i < len(arr):\n                if arr[i] is not None:\n                    node.left = TreeNode(arr[i])\n                    queue.append(node.left)\n                i += 1\n            \n            # Add right child\n            if i < len(arr):\n                if arr[i] is not None:\n                    node.right = TreeNode(arr[i])\n                    queue.append(node.right)\n                i += 1\n        \n        return root\n\n    return (build_tree(root_array),)",
  "verify": "def verify(actual_output, expected_output):\n    \"\"\"Verify the maximum path sum result\"\"\"\n    passed = actual_output == expected_output\n    output_str = str(actual_output)\n    \n    return [passed, output_str]",
  "test_cases": [
    {
      "id": 1,
      "input": {
        "root": [
          1,
          2,
          3
        ]
      },
      "output": 6
    },
    {
      "id": 2,
      "input": {
        "root": [
          -10,
          9,
          20,
          null,
          null,
          15,
          7
        ]
      },
      "output": 42
    },
    {
      "id": 3,
      "input": {
        "root": [
          -3
        ]
      },
      "output": -3
    },
    {
      "id": 4,
      "input": {
        "root": [
          2,
          -1
        ]
      },
      "output": 2
    },
    {
      "id": 5,
      "input": {
        "root": [
          1
        ]
      },
      "output": 1
    },
    {
      "id": 6,
      "input": {
        "root": [
          5,
          4,
          8,
          11,
          null,
          13,
          4,
          7,
          2,
          null,
          null,
          null,
          1
        ]
      },
      "output": 48
    },
    {
      "id": 7,
      "input": {
        "root": [
          1,
          2,
          null,
          3,
          null,
          4,
          null,
          5
        ]
      },
      "output": 15
    },
    {
      "id": 8,
      "input": {
        "root": [
          -1,
          -2,
          -3
        ]
      },
      "output": -1
    },
    {
      "id": 9,
      "input": {
        "root": [
          6,
          2,
          3,
          null,
          null,
          null,
          1
        ]
      },
      "output": 12
    },
    {
      "id": 10,
      "input": {
        "root": [
          9,
          6,
          -3,
          null,
          null,
          -6,
          2,
          null,
          null,
          2,
          null,
          -6,
          -6,
          -6
        ]
      },
      "output": 16
    }
  ]
}
