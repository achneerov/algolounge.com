{
  "index": 116,
  "filename": "clone-graph",
  "title": "Clone Graph",
  "keywords": [
    "clone",
    "graph",
    "dfs",
    "bfs",
    "leetcode",
    "133",
    "hash",
    "map",
    "medium"
  ],
  "description": "<h2>Clone Graph</h2><p>Given a reference of a node in a <strong>connected</strong> undirected graph, return a <strong>deep copy</strong> (clone) of the graph.</p><p>Each node in the graph contains a value (<code>int</code>) and a list (<code>List[Node]</code>) of its neighbors.</p><pre>class Node {\n    public int val;\n    public List&lt;Node&gt; neighbors;\n}</pre><h3>Test case format:</h3><p>For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with <code>val == 1</code>, the second node with <code>val == 2</code>, and so on. The graph is represented in the test case using an adjacency list.</p><p><strong>An adjacency list</strong> is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.</p><p>The given node will always be the first node with <code>val = 1</code>. You must return the <strong>copy of the given node</strong> as a reference to the cloned graph.</p><h3>Examples:</h3><ul><li>Input: adjList = [[2,4],[1,3],[2,4],[1,3]]<br><br>Output: [[2,4],[1,3],[2,4],[1,3]]<br><br>Explanation: There are 4 nodes in the graph.<br>1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).<br>2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).<br>3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).<br>4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).</li><li>Input: adjList = [[]]<br><br>Output: [[]]<br><br>Explanation: The input contains a single node with no neighbors.</li><li>Input: adjList = []<br><br>Output: []<br><br>Explanation: The graph is empty.</li></ul><h3>Constraints:</h3><ul><li><code>The number of nodes in the graph is in the range [0, 100]</code></li><li><code>1 <= Node.val <= 100</code></li><li><code>Node.val is unique for each node</code></li><li><code>There are no repeated edges and no self-loops in the graph</code></li><li><code>The Graph is connected and all nodes can be visited starting from the given node</code></li></ul>",
  "entry_function": "cloneGraph",
  "template": "# class Node:\n#     def __init__(self, val=0, neighbors=None):\n#         self.val = val\n#         self.neighbors = neighbors if neighbors is not None else []\n\ndef cloneGraph(node):\n    ",
  "solution_text": "<h3>Clone Graph</h3><p><strong>Algorithm:</strong></p><ol><li>Create a hash map to store original node to cloned node mapping</li><li>Use DFS to traverse the graph starting from the given node</li><li>For each node, create a clone if not already cloned</li><li>Recursively clone all neighbors and add to the cloned node's neighbor list</li></ol><p><strong>Time Complexity:</strong> O(V + E) - visit all vertices and edges once</p><p><strong>Space Complexity:</strong> O(V) - hash map stores all nodes</p><p><strong>Key Insights:</strong></p><ul><li>Use hash map to track already cloned nodes</li><li>Prevents infinite loops in cyclic graphs</li><li>DFS naturally handles connected components</li><li>Can also be solved with BFS approach</li></ul>",
  "solution_code": "def cloneGraph(node):\n    if not node:\n        return None\n    \n    oldToNew = {}\n    \n    def dfs(node):\n        if node in oldToNew:\n            return oldToNew[node]\n        \n        copy = Node(node.val)\n        oldToNew[node] = copy\n        for nei in node.neighbors:\n            copy.neighbors.append(dfs(nei))\n        return copy\n    \n    return dfs(node)",
  "prepare": "class Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n    \n    def __repr__(self):\n        return f'Node({self.val})'\n\ndef prepare(test_case_input):\n    \"\"\"Convert adjacency list to graph Node structure\"\"\"\n    adjList = test_case_input['adjList']\n    \n    if not adjList:\n        globals()['_original_graph_node'] = None\n        return (None,)\n    \n    # Create all nodes first\n    nodes = {}\n    for i in range(1, len(adjList) + 1):\n        nodes[i] = Node(i)\n    \n    # Connect neighbors\n    for i, neighbors in enumerate(adjList, start=1):\n        for neighbor_val in neighbors:\n            nodes[i].neighbors.append(nodes[neighbor_val])\n    \n    # Store original node for verification\n    original_node = nodes.get(1, None)\n    globals()['_original_graph_node'] = original_node\n    \n    return (original_node,)",
  "verify": "def verify(actual_output, expected_output):\n    \"\"\"Verify the cloned graph structure and ensure it's a deep copy\"\"\"\n    # Get the original node from the global scope (stored by prepare)\n    original_node = globals().get('_original_graph_node', None)\n    \n    def graph_to_adjlist(node):\n        if not node:\n            return []\n        \n        visited = {}\n        adjlist = []\n        \n        def dfs(n):\n            if n.val in visited:\n                return\n            visited[n.val] = True\n            \n            # Ensure we have enough space in adjlist\n            while len(adjlist) < n.val:\n                adjlist.append([])\n            \n            neighbors = sorted([nei.val for nei in n.neighbors])\n            adjlist[n.val - 1] = neighbors\n            \n            for nei in n.neighbors:\n                dfs(nei)\n        \n        dfs(node)\n        return adjlist\n    \n    def adjlist_to_string(adjlist):\n        if not adjlist:\n            return '[]'\n        return '[' + ','.join('[' + ','.join(map(str, neighbors)) + ']' for neighbors in adjlist) + ']'\n    \n    # Check if it's a shallow copy (same object reference)\n    if original_node is not None and actual_output is original_node:\n        return [False, 'Error: Returned same reference (shallow copy), not a deep copy']\n    \n    # Check if nodes are actually different objects\n    if original_node is not None and actual_output is not None:\n        def check_deep_copy(orig, cloned, visited_orig=None, visited_cloned=None):\n            if visited_orig is None:\n                visited_orig = set()\n                visited_cloned = set()\n            \n            if id(orig) in visited_orig:\n                return True\n            \n            visited_orig.add(id(orig))\n            visited_cloned.add(id(cloned))\n            \n            # Check if it's the same object\n            if orig is cloned:\n                return False\n            \n            # Check all neighbors\n            if len(orig.neighbors) != len(cloned.neighbors):\n                return False\n            \n            for orig_nei, cloned_nei in zip(orig.neighbors, cloned.neighbors):\n                if orig_nei.val != cloned_nei.val:\n                    return False\n                if id(cloned_nei) not in visited_cloned:\n                    if not check_deep_copy(orig_nei, cloned_nei, visited_orig, visited_cloned):\n                        return False\n            \n            return True\n        \n        if not check_deep_copy(original_node, actual_output):\n            return [False, 'Error: Not a deep copy - nodes share references with original']\n    \n    actual_adjlist = graph_to_adjlist(actual_output)\n    \n    passed = actual_adjlist == expected_output\n    output_str = adjlist_to_string(actual_adjlist)\n    \n    return [passed, output_str]",
  "test_cases": [
    {
      "id": 1,
      "input": {
        "adjList": [[2, 4], [1, 3], [2, 4], [1, 3]]
      },
      "output": [[2, 4], [1, 3], [2, 4], [1, 3]]
    },
    {
      "id": 2,
      "input": {
        "adjList": [[]]
      },
      "output": [[]]
    },
    {
      "id": 3,
      "input": {
        "adjList": []
      },
      "output": []
    },
    {
      "id": 4,
      "input": {
        "adjList": [[2], [1]]
      },
      "output": [[2], [1]]
    },
    {
      "id": 5,
      "input": {
        "adjList": [[2, 3], [1, 3], [1, 2]]
      },
      "output": [[2, 3], [1, 3], [1, 2]]
    }
  ]
}
