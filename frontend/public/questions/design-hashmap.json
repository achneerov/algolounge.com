{
  "index": 0,
  "filename": "design-hashmap",
  "title": "Design HashMap",
  "difficulty": "Easy",
  "tags": [
    "Hash Map"
  ],
  "keywords": [
    "design",
    "hashmap",
    "hash table",
    "leetcode",
    "706",
    "put",
    "get",
    "remove"
  ],
  "description": "<h2>Design HashMap</h2><p>LeetCode 706. Design HashMap</p><p>Design a HashMap without using any built-in hash table libraries. You may not use <code>set()</code> or <code>dict()</code>.</p><p>Implement the <code>MyHashMap</code> class:</p><ul><li><code>MyHashMap()</code> initializes the object with an empty map.</li><li><code>put(key, value)</code> inserts a <code>(key, value)</code> pair into the HashMap. If the <code>key</code> already exists in the map, update the corresponding <code>value</code>.</li><li><code>get(key)</code> returns the <code>value</code> to which the specified <code>key</code> is mapped, or <code>-1</code> if this map contains no mapping for the <code>key</code>.</li><li><code>remove(key)</code> removes the <code>key</code> and its corresponding <code>value</code> if the map contains the mapping for the <code>key</code>.</li></ul><h3>Examples:</h3><ul><li>Input: [\"MyHashMap()\", \"put(1, 1)\", \"put(2, 2)\", \"get(1)\", \"get(3)\", \"put(2, 1)\", \"get(2)\", \"remove(2)\", \"get(2)\"]<br>Output: [null, null, null, 1, -1, null, 1, null, -1]<br><br>Explanation:<br>MyHashMap myHashMap = new MyHashMap();<br>myHashMap.put(1, 1); // The map is now [[1,1]]<br>myHashMap.put(2, 2); // The map is now [[1,1], [2,2]]<br>myHashMap.get(1);    // return 1<br>myHashMap.get(3);    // return -1 (not found)<br>myHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (update existing value)<br>myHashMap.get(2);    // return 1<br>myHashMap.remove(2); // remove the mapping for 2<br>myHashMap.get(2);    // return -1 (not found)</li></ul><h3>Constraints:</h3><ul><li><code>0 <= key, value <= 1,000,000</code></li><li>At most <code>10,000</code> calls will be made to <code>put</code>, <code>get</code>, and <code>remove</code>.</li></ul>",
  "entry_function": "executeHashMapOperations",
  "template": "class MyHashMap:\n\n    def __init__(self):\n        pass\n\n    def put(self, key: int, value: int) -> None:\n        pass\n\n    def get(self, key: int) -> int:\n        pass\n\n    def remove(self, key: int) -> None:\n        pass",
  "solution_text": "<h3>Design HashMap</h3><p><strong>Algorithm (Array-based with Chaining):</strong></p><p>This solution implements a HashMap using an array of buckets, where each bucket is a list of key-value pairs to handle collisions through chaining.</p><ol><li><strong>Initialization:</strong> Choose a size for the internal array (e.g., 1000 buckets). Initialize each bucket as an empty list.</li><li><strong>Hash Function:</strong> Use <code>key % size</code> to determine which bucket a key belongs to.</li><li><strong>put(key, value):</strong> Calculate the bucket index, then iterate through the bucket. If the key exists, update its value. Otherwise, append the new key-value pair.</li><li><strong>get(key):</strong> Calculate the bucket index, then search for the key in that bucket. Return its value if found, otherwise return -1.</li><li><strong>remove(key):</strong> Calculate the bucket index, then remove the key-value pair from the bucket if it exists.</li></ol><p><strong>Time Complexity:</strong></p><ul><li>Average Case: O(1) for all operations, assuming good hash distribution</li><li>Worst Case: O(N/K) where N is total keys and K is number of buckets</li></ul><p><strong>Space Complexity:</strong> O(K + N) for K buckets and N stored key-value pairs</p><p><strong>Key Insights:</strong></p><ul><li>Each bucket stores [key, value] pairs instead of just keys</li><li>When putting a key that exists, we update in place rather than adding a duplicate</li><li>The modulo operation ensures keys map to valid bucket indices</li></ul>",
  "solution_code": "class MyHashMap:\n\n    def __init__(self):\n        self.size = 1000\n        self.map = [[] for _ in range(self.size)]\n\n    def _hash(self, key: int) -> int:\n        return key % self.size\n\n    def put(self, key: int, value: int) -> None:\n        hash_key = self._hash(key)\n        bucket = self.map[hash_key]\n        for i, (k, v) in enumerate(bucket):\n            if k == key:\n                bucket[i] = [key, value]\n                return\n        bucket.append([key, value])\n\n    def get(self, key: int) -> int:\n        hash_key = self._hash(key)\n        bucket = self.map[hash_key]\n        for k, v in bucket:\n            if k == key:\n                return v\n        return -1\n\n    def remove(self, key: int) -> None:\n        hash_key = self._hash(key)\n        bucket = self.map[hash_key]\n        for i, (k, v) in enumerate(bucket):\n            if k == key:\n                bucket.pop(i)\n                return",
  "prepare": "import re\n\ndef parse_operation(op_str):\n    match = re.match(r'(\\w+)\\((.*)\\)', op_str)\n    if not match:\n        return op_str, []\n    name = match.group(1)\n    args_str = match.group(2).strip()\n    if not args_str:\n        return name, []\n    args = [int(a.strip()) for a in args_str.split(',')]\n    return name, args\n\ndef executeHashMapOperations(operations):\n    results = []\n    hash_map = None\n    for op_str in operations:\n        op, args = parse_operation(op_str)\n        if op == 'MyHashMap':\n            hash_map = MyHashMap()\n            results.append(None)\n        elif op == 'put':\n            hash_map.put(args[0], args[1])\n            results.append(None)\n        elif op == 'get':\n            results.append(hash_map.get(args[0]))\n        elif op == 'remove':\n            hash_map.remove(args[0])\n            results.append(None)\n    return results\n\ndef prepare(test_case_input):\n    return (test_case_input['operations'],)",
  "verify": "def verify(actual_output, expected_output):\n    if len(actual_output) != len(expected_output):\n        return [False, str(actual_output)]\n    \n    for actual, expected in zip(actual_output, expected_output):\n        if actual != expected:\n            return [False, str(actual_output)]\n    \n    return [True, str(actual_output)]",
  "test_cases": [
    {
      "id": 1,
      "input": {
        "operations": ["MyHashMap()", "put(1, 1)", "put(2, 2)", "get(1)", "get(3)", "put(2, 1)", "get(2)", "remove(2)", "get(2)"]
      },
      "output": [null, null, null, 1, -1, null, 1, null, -1]
    },
    {
      "id": 2,
      "input": {
        "operations": ["MyHashMap()", "put(1, 10)", "put(1, 20)", "get(1)", "remove(1)", "get(1)"]
      },
      "output": [null, null, null, 20, null, -1]
    },
    {
      "id": 3,
      "input": {
        "operations": ["MyHashMap()", "get(10)", "put(10, 100)", "get(10)", "put(10, 200)", "get(10)", "get(0)"]
      },
      "output": [null, -1, null, 100, null, 200, -1]
    },
    {
      "id": 4,
      "input": {
        "operations": ["MyHashMap()", "put(5, 50)", "remove(5)", "put(5, 55)", "remove(0)", "get(5)", "get(0)"]
      },
      "output": [null, null, null, null, null, 55, -1]
    },
    {
      "id": 5,
      "input": {
        "operations": ["MyHashMap()", "put(1, 1)", "put(1001, 2)", "put(2001, 3)", "get(1)", "get(1001)", "get(2001)"]
      },
      "output": [null, null, null, null, 1, 2, 3]
    },
    {
      "id": 6,
      "input": {
        "operations": ["MyHashMap()", "put(0, 0)", "put(1000000, 1)", "remove(0)", "remove(1000000)", "get(0)", "get(1000000)"]
      },
      "output": [null, null, null, null, null, -1, -1]
    },
    {
      "id": 7,
      "input": {
        "operations": ["MyHashMap()", "put(1, 1)", "put(2, 2)", "get(1)", "put(2, 1)", "get(2)"]
      },
      "output": [null, null, null, 1, null, 1]
    },
    {
      "id": 8,
      "input": {
        "operations": ["MyHashMap()", "remove(14)", "get(14)"]
      },
      "output": [null, null, -1]
    },
    {
      "id": 9,
      "input": {
        "operations": ["MyHashMap()", "put(1, 1)", "put(2, 2)", "put(3, 3)", "remove(1)", "remove(2)", "remove(3)"]
      },
      "output": [null, null, null, null, null, null, null]
    },
    {
      "id": 10,
      "input": {
        "operations": ["MyHashMap()", "put(1, 1)", "get(1)", "put(1, 2)", "get(1)"]
      },
      "output": [null, null, 1, null, 2]
    }
  ]
}
