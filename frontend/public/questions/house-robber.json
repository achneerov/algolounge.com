{
  "index": 46,
  "filename": "house-robber",
  "title": "House Robber",
  "difficulty": "Medium",
  "tags": ["Dynamic Programming"],
  "keywords": [
    "house",
    "robber",
    "dynamic",
    "programming",
    "dp",
    "maximum",
    "adjacent",
    "optimization",
    "decision",
    "problem"
  ],
  "description": "<h2>House Robber</h2><p>You are given an integer array <code>nums</code> where <code>nums[i]</code> represents the amount of money the <code>i</code>-th house has. The houses are arranged in a straight line, i.e. the <code>i</code>-th house is the neighbor of the <code>(i-1)</code>-th and <code>(i+1)</code>-th house.</p><p>You are planning to rob money from the houses, but you <strong>cannot rob two adjacent houses</strong> because the security system will automatically alert the police if two adjacent houses were both broken into.</p><p>Return the <strong>maximum</strong> amount of money you can rob <strong>without</strong> alerting the police.</p><h3>Examples:</h3><ul><li><strong>Input:</strong> nums = [1,1,3,3]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> nums[0] + nums[2] = 1 + 3 = 4</li><li><strong>Input:</strong> nums = [2,9,8,3,6]<br><strong>Output:</strong> 16<br><strong>Explanation:</strong> nums[0] + nums[2] + nums[4] = 2 + 8 + 6 = 16</li></ul><h3>Constraints:</h3><ul><li><code>1 <= nums.length <= 100</code></li><li><code>0 <= nums[i] <= 100</code></li></ul>",
  "entry_function": "rob",
  "template": "def rob(nums):\n    ",
  "solution_text": "<h3>House Robber</h3><p><strong>Algorithm:</strong></p><ol><li>For each house, make a decision: rob it or skip it</li><li>If rob current house: can't rob previous, so take current + max from 2 houses back</li><li>If skip current house: take max from previous house</li><li>Formula: dp[i] = max(nums[i] + dp[i-2], dp[i-1])</li><li>Use space optimization with two variables</li></ol><p><strong>Time Complexity:</strong> O(n) - single pass through houses</p><p><strong>Space Complexity:</strong> O(1) - constant space with two variables</p><p><strong>Key Insights:</strong></p><ul><li>Classic dynamic programming problem with decision-making</li><li>Each position depends only on previous two positions</li><li>Space can be optimized from O(n) array to O(1) variables</li><li>Similar to Fibonacci but with max() instead of sum</li></ul>",
  "solution_code": "def rob(nums):\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    \n    # dp[i] represents max money we can rob up to house i\n    # We only need to track two previous values\n    prev2 = nums[0]  # dp[i-2]\n    prev1 = max(nums[0], nums[1])  # dp[i-1]\n    \n    for i in range(2, len(nums)):\n        current = max(nums[i] + prev2, prev1)\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1",
  "prepare": "def prepare(test_case_input):\n    \"\"\"Prepare arguments for rob function\"\"\"\n    return (test_case_input['nums'],)",
  "verify": "def verify(actual_output, expected_output):\n    \"\"\"Verify the house robber result\"\"\"\n    passed = actual_output == expected_output\n    output_str = str(actual_output)\n    \n    return [passed, output_str]",
  "test_cases": [
    {
      "id": 1,
      "input": {
        "nums": [
          1,
          1,
          3,
          3
        ]
      },
      "output": 4
    },
    {
      "id": 2,
      "input": {
        "nums": [
          2,
          9,
          8,
          3,
          6
        ]
      },
      "output": 16
    },
    {
      "id": 3,
      "input": {
        "nums": [
          1
        ]
      },
      "output": 1
    },
    {
      "id": 4,
      "input": {
        "nums": [
          2,
          1
        ]
      },
      "output": 2
    },
    {
      "id": 5,
      "input": {
        "nums": [
          5,
          1,
          3,
          9
        ]
      },
      "output": 14
    },
    {
      "id": 6,
      "input": {
        "nums": [
          2,
          7,
          9,
          3,
          1
        ]
      },
      "output": 12
    },
    {
      "id": 7,
      "input": {
        "nums": [
          100,
          1,
          1,
          100
        ]
      },
      "output": 200
    },
    {
      "id": 8,
      "input": {
        "nums": [
          5,
          5,
          10,
          100,
          10,
          5
        ]
      },
      "output": 110
    },
    {
      "id": 9,
      "input": {
        "nums": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10
        ]
      },
      "output": 30
    },
    {
      "id": 10,
      "input": {
        "nums": [
          50,
          1,
          1,
          50,
          1,
          1,
          50
        ]
      },
      "output": 150
    }
  ]
}
