{
  "index": 0,
  "filename": "linked-list-cycle-ii",
  "title": "Linked List Cycle II",
  "difficulty": "Medium",
  "tags": [
    "Linked List",
    "Two Pointers"
  ],
  "keywords": [
    "linked",
    "list",
    "cycle",
    "detection",
    "leetcode",
    "142",
    "head",
    "return",
    "node",
    "floyd",
    "tortoise",
    "hare"
  ],
  "description": "<h2>Linked List Cycle II</h2><p>Given the <code>head</code> of a linked list, return <em>the node where the cycle begins</em>. If there is no cycle, return <code>None</code>.</p><p>There is a cycle in a linked list if some node in the list can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail's <code>next</code> pointer is connected to (<strong>0-indexed</strong>). It is <code>-1</code> if there is no cycle.</p><p><strong>Note:</strong> <code>pos</code> is <strong>not</strong> passed as a parameter.</p><p><strong>Do not modify</strong> the linked list.</p><h3>Examples:</h3><ul><li><strong>Input:</strong> head = [3,2,0,-4], pos = 1<br><strong>Output:</strong> Node at index 1<br><strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the second node (index 1).<pre>3 → 2 → 0 → -4\n    ↑        |\n    └────────┘</pre></li><li><strong>Input:</strong> head = [1,2], pos = 0<br><strong>Output:</strong> Node at index 0<br><strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the first node (index 0).<pre>1 → 2\n↑   |\n└───┘</pre></li><li><strong>Input:</strong> head = [1], pos = -1<br><strong>Output:</strong> None<br><strong>Explanation:</strong> There is no cycle in the linked list.</li></ul><h3>Constraints:</h3><ul><li>The number of nodes in the list is in the range <code>[0, 10^4]</code></li><li><code>-10^5 <= Node.val <= 10^5</code></li><li><code>pos</code> is <code>-1</code> or a valid index in the linked list</li></ul>",
  "entry_function": "detectCycle",
  "template": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef detectCycle(head):\n    ",
  "solution_text": "<h3>Linked List Cycle II - Floyd's Tortoise and Hare</h3>\n\n<p><strong>Algorithm:</strong></p>\n<ol>\n<li>Use two pointers: slow (moves 1 step) and fast (moves 2 steps)</li>\n<li>If they meet, a cycle exists</li>\n<li>Reset one pointer to head, keep the other at meeting point</li>\n<li>Move both one step at a time - they'll meet at cycle start</li>\n</ol>\n\n<p><strong>Why does this work?</strong></p>\n<p>Let's say the distance from head to cycle start is <code>a</code>, and the distance from cycle start to meeting point is <code>b</code>. When slow and fast meet:</p>\n<ul>\n<li>Slow traveled: <code>a + b</code></li>\n<li>Fast traveled: <code>2(a + b)</code></li>\n<li>The difference <code>a + b</code> equals one full cycle length</li>\n<li>So traveling <code>a</code> more steps from meeting point reaches cycle start</li>\n</ul>\n\n<p><strong>Time Complexity:</strong> O(n)</p>\n<p><strong>Space Complexity:</strong> O(1)</p>",
  "solution_code": "def detectCycle(head):\n    if not head or not head.next:\n        return None\n    \n    # Phase 1: Detect if cycle exists using Floyd's algorithm\n    slow = head\n    fast = head\n    \n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        \n        if slow == fast:\n            # Cycle detected, now find the start\n            # Phase 2: Find cycle start\n            slow = head\n            while slow != fast:\n                slow = slow.next\n                fast = fast.next\n            return slow\n    \n    # No cycle\n    return None",
  "prepare": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        self._index = -1\n    \n    def __repr__(self):\n        return f'ListNode({self.val})'\n\ndef prepare(test_case_input):\n    \"\"\"Convert array representation to ListNode with possible cycle\"\"\"\n    arr = test_case_input['head']\n    pos = test_case_input['pos']\n    \n    if not arr:\n        return (None,)\n    \n    # Build linked list\n    head = ListNode(arr[0])\n    head._index = 0\n    current = head\n    nodes = [head]\n    \n    for i, val in enumerate(arr[1:], 1):\n        new_node = ListNode(val)\n        new_node._index = i\n        current.next = new_node\n        current = new_node\n        nodes.append(new_node)\n    \n    # Create cycle if pos >= 0\n    if pos >= 0 and pos < len(nodes):\n        current.next = nodes[pos]\n    \n    return (head,)",
  "verify": "def verify(actual_output, expected_output):\n    \"\"\"Verify the cycle detection result - return the index of cycle start or None\"\"\"\n    if actual_output is None:\n        actual_index = None\n    else:\n        actual_index = actual_output._index\n    \n    passed = actual_index == expected_output\n    display = 'None' if actual_index is None else str(actual_index)\n    return [passed, display]",
  "test_cases": [
    {
      "id": 1,
      "input": {
        "head": [3, 2, 0, -4],
        "pos": 1
      },
      "output": 1
    },
    {
      "id": 2,
      "input": {
        "head": [1, 2],
        "pos": 0
      },
      "output": 0
    },
    {
      "id": 3,
      "input": {
        "head": [1],
        "pos": -1
      },
      "output": null
    },
    {
      "id": 4,
      "input": {
        "head": [1, 2, 3, 4, 5],
        "pos": -1
      },
      "output": null
    },
    {
      "id": 5,
      "input": {
        "head": [1, 2, 3, 4, 5],
        "pos": 2
      },
      "output": 2
    },
    {
      "id": 6,
      "input": {
        "head": [],
        "pos": -1
      },
      "output": null
    },
    {
      "id": 7,
      "input": {
        "head": [7, 8, 9, 10],
        "pos": 3
      },
      "output": 3
    },
    {
      "id": 8,
      "input": {
        "head": [5, 6],
        "pos": -1
      },
      "output": null
    },
    {
      "id": 9,
      "input": {
        "head": [10, 20, 30],
        "pos": 0
      },
      "output": 0
    },
    {
      "id": 10,
      "input": {
        "head": [100, 200, 300, 400, 500, 600],
        "pos": 4
      },
      "output": 4
    }
  ]
}
