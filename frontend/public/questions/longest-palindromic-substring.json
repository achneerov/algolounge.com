{
  "index": 55,
  "filename": "longest-palindromic-substring",
  "title": "Longest Palindromic Substring",
  "keywords": [
    "longest",
    "palindrome",
    "substring",
    "string",
    "expand",
    "center",
    "two-pointers",
    "dynamic",
    "programming",
    "pattern"
  ],
  "description": "<h2>Longest Palindromic Substring</h2><p>Given a string <code>s</code>, return the longest substring of <code>s</code> that is a palindrome.</p><p>A <strong>palindrome</strong> is a string that reads the same forward and backward.</p><p>If there are multiple palindromic substrings that have the same length, return any one of them.</p><h3>Examples:</h3><ul><li><strong>Input:</strong> s = \"ababd\"<br><strong>Output:</strong> \"bab\" (or \"aba\")<br><strong>Explanation:</strong> Both \"aba\" and \"bab\" are valid answers.</li><li><strong>Input:</strong> s = \"abbc\"<br><strong>Output:</strong> \"bb\"</li><li><strong>Input:</strong> s = \"a\"<br><strong>Output:</strong> \"a\"</li></ul><h3>Constraints:</h3><ul><li><code>1 <= s.length <= 1000</code></li><li><code>s</code> consists of only digits and English letters</li></ul>",
  "entry_function": "longestPalindrome",
  "template": "def longestPalindrome(s):\n    ",
  "solution_text": "<h3>Longest Palindromic Substring</h3><p><strong>Algorithm: Expand Around Centers</strong></p><ol><li>For each possible center (character or between characters), expand outward</li><li>Check if characters on both sides match while expanding</li><li>Track the longest palindrome found</li><li>Handle both odd-length (center is a character) and even-length (center between characters) palindromes</li></ol><p><strong>Time Complexity:</strong> O(n²) - for each center, potentially expand n characters</p><p><strong>Space Complexity:</strong> O(1) - only using variables to track indices</p><p><strong>Key Insights:</strong></p><ul><li>Palindromes expand from their center symmetrically</li><li>Two types of centers: single character (odd length) and between characters (even length)</li><li>More efficient than checking all O(n²) substrings</li><li>Avoids the O(n³) brute force approach</li></ul>",
  "solution_code": "def longestPalindrome(s):\n    if not s:\n        return \"\"\n    \n    if len(s) == 1:\n        return s\n    \n    def expand_around_center(left, right):\n        # Expand around center while characters match\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        # Return the valid palindrome (exclude the mismatched characters)\n        return s[left + 1:right]\n    \n    longest = \"\"\n    \n    for i in range(len(s)):\n        # Check for odd-length palindromes (center is a character)\n        odd_palindrome = expand_around_center(i, i)\n        if len(odd_palindrome) > len(longest):\n            longest = odd_palindrome\n        \n        # Check for even-length palindromes (center is between characters)\n        if i < len(s) - 1:\n            even_palindrome = expand_around_center(i, i + 1)\n            if len(even_palindrome) > len(longest):\n                longest = even_palindrome\n    \n    return longest",
  "prepare": "def prepare(test_case_input):\n    \"\"\"Prepare arguments for longestPalindrome function\"\"\"\n    # Store input string for verification\n    global _input_string\n    _input_string = test_case_input['s']\n    return (test_case_input['s'],)",
  "verify": "def verify(actual_output, expected_output):\n    \"\"\"Verify the longest palindromic substring result\"\"\"\n    def is_palindrome(s):\n        if not isinstance(s, str):\n            return False\n        return s == s[::-1]\n    \n    output_str = '\"' + str(actual_output) + '\"'\n    \n    # Check if actual output is a string\n    if not isinstance(actual_output, str):\n        return [False, output_str]\n    \n    # Check if actual output is a valid palindrome\n    if not is_palindrome(actual_output):\n        return [False, output_str]\n    \n    # Check if the palindrome actually exists in the input string\n    if actual_output not in _input_string:\n        return [False, output_str]\n    \n    # Check if lengths match (multiple valid answers possible)\n    passed = len(actual_output) == len(expected_output)\n    \n    return [passed, output_str]",
  "test_cases": [
    {
      "id": 1,
      "input": {
        "s": "ababd"
      },
      "output": "bab"
    },
    {
      "id": 2,
      "input": {
        "s": "abbc"
      },
      "output": "bb"
    },
    {
      "id": 3,
      "input": {
        "s": "a"
      },
      "output": "a"
    },
    {
      "id": 4,
      "input": {
        "s": "aa"
      },
      "output": "aa"
    },
    {
      "id": 5,
      "input": {
        "s": "abc"
      },
      "output": "a"
    },
    {
      "id": 6,
      "input": {
        "s": "racecar"
      },
      "output": "racecar"
    },
    {
      "id": 7,
      "input": {
        "s": "abcdef"
      },
      "output": "a"
    },
    {
      "id": 8,
      "input": {
        "s": "noon"
      },
      "output": "noon"
    },
    {
      "id": 9,
      "input": {
        "s": "abacabad"
      },
      "output": "abacaba"
    },
    {
      "id": 10,
      "input": {
        "s": "cbbd"
      },
      "output": "bb"
    }
  ]
}
