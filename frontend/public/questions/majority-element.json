{
  "index": 119,
  "filename": "majority-element",
  "title": "Majority Element",
  "difficulty": "Easy",
  "tags": [
    "Arrays and Hashing",
    "Bit Manipulation"
  ],
  "keywords": [
    "majority",
    "element",
    "array",
    "voting",
    "boyer-moore",
    "frequency",
    "leetcode",
    "169"
  ],
  "description": "<h2>Majority Element</h2><p>Given an array <code>nums</code> of size <code>n</code>, return the <strong>majority element</strong>.</p><p>The majority element is the element that appears more than <code>⌊n / 2⌋</code> times. You may assume that the majority element always exists in the array.</p><h3>Examples:</h3><ul><li><strong>Input:</strong> nums = [3,2,3]<br><strong>Output:</strong> 3</li><li><strong>Input:</strong> nums = [2,2,1,1,1,2,2]<br><strong>Output:</strong> 2</li><li><strong>Input:</strong> nums = [1]<br><strong>Output:</strong> 1</li></ul><h3>Constraints:</h3><ul><li><code>1 &lt;= nums.length &lt;= 5 * 10^4</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li><li>The majority element always exists in the array</li></ul><h3>Follow-up:</h3><p>Could you solve this in linear time with O(1) space complexity?</p>",
  "entry_function": "majorityElement",
  "template": "def majorityElement(nums):\n    ",
  "solution_text": "<h3>Majority Element - Boyer-Moore Voting Algorithm</h3><p><strong>Algorithm:</strong></p><ol><li>Initialize candidate and count variables</li><li>Iterate through the array</li><li>If count is 0, set current number as candidate</li><li>If current number equals candidate, increment count</li><li>Otherwise, decrement count</li><li>Return the candidate (guaranteed to be majority element)</li></ol><p><strong>Time Complexity:</strong> O(n) - single pass through array</p><p><strong>Space Complexity:</strong> O(1) - constant space</p><p><strong>Key Insights:</strong></p><ul><li>Boyer-Moore Voting Algorithm is optimal for this problem</li><li>Works because majority element appears more than n/2 times</li><li>When majority and non-majority cancel out, majority still dominates</li><li>Linear time with constant space - best possible</li><li>Alternative: hash map O(n) time, O(n) space</li></ul>",
  "solution_code": "def majorityElement(nums):\n    candidate = None\n    count = 0\n    \n    for num in nums:\n        if count == 0:\n            candidate = num\n        count += (1 if num == candidate else -1)\n    \n    return candidate",
  "prepare": "def prepare(test_case_input):\n    \"\"\"Prepare arguments for majorityElement function\"\"\"\n    return (test_case_input['nums'],)",
  "verify": "def verify(actual_output, expected_output):\n    \"\"\"Verify the majority element result\"\"\"\n    passed = actual_output == expected_output\n    return [passed, str(actual_output)]",
  "test_cases": [
    {
      "id": 1,
      "input": {
        "nums": [
          3,
          2,
          3
        ]
      },
      "output": 3
    },
    {
      "id": 2,
      "input": {
        "nums": [
          2,
          2,
          1,
          1,
          1,
          2,
          2
        ]
      },
      "output": 2
    },
    {
      "id": 3,
      "input": {
        "nums": [
          1
        ]
      },
      "output": 1
    },
    {
      "id": 4,
      "input": {
        "nums": [
          1,
          1,
          1,
          1
        ]
      },
      "output": 1
    },
    {
      "id": 5,
      "input": {
        "nums": [
          5,
          5,
          5,
          1,
          1
        ]
      },
      "output": 5
    },
    {
      "id": 6,
      "input": {
        "nums": [
          1,
          2,
          3,
          3,
          3
        ]
      },
      "output": 3
    },
    {
      "id": 7,
      "input": {
        "nums": [
          -1,
          -1,
          -1,
          1,
          2
        ]
      },
      "output": -1
    },
    {
      "id": 8,
      "input": {
        "nums": [
          10,
          9,
          9,
          9,
          10
        ]
      },
      "output": 9
    }
  ]
}
