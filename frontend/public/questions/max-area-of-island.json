{
  "index": 202,
  "filename": "max-area-of-island",
  "title": "Max Area of Island",
  "difficulty": "Medium",
  "tags": [
    "Graph",
    "DFS",
    "Matrix"
  ],
  "keywords": [
    "island",
    "area",
    "maximum",
    "grid",
    "dfs",
    "leetcode",
    "695",
    "matrix",
    "graph",
    "medium"
  ],
  "description": "<h2>Max Area of Island</h2><p>You are given an <code>m x n</code> binary matrix <code>grid</code>. An island is a group of <code>1</code>'s (representing land) connected <strong>4-directionally</strong> (horizontal or vertical). You may assume all four edges of the grid are surrounded by water.</p><p>The <strong>area</strong> of an island is the number of cells with a value <code>1</code> in the island.</p><p>Return <em>the maximum <strong>area</strong> of an island in</em> <code>grid</code>. If there is no island, return <code>0</code>.</p><h3>Examples</h3><ul><li>Input: <code>grid = [<br>  [1,1,0,0,0],<br>  [1,1,0,0,0],<br>  [0,0,0,1,1],<br>  [0,0,0,1,1]<br>]</code><br>Output: <code>4</code><br>Explanation: Two islands of equal size (4 cells each).</li><li>Input: <code>grid = [<br>  [1,1,1],<br>  [1,0,1],<br>  [1,1,1]<br>]</code><br>Output: <code>8</code><br>Explanation: The island wraps around the center water cell.</li><li>Input: <code>grid = [[0,0,0,0,0,0,0,0]]</code><br>Output: <code>0</code><br>Explanation: No islands in the grid.</li></ul><h3>Constraints</h3><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 <= m, n <= 50</code></li><li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code></li></ul>",
  "entry_function": "maxAreaOfIsland",
  "template": "def maxAreaOfIsland(grid):\n    ",
  "solution_text": "<h3>Max Area of Island</h3><p><strong>Algorithm (DFS Approach):</strong></p><ol><li>Iterate through each cell in the grid</li><li>When finding an unvisited land cell (1), start DFS to calculate area</li><li>DFS returns the total area of the island starting from that cell</li><li>Mark visited cells by changing 1 to 0</li><li>Track the maximum area found across all islands</li></ol><p><strong>Time Complexity:</strong> O(m × n) - visit each cell at most once</p><p><strong>Space Complexity:</strong> O(m × n) - worst case recursion depth if entire grid is one island</p><p><strong>Key Insights:</strong></p><ul><li>DFS function returns 1 + sum of areas from all 4 neighbors</li><li>Base case returns 0 for out-of-bounds or water cells</li><li>Modify grid in-place to mark visited cells</li><li>Keep track of maximum area seen so far</li></ul>",
  "solution_code": "def maxAreaOfIsland(grid):\n    if not grid or not grid[0]:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    max_area = 0\n    \n    def dfs(r, c):\n        # Base cases: out of bounds or water\n        if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0:\n            return 0\n        \n        # Mark current cell as visited\n        grid[r][c] = 0\n        \n        # Calculate area: 1 (current cell) + areas from all 4 directions\n        area = 1\n        area += dfs(r + 1, c)  # down\n        area += dfs(r - 1, c)  # up\n        area += dfs(r, c + 1)  # right\n        area += dfs(r, c - 1)  # left\n        \n        return area\n    \n    # Iterate through each cell\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 1:\n                max_area = max(max_area, dfs(r, c))\n    \n    return max_area",
  "prepare": "def prepare(test_case_input):\n    \"\"\"Prepare arguments for maxAreaOfIsland function\"\"\"\n    # Deep copy the grid to avoid modifying the test case\n    import copy\n    grid_copy = copy.deepcopy(test_case_input['grid'])\n    return (grid_copy,)",
  "verify": "def verify(actual_output, expected_output):\n    \"\"\"Verify the max area of island result\"\"\"\n    passed = actual_output == expected_output\n    output_str = str(actual_output)\n    \n    return [passed, output_str]",
  "test_cases": [
    {
      "id": 1,
      "input": {
        "grid": [
          [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],
          [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],
          [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]
        ]
      },
      "output": 6
    },
    {
      "id": 2,
      "input": {
        "grid": [
          [0, 0, 0, 0, 0, 0, 0, 0]
        ]
      },
      "output": 0
    },
    {
      "id": 3,
      "input": {
        "grid": [
          [1, 1, 0, 0, 0],
          [1, 1, 0, 0, 0],
          [0, 0, 0, 1, 1],
          [0, 0, 0, 1, 1]
        ]
      },
      "output": 4
    },
    {
      "id": 4,
      "input": {
        "grid": [
          [1, 0, 1],
          [0, 1, 0],
          [1, 0, 1]
        ]
      },
      "output": 1
    },
    {
      "id": 5,
      "input": {
        "grid": [
          [1, 1, 1],
          [1, 0, 1],
          [1, 1, 1]
        ]
      },
      "output": 8
    },
    {
      "id": 6,
      "input": {
        "grid": [
          [1]
        ]
      },
      "output": 1
    },
    {
      "id": 7,
      "input": {
        "grid": [
          [0]
        ]
      },
      "output": 0
    },
    {
      "id": 8,
      "input": {
        "grid": [
          [1, 1, 1, 1],
          [1, 1, 1, 1],
          [1, 1, 1, 1]
        ]
      },
      "output": 12
    }
  ]
}
