{
  "index": 1,
  "filename": "meeting-rooms-ii",
  "title": "Meeting Rooms II",
  "keywords": [
    "meeting",
    "intervals",
    "sorting",
    "heap",
    "priority",
    "queue",
    "medium",
    "leetcode"
  ],
  "description": "<h2>Meeting Rooms II</h2><p>Given an array of meeting time intervals <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, return the minimum number of conference rooms required.</p><h3>Examples:</h3><ul><li><strong>Input:</strong> intervals = [[0,30],[5,10],[15,20]]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> We need two rooms: one for [0,30] and one for [5,10] (or [15,20]).</li><li><strong>Input:</strong> intervals = [[7,10],[2,4]]<br><strong>Output:</strong> 1<br><strong>Explanation:</strong> The two meetings do not overlap, so we only need one room.</li></ul><h3>Constraints:</h3><ul><li><code>1 <= intervals.length <= 10^4</code></li><li><code>0 <= starti < endi <= 10^6</code></li></ul>",
  "entry_function": "minMeetingRooms",
  "template": "def minMeetingRooms(intervals):\n    ",
  "solution_text": "<h3>Meeting Rooms II</h3><p><strong>Algorithm:</strong></p><ol><li>Sort intervals by start time</li><li>Use a min heap to track end times of meetings in progress</li><li>For each meeting, remove all meetings from heap that have ended</li><li>Add current meeting's end time to heap</li><li>Track maximum heap size as the answer</li></ol><p><strong>Time Complexity:</strong> O(n log n) for sorting and heap operations</p><p><strong>Space Complexity:</strong> O(n) for the heap</p><p><strong>Key Insights:</strong></p><ul><li>The heap size represents the number of rooms needed at any time</li><li>Removing meetings that ended frees up rooms</li><li>Maximum heap size is the minimum rooms needed</li><li>Alternative: Use separate sorted arrays for start and end times</li></ul>",
  "solution_code": "import heapq\n\ndef minMeetingRooms(intervals):\n    if not intervals:\n        return 0\n    \n    # Sort by start time\n    intervals.sort(key=lambda x: x[0])\n    \n    # Min heap to track end times\n    heap = []\n    max_rooms = 0\n    \n    for start, end in intervals:\n        # Remove all meetings that have ended\n        while heap and heap[0] <= start:\n            heapq.heappop(heap)\n        \n        # Add current meeting\n        heapq.heappush(heap, end)\n        \n        # Track maximum rooms needed\n        max_rooms = max(max_rooms, len(heap))\n    \n    return max_rooms",
  "prepare": "def prepare(test_case_input):\n    \"\"\"Prepare arguments for minMeetingRooms function\"\"\"\n    return (test_case_input['intervals'],)",
  "verify": "def verify(actual_output, expected_output):\n    \"\"\"Verify the meeting rooms result\"\"\"\n    passed = actual_output == expected_output\n    output_str = str(actual_output)\n    return [passed, output_str]",
  "test_cases": [
    {
      "id": 1,
      "input": {
        "intervals": [
          [0, 30],
          [5, 10],
          [15, 20]
        ]
      },
      "output": 2
    },
    {
      "id": 2,
      "input": {
        "intervals": [
          [7, 10],
          [2, 4]
        ]
      },
      "output": 1
    },
    {
      "id": 3,
      "input": {
        "intervals": [
          [1, 5],
          [2, 6],
          [3, 7],
          [4, 8]
        ]
      },
      "output": 4
    },
    {
      "id": 4,
      "input": {
        "intervals": [
          [1, 5],
          [8, 9],
          [8, 9]
        ]
      },
      "output": 2
    },
    {
      "id": 5,
      "input": {
        "intervals": [
          [9, 10],
          [4, 9],
          [4, 17]
        ]
      },
      "output": 2
    }
  ]
}
