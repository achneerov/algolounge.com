{
  "index": 59,
  "filename": "merge-two-sorted-lists",
  "title": "Merge Two Sorted Linked Lists",
  "difficulty": "Easy",
  "tags": [
    "Linked List"
  ],
  "keywords": [
    "merge",
    "two",
    "sorted",
    "linked",
    "lists",
    "leetcode",
    "given",
    "heads",
    "list1",
    "list2"
  ],
  "description": "<h2>Merge Two Sorted Linked Lists</h2><p>Leetcode 21. Merge Two Sorted Lists</p><p>You are given the heads of two sorted linked lists <code>list1</code> and <code>list2</code>.</p><p>Merge the two lists into one <strong>sorted</strong> linked list and return the head of the new sorted linked list.</p><p>The new list should be made up of nodes from <code>list1</code> and <code>list2</code>.</p><h3>Examples:</h3><ul><li>Input: list1 = [], list2 = [1,2]<br><br>Output: [1,2]</li><li>Input: list1 = [], list2 = []<br><br>Output: []</li></ul><h3>Constraints:</h3><ul><li><code>0 <= The length of the each list <= 100</code></li><li><code>-100 <= Node.val <= 100</code></li></ul>",
  "entry_function": "mergeTwoLists",
  "template": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef mergeTwoLists(list1, list2):\n    ",
  "solution_text": "<h3>Two-Pointer Approach for Merging Sorted Linked Lists</h3>\n\n<p><strong>Algorithm:</strong></p>\n<ul>\n<li>Create a dummy node to simplify edge case handling</li>\n<li>Use two pointers to traverse both linked lists</li>\n<li>Compare current values and attach smaller node to result</li>\n<li>Append remaining nodes from non-exhausted list</li>\n</ul>\n\n<p><strong>Time Complexity:</strong> O(m + n) - visit each node once</p>\n<p><strong>Space Complexity:</strong> O(1) - only using pointers</p>\n\n<p><strong>Key Insights:</strong></p>\n<ul>\n<li>Dummy node simplifies head management</li>\n<li>Two-pointer technique for sorted data</li>\n<li>Handle different length lists efficiently</li>\n</ul>",
  "solution_code": "def mergeTwoLists(list1, list2):\n    # Create dummy node to simplify logic\n    dummy = ListNode(0)\n    current = dummy\n    \n    # Merge while both lists have nodes\n    while list1 and list2:\n        if list1.val <= list2.val:\n            current.next = list1\n            list1 = list1.next\n        else:\n            current.next = list2\n            list2 = list2.next\n        current = current.next\n    \n    # Attach remaining nodes\n    current.next = list1 or list2\n    \n    return dummy.next",
  "prepare": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n    \n    def __repr__(self):\n        return f'ListNode({self.val})'\n\ndef prepare(test_case_input):\n    \"\"\"Convert array representation to ListNode structure\"\"\"\n    def build_list(arr):\n        if not arr:\n            return None\n        head = ListNode(arr[0])\n        current = head\n        for val in arr[1:]:\n            current.next = ListNode(val)\n            current = current.next\n        return head\n    \n    list1 = build_list(test_case_input['list1'])\n    list2 = build_list(test_case_input['list2'])\n    return (list1, list2)",
  "verify": "def verify(actual_output, expected_output):\n    \"\"\"Verify the merged linked list result\"\"\"\n    def list_to_array(node):\n        result = []\n        while node:\n            result.append(node.val)\n            node = node.next\n        return result\n    \n    def list_to_string(lst):\n        if not lst:\n            return '[]'\n        return '[' + ', '.join(str(x) for x in lst) + ']'\n    \n    actual_array = list_to_array(actual_output)\n    passed = actual_array == expected_output\n    output_str = list_to_string(actual_array)\n    \n    return [passed, output_str]",
  "test_cases": [
    {
      "id": 1,
      "input": {
        "list1": [
          1,
          2,
          4
        ],
        "list2": [
          1,
          3,
          4
        ]
      },
      "output": [
        1,
        1,
        2,
        3,
        4,
        4
      ]
    },
    {
      "id": 2,
      "input": {
        "list1": [],
        "list2": []
      },
      "output": []
    },
    {
      "id": 3,
      "input": {
        "list1": [],
        "list2": [
          0
        ]
      },
      "output": [
        0
      ]
    },
    {
      "id": 4,
      "input": {
        "list1": [
          1
        ],
        "list2": [
          2
        ]
      },
      "output": [
        1,
        2
      ]
    },
    {
      "id": 5,
      "input": {
        "list1": [
          1,
          3,
          5
        ],
        "list2": [
          2,
          4,
          6
        ]
      },
      "output": [
        1,
        2,
        3,
        4,
        5,
        6
      ]
    },
    {
      "id": 6,
      "input": {
        "list1": [
          1,
          1,
          1
        ],
        "list2": [
          2,
          2,
          2
        ]
      },
      "output": [
        1,
        1,
        1,
        2,
        2,
        2
      ]
    },
    {
      "id": 7,
      "input": {
        "list1": [
          5
        ],
        "list2": [
          1,
          2,
          3,
          4
        ]
      },
      "output": [
        1,
        2,
        3,
        4,
        5
      ]
    },
    {
      "id": 8,
      "input": {
        "list1": [
          -10,
          -5,
          0
        ],
        "list2": [
          -8,
          -2,
          4
        ]
      },
      "output": [
        -10,
        -8,
        -5,
        -2,
        0,
        4
      ]
    },
    {
      "id": 9,
      "input": {
        "list1": [
          1,
          2,
          3
        ],
        "list2": []
      },
      "output": [
        1,
        2,
        3
      ]
    },
    {
      "id": 10,
      "input": {
        "list1": [
          1,
          100
        ],
        "list2": [
          50
        ]
      },
      "output": [
        1,
        50,
        100
      ]
    }
  ]
}
