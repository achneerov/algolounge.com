{
  "index": 1,
  "filename": "minimum-interval-to-include-each-query",
  "title": "Minimum Interval to Include Each Query",
  "keywords": [
    "minimum",
    "interval",
    "query",
    "intervals",
    "sorting",
    "heap",
    "priority",
    "queue",
    "binary",
    "search",
    "leetcode"
  ],
  "description": "<h2>Minimum Interval to Include Each Query</h2><p>You are given a 2D integer array <code>intervals</code>, where <code>intervals[i] = [lefti, righti]</code> describes the ith interval starting at <code>lefti</code> and ending at <code>righti</code> (inclusive). The size of an interval is defined as the number of integers it contains, or more formally <code>righti - lefti + 1</code>.</p><p>You are also given an integer array <code>queries</code>. The answer to the jth query is the size of the smallest interval i such that <code>lefti <= queries[j] <= righti</code>. If no such interval exists, the answer is -1.</p><p>Return an array containing the answers to the queries.</p><h3>Examples:</h3><ul><li><strong>Input:</strong> intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]<br><strong>Output:</strong> [3,3,1,4]<br><strong>Explanation:</strong> The queries are processed as follows:<br>- Query = 2: The interval [2,4] is the smallest interval containing 2. The answer is 4 - 2 + 1 = 3.<br>- Query = 3: The interval [2,4] is the smallest interval containing 3. The answer is 4 - 2 + 1 = 3.<br>- Query = 4: The interval [4,4] is the smallest interval containing 4. The answer is 4 - 4 + 1 = 1.<br>- Query = 5: The interval [3,6] is the smallest interval containing 5. The answer is 6 - 3 + 1 = 4.</li><li><strong>Input:</strong> intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]<br><strong>Output:</strong> [2,-1,4,6]<br><strong>Explanation:</strong> The queries are processed as follows:<br>- Query = 2: The interval [2,3] is the smallest interval containing 2. The answer is 3 - 2 + 1 = 2.<br>- Query = 19: None of the intervals contain 19. The answer is -1.<br>- Query = 5: The interval [2,5] is the smallest interval containing 5. The answer is 5 - 2 + 1 = 4.<br>- Query = 22: The interval [20,25] is the smallest interval containing 22. The answer is 25 - 20 + 1 = 6.</li></ul><h3>Constraints:</h3><ul><li><code>1 <= intervals.length <= 10^5</code></li><li><code>1 <= queries.length <= 10^5</code></li><li><code>intervals[i].length == 2</code></li><li><code>1 <= lefti <= righti <= 10^7</code></li><li><code>1 <= queries[j] <= 10^7</code></li></ul>",
  "entry_function": "minInterval",
  "template": "def minInterval(intervals, queries):\n    ",
  "solution_text": "<h3>Minimum Interval to Include Each Query</h3><p><strong>Algorithm:</strong></p><ol><li>Create list of (query, original_index) pairs and sort by query value</li><li>Sort intervals by left endpoint</li><li>Use a min heap to track intervals by size</li><li>For each query in sorted order, add all intervals that start <= query to heap</li><li>Remove intervals from heap that end < query</li><li>The top of heap is the smallest valid interval</li><li>Place result at original query index</li></ol><p><strong>Time Complexity:</strong> O(n log n + m log m) where n = intervals, m = queries</p><p><strong>Space Complexity:</strong> O(n + m) for heap and result storage</p><p><strong>Key Insights:</strong></p><ul><li>Processing queries in sorted order optimizes interval filtering</li><li>Min heap by size allows quick retrieval of smallest interval</li><li>Tracking original indices maintains query order in result</li><li>Lazy deletion of invalid intervals from heap is efficient</li></ul>",
  "solution_code": "import heapq\n\ndef minInterval(intervals, queries):\n    # Sort intervals by left endpoint\n    intervals.sort()\n    \n    # Create query list with original indices\n    query_list = [(q, i) for i, q in enumerate(queries)]\n    query_list.sort()\n    \n    result = [-1] * len(queries)\n    min_heap = []  # (size, right endpoint)\n    interval_idx = 0\n    \n    for query, original_idx in query_list:\n        # Add all intervals that start <= query\n        while interval_idx < len(intervals) and intervals[interval_idx][0] <= query:\n            left, right = intervals[interval_idx]\n            size = right - left + 1\n            heapq.heappush(min_heap, (size, right))\n            interval_idx += 1\n        \n        # Remove intervals that end before query\n        while min_heap and min_heap[0][1] < query:\n            heapq.heappop(min_heap)\n        \n        # Get smallest valid interval\n        if min_heap:\n            size, right = min_heap[0]\n            # Verify the interval actually contains the query\n            if right >= query:\n                result[original_idx] = size\n    \n    return result",
  "prepare": "def prepare(test_case_input):\n    \"\"\"Prepare arguments for minInterval function\"\"\"\n    return (test_case_input['intervals'], test_case_input['queries'])",
  "verify": "def verify(actual_output, expected_output):\n    \"\"\"Verify the minimum interval result\"\"\"\n    passed = actual_output == expected_output\n    output_str = str(actual_output)\n    return [passed, output_str]",
  "test_cases": [
    {
      "id": 1,
      "input": {
        "intervals": [
          [1, 4],
          [2, 4],
          [3, 6],
          [4, 4]
        ],
        "queries": [2, 3, 4, 5]
      },
      "output": [3, 3, 1, 4]
    },
    {
      "id": 2,
      "input": {
        "intervals": [
          [2, 3],
          [2, 5],
          [1, 8],
          [20, 25]
        ],
        "queries": [2, 19, 5, 22]
      },
      "output": [2, -1, 4, 6]
    },
    {
      "id": 3,
      "input": {
        "intervals": [
          [1, 1],
          [2, 2],
          [3, 3],
          [4, 4],
          [5, 5]
        ],
        "queries": [1, 2, 3, 4, 5]
      },
      "output": [1, 1, 1, 1, 1]
    },
    {
      "id": 4,
      "input": {
        "intervals": [
          [1, 5],
          [2, 6],
          [3, 7]
        ],
        "queries": [1, 3, 5, 7]
      },
      "output": [5, 5, 5, 5]
    },
    {
      "id": 5,
      "input": {
        "intervals": [
          [100, 200]
        ],
        "queries": [50, 100, 150, 200, 250]
      },
      "output": [-1, 101, 101, 101, -1]
    }
  ]
}
