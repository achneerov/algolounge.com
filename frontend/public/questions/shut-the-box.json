{
  "index": 217,
  "filename": "shut-the-box",
  "title": "Shut the Box",
  "difficulty": "Hard",
  "tags": [
    "Matrix",
    "BFS",
    "3D Geometry",
    "Enumeration"
  ],
  "keywords": [
    "shut",
    "box",
    "cuboid",
    "net",
    "fold",
    "grid",
    "panels",
    "surface area",
    "3d",
    "bfs",
    "mesh",
    "rectangular"
  ],
  "description": "<h2>Shut the Box</h2>\n<p>You are a warehouse associate at an Amazon fulfilment centre. Your job is to take a flat cardboard net \u2014 a connected arrangement of square panels on a cutting board \u2014 and decide whether it can be folded up to form a complete rectangular box (cuboid) ready for shipping.</p>\n<p>You are given an <code>n \u00d7 n</code> binary grid (up to <code>20 \u00d7 20</code>) where <code>1</code> represents a panel and <code>0</code> represents empty space. Determine whether the panels form a valid net for <strong>any</strong> rectangular box with positive integer dimensions <em>a \u00d7 b \u00d7 c</em>. If so, return the dimensions <code>[a, b, c]</code> sorted in ascending order. If the panels cannot be folded into any box, return an empty array.</p>\n<p>A valid fold must satisfy all of the following:</p>\n<ul>\n<li>Every panel is used <strong>exactly once</strong></li>\n<li>No two panels overlap after folding</li>\n<li>Every face of the resulting box is completely covered</li>\n<li>All panels must form a <strong>connected region</strong> \u2014 a disconnected region cannot be folded into a single box</li>\n</ul>\n<h3>Examples:</h3>\n<ul>\n<li><strong>Input:</strong> grid =<br>........<br>..##....<br>######..<br>..##.###<br>####....<br>...#....<br>..#####.<br>####.#..<br><strong>Output:</strong> [1, 2, 4]</li>\n<li><strong>Input:</strong> grid =<br>.....##.........##..<br>......##.##...#####.<br>......#...##.##.#...<br>......##.#####..###.<br>.......###.##...#.#.<br>.....###...##...#...<br>.....####.##....##..<br>.#######..###...###.<br>###..##...#####.##..<br>.##.####..#.##..#...<br>....#####.#....###..<br>.##...#.#.##...#....<br>..#...#...##........<br>..##.####.#.........<br>..#####.............<br>.....###..##........<br>.......#####........<br>........#..###......<br>.......###..#.......<br>........#...........<br><strong>Output:</strong> [2, 6, 7]</li>\n<li><strong>Input:</strong> grid =<br>..########<br>..........<br>..........<br>######....<br>..........<br>..........<br>..........<br>..........<br>..........<br>..........<br><strong>Output:</strong> []<br><strong>Explanation:</strong> Two disconnected strips cannot fold into a single box.</li>\n</ul>",
  "entry_function": "findShutBox",
  "template": "def findShutBox(grid):\n    \"\"\"\n    grid: List[List[int]] \u2014 n\u00d7n binary grid (1=panel, 0=empty), 1 <= n <= 20\n    Returns: List[int] \u2014 sorted [a, b, c] dimensions, or [] if no valid fold\n    \"\"\"\n    ",
  "solution_text": "<h3>Shut the Box \u2014 Named-Face BFS Folding</h3>\n\n<p><strong>Algorithm:</strong></p>\n<ol>\n<li>Count filled panels <code>n</code> and verify connectivity with BFS. Disconnected grids return <code>[]</code> immediately.</li>\n<li>Enumerate all integer triples <code>(a, b, c)</code> satisfying the surface area formula <code>2(ab + bc + ca) = n</code>. These are the only candidate box sizes.</li>\n<li>Model the box as 6 named faces (<code>front, back, top, bot, left, right</code>) with known dimensions. Each face placement method handles out-of-bounds coordinates by redirecting to the correct adjacent face \u2014 hardcoding the entire 3D box topology.</li>\n<li>For each candidate triple and each of its axis permutations, try placing each filled cell as the starting panel on the front face. Run BFS outward, propagating a local orientation value <code>m_o</code>. When placing a flat-grid neighbor in direction <code>j</code>, the mesh direction is <code>DIRS[(j + m_o) % 4]</code>, correctly rotating the frame as the net wraps around box edges.</li>\n<li>If any mesh cell is claimed twice, the fold fails. If BFS completes with all <code>n</code> panels placed, return the sorted dimensions.</li>\n</ol>\n\n<p><strong>Time Complexity:</strong> O(n\u00b2 \u00b7 D \u00b7 S) where n = filled cells \u2264 400, D = number of candidate dimension permutations (sparse for n \u2264 400), S = start positions per permutation \u2264 a\u00b7b</p>\n<p><strong>Space Complexity:</strong> O(n) for the visited array and mesh face grids</p>\n\n<p><strong>Key Insights:</strong></p>\n<ul>\n<li>Surface area formula <code>2(ab + bc + ca) = n</code> is a necessary condition \u2014 filter impossible sizes before any BFS</li>\n<li>Named-face wrapping encodes 3D box topology as simple coordinate transforms, avoiding rotation matrices</li>\n<li>Orientation propagation <code>(j + m_o) % 4</code> handles the local frame rotation at every edge crossing</li>\n<li>Trying all axis permutations of <code>(a, b, c)</code> accounts for the box being placed in any orientation relative to the flat net</li>\n</ul>",
  "solution_code": "def findShutBox(grid):\n    from collections import deque\n\n    DIRS = [(-1,0),(0,1),(1,0),(0,-1)]\n    N = len(grid)  # n\u00d7n grid, 1 <= n <= 20\n\n    # Step 1: connectivity check\n    filled = [(r,c) for r in range(N) for c in range(N) if grid[r][c]==1]\n    if not filled: return []\n    n = len(filled)\n    seen = {filled[0]}\n    q = deque([filled[0]])\n    while q:\n        r,c = q.popleft()\n        for dr,dc in DIRS:\n            nb=(r+dr,c+dc)\n            if 0<=nb[0]<N and 0<=nb[1]<N and grid[nb[0]][nb[1]]==1 and nb not in seen:\n                seen.add(nb); q.append(nb)\n    if len(seen)!=n: return []\n\n    # Step 2: candidate dimensions\n    candidates=[]\n    for a in range(1,n):\n        for b in range(a,n):\n            for c in range(b,n):\n                if 2*(a*b+b*c+a*c)==n:\n                    candidates.append((a,b,c))\n    if not candidates: return []\n\n    # Step 3: try every permutation x start position x start cell\n    def try_fold(start,nr,nc,nl,sr,sc):\n        faces={k:[[0]*dim2 for _ in range(dim1)]\n               for k,dim1,dim2 in [(\"front\",nr,nc),(\"back\",nr,nc),\n                                    (\"top\",nl,nc),(\"bot\",nl,nc),\n                                    (\"left\",nr,nl),(\"right\",nr,nl)]}\n\n        def place(face,r,c,o):\n            # fmt: off\n            if face==\"front\":\n                if r==-1:  return place(\"top\",  nl-1,c,o)\n                if r==nr:  return place(\"bot\",  0,c,o)\n                if c==-1:  return place(\"left\", r,nl-1,o)\n                if c==nc:  return place(\"right\",r,0,o)\n                if faces[\"front\"][r][c]: return None\n                faces[\"front\"][r][c]=1; return (\"front\",r,c,o%4)\n            elif face==\"back\":\n                if r==-1:  return place(\"bot\",  nl-1,c,o)\n                if r==nr:  return place(\"top\",  0,c,o)\n                if c==-1:  return place(\"left\", nr-r-1,0,o+2)\n                if c==nc:  return place(\"right\",nr-r-1,nl-1,o+2)\n                if faces[\"back\"][r][c]: return None\n                faces[\"back\"][r][c]=1; return (\"back\",r,c,o%4)\n            elif face==\"top\":\n                if r==-1:  return place(\"back\", nr-1,c,o)\n                if r==nl:  return place(\"front\",0,c,o)\n                if c==-1:  return place(\"left\", 0,r,o-1)\n                if c==nc:  return place(\"right\",0,nl-r-1,o+1)\n                if faces[\"top\"][r][c]: return None\n                faces[\"top\"][r][c]=1; return (\"top\",r,c,o%4)\n            elif face==\"bot\":\n                if r==-1:  return place(\"front\",nr-1,c,o)\n                if r==nl:  return place(\"back\", 0,c,o)\n                if c==-1:  return place(\"left\", nr-1,nl-r-1,o+1)\n                if c==nc:  return place(\"right\",nr-1,r,o-1)\n                if faces[\"bot\"][r][c]: return None\n                faces[\"bot\"][r][c]=1; return (\"bot\",r,c,o%4)\n            elif face==\"left\":\n                if r==-1:  return place(\"top\",  c,0,o+1)\n                if r==nr:  return place(\"bot\",  nl-c-1,0,o-1)\n                if c==-1:  return place(\"back\", nr-r-1,0,o+2)\n                if c==nl:  return place(\"front\",r,0,o)\n                if faces[\"left\"][r][c]: return None\n                faces[\"left\"][r][c]=1; return (\"left\",r,c,o%4)\n            else:  # right\n                if r==-1:  return place(\"top\",  nl-c-1,nc-1,o-1)\n                if r==nr:  return place(\"bot\",  c,nc-1,o+1)\n                if c==-1:  return place(\"front\",r,nc-1,o)\n                if c==nl:  return place(\"back\", nr-r-1,nc-1,o+2)\n                if faces[\"right\"][r][c]: return None\n                faces[\"right\"][r][c]=1; return (\"right\",r,c,o%4)\n            # fmt: on\n\n        place(\"front\",sr,sc,0)\n        visited=[row[:] for row in grid]\n        visited[start[0]][start[1]]=2\n        fm=[(\"front\",sr,sc,0)]; ff=[start]\n        while fm:\n            nm,nf=[],[]\n            for (mf,mr,mc,mo),(fr,fc) in zip(fm,ff):\n                for j,(dr,dc) in enumerate(DIRS):\n                    r2,c2=fr+dr,fc+dc\n                    if not(0<=r2<N and 0<=c2<N): continue\n                    if visited[r2][c2]!=1: continue\n                    idx=(j+mo)%4; odr,odc=DIRS[idx]\n                    res=place(mf,mr+odr,mc+odc,mo)\n                    if res is None: return False\n                    visited[r2][c2]=2\n                    nm.append(res); nf.append((r2,c2))\n            fm,ff=nm,nf\n        return sum(visited[r][c]==2 for r in range(N) for c in range(N))==n\n\n    for a,b,c in candidates:\n        for nr,nc,nl in {(a,b,c),(a,c,b),(b,a,c),(b,c,a),(c,a,b),(c,b,a)}:\n            for sr in range(nr):\n                for sc in range(nc):\n                    for start in filled:\n                        if try_fold(start,nr,nc,nl,sr,sc):\n                            return sorted([nr,nc,nl])\n    return []",
  "prepare": "def prepare(test_case_input):\n    \"\"\"Prepare arguments for findShutBox function\"\"\"\n    return (test_case_input['grid'],)",
  "verify": "def verify(actual_output, expected_output):\n    \"\"\"Verify the cuboid dimensions result\"\"\"\n    def list_to_string(lst):\n        if not lst:\n            return '[]'\n        return '[' + ', '.join(str(x) for x in lst) + ']'\n\n    # Both must be sorted ascending (or both empty)\n    actual_sorted   = sorted(actual_output)   if actual_output   else []\n    expected_sorted = sorted(expected_output) if expected_output else []\n\n    passed = actual_sorted == expected_sorted\n    output_str = list_to_string(actual_output)\n    return [passed, output_str]",
  "test_cases": [
    {
      "id": 1,
      "input": {
        "grid": [
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 1, 1, 0, 0, 0, 0],
          [1, 1, 1, 1, 1, 1, 0, 0],
          [0, 0, 1, 1, 0, 1, 1, 1],
          [1, 1, 1, 1, 0, 0, 0, 0],
          [0, 0, 0, 1, 0, 0, 0, 0],
          [0, 0, 1, 1, 1, 1, 1, 0],
          [1, 1, 1, 1, 0, 1, 0, 0]
        ]
      },
      "output": [1, 2, 4]
    },
    {
      "id": 2,
      "input": {
        "grid": [
          [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0],
          [0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0],
          [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0],
          [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0],
          [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0],
          [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0],
          [0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0],
          [1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0],
          [0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0],
          [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0],
          [0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0],
          [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        ]
      },
      "output": [2, 6, 7]
    },
    {
      "id": 3,
      "input": {
        "grid": [
          [0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [1, 1, 1, 1, 1, 1, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        ]
      },
      "output": []
    },
    {
      "id": 4,
      "input": {
        "grid": [
          [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        ]
      },
      "output": [2, 3, 4]
    },
    {
      "id": 5,
      "input": {
        "grid": [
          [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        ]
      },
      "output": [3, 4, 5]
    },
    {
      "id": 6,
      "input": {
        "grid": [
          [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        ]
      },
      "output": [2, 5, 6]
    },
    {
      "id": 7,
      "input": {
        "grid": [
          [0, 1, 0, 0],
          [1, 1, 1, 0],
          [0, 1, 0, 0],
          [0, 1, 0, 0]
        ]
      },
      "output": [1, 1, 1]
    },
    {
      "id": 8,
      "input": {
        "grid": [
          [0]
        ]
      },
      "output": []
    },
    {
      "id": 9,
      "input": {
        "grid": [
          [1, 1, 1, 1],
          [0, 0, 0, 1],
          [0, 0, 0, 1],
          [0, 0, 0, 1]
        ]
      },
      "output": []
    },
    {
      "id": 10,
      "input": {
        "grid": [
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        ]
      },
      "output": []
    }
  ]
}
