{
  "index": 213,
  "filename": "subsets",
  "title": "Subsets",
  "difficulty": "Medium",
  "tags": [
    "Backtracking"
  ],
  "keywords": [
    "subsets",
    "power",
    "set",
    "backtracking",
    "recursion",
    "include",
    "exclude",
    "combination",
    "leetcode",
    "78"
  ],
  "description": "<h2>Subsets</h2><p>Given an integer array <code>nums</code> of <strong>unique</strong> elements, return all possible subsets (the power set).</p><p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p><h3>Examples:</h3><ul><li><strong>Input:</strong> nums = [1,2,3]<br><strong>Output:</strong> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</li><li><strong>Input:</strong> nums = [0]<br><strong>Output:</strong> [[],[0]]</li></ul><h3>Constraints:</h3><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li>All the numbers of <code>nums</code> are <strong>unique</strong></li></ul>",
  "entry_function": "subsets",
  "template": "def subsets(nums):\n    ",
  "solution_text": "<h3>Subsets</h3><p><strong>Algorithm:</strong></p><ol><li>Use backtracking with an include/exclude decision at each index</li><li>At each element, branch into two choices: include it or skip it</li><li>When we've processed all elements, add the current subset to results</li></ol><p><strong>Time Complexity:</strong> O(n * 2^n) - 2^n subsets, each up to length n</p><p><strong>Space Complexity:</strong> O(n) - recursion depth (excluding output)</p><p><strong>Key Insights:</strong></p><ul><li>Each element is either in the subset or not â€” binary decision tree</li><li>This generates exactly 2^n subsets</li><li>The include/exclude pattern is fundamental to many backtracking problems</li></ul>",
  "solution_code": "def subsets(nums):\n    result = []\n    \n    def backtrack(i, current):\n        if i == len(nums):\n            result.append(current[:])\n            return\n        \n        # Include nums[i]\n        current.append(nums[i])\n        backtrack(i + 1, current)\n        current.pop()\n        \n        # Exclude nums[i]\n        backtrack(i + 1, current)\n    \n    backtrack(0, [])\n    return result",
  "prepare": "def prepare(test_case_input):\n    return (test_case_input['nums'],)",
  "verify": "def verify(actual_output, expected_output):\n    actual_sorted = sorted([sorted(s) for s in actual_output])\n    expected_sorted = sorted([sorted(s) for s in expected_output])\n    passed = actual_sorted == expected_sorted\n    output_str = str(actual_sorted)\n    return [passed, output_str]",
  "test_cases": [
    {
      "id": 1,
      "input": { "nums": [1, 2, 3] },
      "output": [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]
    },
    {
      "id": 2,
      "input": { "nums": [0] },
      "output": [[], [0]]
    },
    {
      "id": 3,
      "input": { "nums": [1, 2] },
      "output": [[], [1], [2], [1, 2]]
    },
    {
      "id": 4,
      "input": { "nums": [5, 10] },
      "output": [[], [5], [10], [5, 10]]
    },
    {
      "id": 5,
      "input": { "nums": [1, 2, 3, 4] },
      "output": [[], [1], [2], [3], [4], [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4], [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4], [1, 2, 3, 4]]
    },
    {
      "id": 6,
      "input": { "nums": [-1, 0, 1] },
      "output": [[], [-1], [0], [1], [-1, 0], [-1, 1], [0, 1], [-1, 0, 1]]
    },
    {
      "id": 7,
      "input": { "nums": [7] },
      "output": [[], [7]]
    },
    {
      "id": 8,
      "input": { "nums": [1, 5, 3] },
      "output": [[], [1], [5], [3], [1, 5], [1, 3], [5, 3], [1, 5, 3]]
    }
  ]
}
