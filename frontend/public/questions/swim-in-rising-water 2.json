{
  "index": 223,
  "filename": "swim-in-rising-water",
  "title": "Swim in Rising Water",
  "difficulty": "Hard",
  "tags": [
    "Graph",
    "BFS",
    "Heap / Priority Queue"
  ],
  "keywords": [
    "swim",
    "rising",
    "water",
    "grid",
    "graph",
    "bfs",
    "dijkstra",
    "heap",
    "priority queue",
    "binary search",
    "leetcode",
    "778",
    "hard"
  ],
  "description": "<h2>Swim in Rising Water</h2><p>You are given an <code>n x n</code> integer matrix <code>grid</code> where each value <code>grid[i][j]</code> represents the elevation at that point <code>(i, j)</code>.</p><p>The rain starts to fall. At time <code>t</code>, the depth of the water everywhere is <code>t</code>. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually is at most <code>t</code>. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.</p><p>Return <em>the least time until you can reach the bottom right square <code>(n - 1, n - 1)</code> starting from the top left square <code>(0, 0)</code></em>.</p><h3>Examples:</h3><ul><li>Input: <code>grid = [[0,2],[1,3]]</code><br><br>Output: <code>3</code><br><br>Explanation: At time 3, we can swim anywhere since all elevations ≤ 3. The path is (0,0) → (1,0) → (1,1).</li><li>Input: <code>grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]</code><br><br>Output: <code>16</code><br><br>Explanation: We need to wait until time 16 so we can follow the path around the border.</li></ul><h3>Constraints:</h3><ul><li><code>n == grid.length == grid[i].length</code></li><li><code>1 <= n <= 50</code></li><li><code>0 <= grid[i][j] < n * n</code></li><li>Each value in <code>grid</code> is unique</li></ul>",
  "entry_function": "swimInWater",
  "template": "def swimInWater(grid):\n    ",
  "solution_text": "<h3>Swim in Rising Water</h3><p><strong>Algorithm (Min-Heap / Modified Dijkstra):</strong></p><ol><li>Use a min-heap (priority queue) starting from (0,0)</li><li>The priority is the maximum elevation encountered on the path so far</li><li>For each cell, explore 4 neighbors and push them with updated max elevation</li><li>When we reach (n-1, n-1), the max elevation on that path is our answer</li></ol><p><strong>Time Complexity:</strong> O(n² log n) - each cell processed once, heap operations are O(log n²)</p><p><strong>Space Complexity:</strong> O(n²) - visited set and heap</p><p><strong>Key Insights:</strong></p><ul><li>This is a shortest path problem where \"cost\" is the max elevation along the path</li><li>Modified Dijkstra: minimize the maximum weight on any path from source to destination</li><li>Min-heap ensures we always explore the path with smallest bottleneck first</li><li>Can also be solved with binary search + BFS/DFS</li></ul>",
  "solution_code": "def swimInWater(grid):\n    import heapq\n    \n    n = len(grid)\n    visited = set()\n    # (max_elevation_so_far, row, col)\n    heap = [(grid[0][0], 0, 0)]\n    visited.add((0, 0))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    while heap:\n        max_elev, r, c = heapq.heappop(heap)\n        \n        if r == n - 1 and c == n - 1:\n            return max_elev\n        \n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < n and 0 <= nc < n and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                new_max = max(max_elev, grid[nr][nc])\n                heapq.heappush(heap, (new_max, nr, nc))\n    \n    return -1",
  "prepare": "def prepare(test_case_input):\n    \"\"\"Prepare arguments for swimInWater function\"\"\"\n    return (test_case_input['grid'],)",
  "verify": "def verify(actual_output, expected_output):\n    \"\"\"Verify the swim in rising water result\"\"\"\n    passed = actual_output == expected_output\n    output_str = str(actual_output)\n    \n    return [passed, output_str]",
  "test_cases": [
    {
      "id": 1,
      "input": {
        "grid": [
          [
            0,
            2
          ],
          [
            1,
            3
          ]
        ]
      },
      "output": 3
    },
    {
      "id": 2,
      "input": {
        "grid": [
          [
            0,
            1,
            2,
            3,
            4
          ],
          [
            24,
            23,
            22,
            21,
            5
          ],
          [
            12,
            13,
            14,
            15,
            16
          ],
          [
            11,
            17,
            18,
            19,
            20
          ],
          [
            10,
            9,
            8,
            7,
            6
          ]
        ]
      },
      "output": 16
    },
    {
      "id": 3,
      "input": {
        "grid": [
          [
            0
          ]
        ]
      },
      "output": 0
    },
    {
      "id": 4,
      "input": {
        "grid": [
          [
            0,
            1,
            2
          ],
          [
            5,
            4,
            3
          ],
          [
            6,
            7,
            8
          ]
        ]
      },
      "output": 8
    },
    {
      "id": 5,
      "input": {
        "grid": [
          [
            3,
            2
          ],
          [
            0,
            1
          ]
        ]
      },
      "output": 3
    },
    {
      "id": 6,
      "input": {
        "grid": [
          [
            0,
            7,
            3
          ],
          [
            8,
            5,
            1
          ],
          [
            4,
            6,
            2
          ]
        ]
      },
      "output": 7
    }
  ]
}
