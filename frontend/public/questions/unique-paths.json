{
  "index": 216,
  "filename": "unique-paths",
  "title": "Unique Paths",
  "difficulty": "Medium",
  "tags": [
    "Dynamic Programming"
  ],
  "keywords": [
    "unique",
    "paths",
    "grid",
    "robot",
    "dynamic",
    "programming",
    "dp",
    "2d",
    "combinatorics",
    "math"
  ],
  "description": "<h2>Unique Paths</h2><p>There is a robot on an <code>m x n</code> grid. The robot starts at the top-left corner <code>(0, 0)</code> and tries to reach the bottom-right corner <code>(m - 1, n - 1)</code>. The robot can only move <strong>down</strong> or <strong>right</strong> at any point in time.</p><p>Return the number of unique paths the robot can take to reach the bottom-right corner.</p><pre>\n  +---+---+---+---+---+---+---+\n  | R |   |   |   |   |   |   |  R = Robot (start)\n  +---+---+---+---+---+---+---+\n  |   |   |   |   |   |   |   |  * = Goal (end)\n  +---+---+---+---+---+---+---+\n  |   |   |   |   |   |   | * |  Moves: → or ↓ only\n  +---+---+---+---+---+---+---+\n</pre><h3>Examples:</h3><ul><li><strong>Input:</strong> m = 3, n = 2<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The three possible paths are:<pre>\n  Path 1              Path 2              Path 3\n\n  ┌─────┬─────┐      ┌─────┬─────┐      ┌─────┬─────┐\n  │  R  → ███ │      │  R  │     │      │  R  │     │\n  ├─────┼──↓──┤      ├──↓──┼─────┤      ├──↓──┼─────┤\n  │     │ ███ │      │ ███ → ███ │      │ ███ │     │\n  ├─────┼──↓──┤      ├─────┼──↓──┤      ├──↓──┼─────┤\n  │     │ ★★★ │      │     │ ★★★ │      │ ███ → ★★★ │\n  └─────┴─────┘      └─────┴─────┘      └─────┴─────┘\n\n  Route: → ↓ ↓        Route: ↓ → ↓        Route: ↓ ↓ →\n</pre></li><li><strong>Input:</strong> m = 3, n = 7<br><strong>Output:</strong> 28</li></ul><h3>Constraints:</h3><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>The answer is guaranteed to be less than or equal to <code>2 * 10^9</code></li></ul>",
  "entry_function": "uniquePaths",
  "template": "def uniquePaths(m, n):\n    ",
  "solution_text": "<h3>Unique Paths</h3><p><strong>Algorithm:</strong></p><ol><li>Create a 1D DP array of size <code>n</code>, initialized to 1 (the first row has only one way to reach each cell: go right)</li><li>For each subsequent row, update each cell: <code>dp[j] += dp[j - 1]</code></li><li>This works because <code>dp[j]</code> already holds the paths from above, and <code>dp[j - 1]</code> holds the paths from the left</li><li>Return <code>dp[n - 1]</code></li></ol><p><strong>Time Complexity:</strong> O(m * n) - iterate through every cell in the grid</p><p><strong>Space Complexity:</strong> O(n) - single row DP array</p><p><strong>Key Insights:</strong></p><ul><li>Each cell can only be reached from above or from the left</li><li>Paths to a cell = paths from above + paths from the left</li><li>The first row and first column all have exactly 1 path</li><li>Space optimization: only need the current and previous row, which can be combined into a single array updated in-place</li></ul>",
  "solution_code": "def uniquePaths(m, n):\n    # Each cell in the first row has exactly 1 path (all right)\n    dp = [1] * n\n    \n    # For each subsequent row\n    for i in range(1, m):\n        # For each cell (skip col 0, always 1)\n        for j in range(1, n):\n            # dp[j] already has paths from above\n            # dp[j-1] has paths from the left (already updated this row)\n            dp[j] += dp[j - 1]\n    \n    return dp[-1]",
  "prepare": "def prepare(test_case_input):\n    return (test_case_input['m'], test_case_input['n'])",
  "verify": "def verify(actual_output, expected_output):\n    passed = actual_output == expected_output\n    return [passed, str(actual_output)]",
  "test_cases": [
    {
      "id": 1,
      "input": { "m": 3, "n": 2 },
      "output": 3
    },
    {
      "id": 2,
      "input": { "m": 3, "n": 7 },
      "output": 28
    },
    {
      "id": 3,
      "input": { "m": 1, "n": 1 },
      "output": 1
    },
    {
      "id": 4,
      "input": { "m": 2, "n": 2 },
      "output": 2
    },
    {
      "id": 5,
      "input": { "m": 3, "n": 3 },
      "output": 6
    },
    {
      "id": 6,
      "input": { "m": 4, "n": 4 },
      "output": 20
    },
    {
      "id": 7,
      "input": { "m": 1, "n": 5 },
      "output": 1
    },
    {
      "id": 8,
      "input": { "m": 5, "n": 1 },
      "output": 1
    },
    {
      "id": 9,
      "input": { "m": 7, "n": 3 },
      "output": 28
    },
    {
      "id": 10,
      "input": { "m": 10, "n": 10 },
      "output": 48620
    }
  ]
}
