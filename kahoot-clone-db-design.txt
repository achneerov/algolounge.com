# Kahoot Clone - Database Design

## Project Overview
Building a real-time multiplayer quiz platform similar to Kahoot.

## Key Design Decisions

### Architecture
- No generic "Events" table - simplified to quiz-specific tables
- Round = single question (not a group of questions)
- Typical quiz has 10-20 questions
- Real-time multiplayer gameplay
- Template-based system: reusable quiz templates can be instantiated as live events

### Question Types
- Using polymorphic design: base `questions` table + type-specific tables
- Separate tables for each question type (future-proof and extensible)
- Multiple choice variants: 2-option, 3-option, 4-option (separate tables)
- Additional types: true/false, typed (free text)
- Enum table to track available question types

### User Roles
- Two roles: Admin and Member
- User roles stored in enum table
- Users table needs `role_id` column added
- Only admins can create quiz events
- UI: Admins see "Create Quiz" button (top right) + "Join Quiz" (center)

### Quiz Event Flow
1. Admin selects a quiz template
2. Admin clicks "Start" → event created with 4-digit room code
3. Users join using the room code
4. Admin controls progression through questions

### Join Mechanism
- 4-digit numeric room codes
- TODO: Decide on uniqueness constraints and expiration

### Scoring System
- Relative scoring based on speed (not absolute)
- Only correct answers get points
- Algorithm:
  1. Collect all users who answered correctly
  2. Order by submission timestamp (earliest to latest)
  3. Fastest gets 100 points
  4. Slowest gets 50 points
  5. Everyone in between scaled linearly (50-100 range)
- Points calculated AFTER round ends (not real-time)
- Store calculated points in `quiz_round_performances` table

### Time Tracking
- `submitted_at` stored as timestamp
- TODO: Decide on time limit implementation (per-question or quiz-wide)

### Template Creation
- Manual creation via SQL migrations (no UI for now)
- Templates are reusable:
  - One template → many events
  - Multiple quizzes can share the same questions (many-to-many)

---

## Proposed Database Schema

### Enum Tables

```sql
user_roles
  - id (integer, primary key)
  - role_name (text, unique)
  - Values: 'admin', 'member'

question_types
  - id (integer, primary key)
  - type_name (text, unique)
  - Values: 'multiple_choice_2', 'multiple_choice_3', 'multiple_choice_4',
           'true_false', 'typed', [future types...]
```

### Users Table (UPDATE EXISTING)

```sql
users
  - id (integer, primary key)
  - username (text, unique, not null)
  - email (text, unique, not null)
  - password_hash (text, not null)
  - role_id (integer, FK to user_roles) ← NEW COLUMN
  - created_at (timestamp)
  - updated_at (timestamp)
```

### Questions (Base Table + Type-Specific Tables)

```sql
questions (base table)
  - id (integer, primary key)
  - question_type_id (integer, FK to question_types)
  - question_text (text, not null)
  - time_limit_seconds (integer, not null, default 30) - range: 5-120 seconds
  - created_at (timestamp)

questions_multiple_choice_2
  - question_id (integer, FK to questions, PRIMARY KEY)
  - option_1 (text, not null)
  - option_2 (text, not null)
  - correct_option_index (integer, 1 or 2)

questions_multiple_choice_3
  - question_id (integer, FK to questions, PRIMARY KEY)
  - option_1 (text, not null)
  - option_2 (text, not null)
  - option_3 (text, not null)
  - correct_option_index (integer, 1-3)

questions_multiple_choice_4
  - question_id (integer, FK to questions, PRIMARY KEY)
  - option_1 (text, not null)
  - option_2 (text, not null)
  - option_3 (text, not null)
  - option_4 (text, not null)
  - correct_option_index (integer, 1-4)

questions_true_false
  - question_id (integer, FK to questions, PRIMARY KEY)
  - correct_answer (boolean, not null)

questions_typed
  - question_id (integer, FK to questions, PRIMARY KEY)
  - correct_answer (text, not null)
  - case_sensitive (boolean, default false)
```

### Quiz Templates (Reusable Definitions)

```sql
quiz_templates
  - id (integer, primary key)
  - name (text, not null)
  - description (text, nullable)
  - created_at (timestamp)

quiz_template_rounds (many-to-many: templates ↔ questions)
  - id (integer, primary key)
  - quiz_template_id (integer, FK to quiz_templates)
  - question_id (integer, FK to questions)
  - round_order (integer, not null) - determines sequence of questions
  - UNIQUE constraint: (quiz_template_id, round_order)
```

### Quiz Events (Live Game Sessions)

```sql
quiz_events
  - id (integer, primary key)
  - quiz_template_id (integer, FK to quiz_templates)
  - room_code (text, 4 digits, not null)
  - created_by_user_id (integer, FK to users)
  - status (text, not null) - values: 'waiting', 'in_progress', 'completed'
  - created_at (timestamp)
  - started_at (timestamp, nullable)
  - ended_at (timestamp, nullable)
  - PARTIAL UNIQUE constraint on room_code WHERE status IN ('waiting', 'in_progress')

quiz_event_participants
  - id (integer, primary key)
  - quiz_event_id (integer, FK to quiz_events)
  - user_id (integer, FK to users)
  - joined_at (timestamp, not null)
  - UNIQUE constraint: (quiz_event_id, user_id) - user can only join event once

quiz_event_rounds
  - id (integer, primary key)
  - quiz_event_id (integer, FK to quiz_events)
  - quiz_template_round_id (integer, FK to quiz_template_rounds)
  - round_number (integer, not null) - 1, 2, 3...
  - status (text, not null) - values: 'pending', 'active', 'completed'
  - started_at (timestamp, nullable)
  - ended_at (timestamp, nullable)
  - UNIQUE constraint: (quiz_event_id, round_number)
```

### Performance & Scoring

```sql
quiz_round_performances
  - id (integer, primary key)
  - quiz_event_round_id (integer, FK to quiz_event_rounds)
  - user_id (integer, FK to users)
  - user_answer (text, nullable) - stores actual answer submitted (option index or typed text)
  - submitted_at (timestamp, not null)
  - answered_correctly (boolean, not null)
  - points_earned (integer, default 0) - calculated after round ends (0-100 range)
  - UNIQUE constraint: (quiz_event_round_id, user_id) - one answer per user per round
```

---

## Design Decisions - FINALIZED

### Room Codes ✓
- **Generation:** Auto-generated random 4-digit numbers (1000-9999)
- **Uniqueness:** Unique only among active events (status = 'waiting' or 'in_progress')
- **Expiration:** Reusable after event completes - codes can be recycled
- **Implementation:** Partial unique constraint on `(room_code)` where status IN ('waiting', 'in_progress')
- **Rationale:** 9000 possible codes is sufficient for concurrent games; completed games release codes back to pool

### Time Limits ✓
- **Per-question time limits** (not quiz-wide)
- **Storage:** `time_limit_seconds` column on `questions` table (nullable, defaults to 30 seconds)
- **Range:** 5-120 seconds (configurable per question based on difficulty)
- **Timeout behavior:** Auto-submit as incorrect (0 points)
- **Rationale:** Matches Kahoot's model; creates urgency; different questions need different time

### Scoring Rules ✓
- **Everyone wrong:** No points awarded (all get 0)
- **Only 1 correct:** They get 100 points (no scaling)
- **Incorrect answers:** 0 points (no negative scoring - keep it positive)
- **Partial credit:** Not supported in v1 (can add later if needed)
- **Tie handling:** Users with identical timestamps get averaged position points
- **Example:** 5 correct answers → 100, 87, 75, 62, 50 points (linear scale 50-100)

### Answer Storage ✓
- **Add `user_answer` column** to `quiz_round_performances` (text, nullable)
- **Format:**
  - Multiple choice: option index as string ("1", "2", "3", "4")
  - True/False: "true" or "false"
  - Typed: actual user input (trimmed)
- **Benefits:** Debugging, analytics, dispute resolution, future answer review feature
- **Overhead:** Minimal (typically 1-50 characters per answer)

### Event Rounds Pre-creation ✓
- **Create ALL rounds eagerly** when quiz event is created
- **Why:** Simpler implementation, allows "question X of Y" display, admin can preview structure
- **Admin control:** `POST /api/quiz-events/:id/advance` endpoint
  - Marks current round as completed (sets `ended_at`)
  - Activates next round (sets `status = 'active'`, `started_at`)
  - Calculates and stores points for completed round
  - Returns updated event state with leaderboard
- **Alternative rejected:** Lazy creation (too complex, no real benefit)

### Database Technology ✓
- **Database:** SQLite (existing AlgoLounge setup)
- **ORM:** Drizzle ORM 0.44.7
- **Migrations:** Drizzle migrations in `backend/src/db/migrations/`
- **Dev workflow:** `npm run db:generate` → `npm run db:migrate`

### Real-time Architecture ✓
- **Technology:** Server-Sent Events (SSE)
- **Why SSE:**
  - Simpler than WebSockets (unidirectional server→client)
  - Automatic reconnection
  - Works over HTTP
  - Perfect for server-driven updates (admin controls pace)
- **Event types:**
  - `player_joined` - New player enters waiting room
  - `quiz_started` - Admin starts the quiz
  - `round_started` - New question activated (includes question data)
  - `round_ended` - Question time expired (includes correct answer + leaderboard)
  - `quiz_ended` - All questions complete (final leaderboard)
- **Endpoint:** `GET /api/quiz-events/:id/stream` (authenticated)
- **Frontend:** Angular `EventSource` API

### UI Components Required
- **Admin Dashboard:**
  - Quiz template selector
  - "Start Quiz" button → generates room code
  - Live participant list (waiting room)
  - "Start Round" / "Next Question" button
  - Current question display
  - Timer countdown
  - Live leaderboard
- **Player View:**
  - Room code entry
  - Waiting room (shows other players joining)
  - Question display with answer options
  - Timer countdown (synced with server)
  - Answer submission feedback
  - Round results (correct answer + leaderboard)
  - Final leaderboard

---

## API Endpoints

### Quiz Events
```
POST /api/quiz-events
  Body: { quiz_template_id: number }
  Auth: Admin only
  Returns: { id, room_code, status, quiz_template_id, ... }
  - Creates new event with auto-generated room code
  - Creates all quiz_event_rounds eagerly
  - Sets status to 'waiting'

GET /api/quiz-events/:room_code
  Auth: Any authenticated user
  Returns: Event details + participants list
  - Look up event by room_code
  - Return event details and current round info

POST /api/quiz-events/:id/join
  Auth: Any authenticated user (non-admin)
  Returns: Success confirmation
  - Add user to event participants
  - Broadcast 'player_joined' SSE event

POST /api/quiz-events/:id/start
  Auth: Admin (event creator only)
  Returns: Updated event with first round active
  - Sets event status to 'in_progress'
  - Sets started_at timestamp
  - Activates first round (status = 'active')
  - Broadcasts 'quiz_started' + 'round_started' SSE events

POST /api/quiz-events/:id/advance
  Auth: Admin (event creator only)
  Returns: Updated event + leaderboard
  - Marks current round as 'completed' (sets ended_at)
  - Calculates and stores points for all performances in round
  - If more rounds exist: activates next round
  - If no more rounds: marks event as 'completed'
  - Broadcasts 'round_ended' or 'quiz_ended' SSE event

GET /api/quiz-events/:id/stream
  Auth: Any authenticated participant
  Returns: SSE stream
  - Server-Sent Events for real-time updates
  - Event types: player_joined, quiz_started, round_started, round_ended, quiz_ended
```

### Answers
```
POST /api/quiz-events/:event_id/rounds/:round_id/answer
  Body: { answer: string } - option index or typed text
  Auth: Any authenticated participant
  Returns: Confirmation (no correctness info until round ends)
  - Validates answer format based on question type
  - Stores in quiz_round_performances with timestamp
  - Sets answered_correctly boolean
  - points_earned remains 0 until round ends
  - Rejects if round is not 'active' or already answered
```

### Quiz Templates (Admin only)
```
GET /api/quiz-templates
  Auth: Admin only
  Returns: List of available quiz templates
  - For admin to select which quiz to start

GET /api/quiz-templates/:id
  Auth: Admin only
  Returns: Template details + all questions/rounds
  - Preview template before starting
```

### Leaderboard
```
GET /api/quiz-events/:id/leaderboard
  Auth: Any authenticated participant
  Returns: Ranked list of participants with total scores
  - Aggregate points_earned across all completed rounds
  - Order by total score descending
```

---

## Implementation Notes

### Migration Strategy
1. Create enum tables (user_roles, question_types)
2. Alter users table to add role_id
3. Create questions tables (base + type-specific)
4. Create quiz template tables (quiz_templates, quiz_template_rounds)
5. Create quiz event tables (quiz_events, quiz_event_participants, quiz_event_rounds)
6. Create performance table (quiz_round_performances)
7. Create indexes for performance optimization
8. Seed initial data (roles, question types)

### Data Relationships
- quiz_templates → questions: many-to-many (via quiz_template_rounds)
- quiz_events → quiz_templates: many-to-one
- quiz_events → users: many-to-many (via quiz_event_participants)
- quiz_event_rounds → quiz_events: one-to-many
- quiz_event_rounds → quiz_template_rounds: many-to-one
- quiz_round_performances → quiz_event_rounds: many-to-one
- quiz_round_performances → users: many-to-one

### Indexes to Consider
- users.role_id
- questions.question_type_id
- quiz_template_rounds: (quiz_template_id, round_order)
- quiz_events.room_code (for fast lookups during join - CRITICAL for UX)
- quiz_event_participants: (quiz_event_id) for participant lists
- quiz_event_participants: (user_id) for finding user's active quizzes
- quiz_event_rounds: (quiz_event_id, round_number)
- quiz_event_rounds: (quiz_event_id, status) for finding active round
- quiz_round_performances: (quiz_event_round_id, submitted_at) for scoring calculations
- quiz_round_performances: (quiz_event_round_id, answered_correctly) for filtering correct answers

---

## Next Steps
1. Finalize open questions
2. Write Drizzle schema definitions
3. Generate and run migrations
4. Seed initial enum data
5. Create sample quiz templates via SQL
6. Build backend API endpoints
7. Build frontend UI components
8. Implement real-time sync mechanism
