{"filename": "delete-node-in-a-bst", "title": "Delete Node in a BST", "keywords": ["delete", "node", "bst", "leetcode", "450", "given", "root", "reference", "key", "present"], "description": "<h2>Delete Node in a BST</h2><p>Leetcode 450. Delete Node in a BST</p><p></p><p>You are given a `root` node reference of a BST and a `key`, delete the node with the given key in the BST, if present. Return the root node reference (possibly updated) of the BST.</p><p></p><p>Basically, the deletion can be divided into two stages:</p><p></p><p>- Search for a node to remove.</p><p>- If the node is found, delete the node.</p><p></p><p>Note: There can be multiple results after deleting the node, return any one of them.</p><h3>Examples:</h3><ul><li>Input: root = [5,3,6,null,4,null,10,null,null,7], key = 3<br><br>Output: [5,4,6,null,null,null,10,7]</li></ul><h3>Constraints:</h3><ul><li> `0 <= The number of nodes in the tree <= 10,000`.</li><li> `-100,000 <= key, Node.val <= 100,000`</li><li> All the values `Node.val` are unique.</li></ul>", "languages": { "python": { "template": "def deleteNodeInABst(root, key):\n    ", "solution_text": "<p><strong>Recursive Solution for Deleting a Node in a BST:</strong></p><p>This problem involves finding a node with a specific key and removing it while maintaining the properties of a Binary Search Tree (BST).</p><p><strong>Algorithm:</strong></p><ol><li><strong>Base Case:</strong> If the `root` is `None`, the key is not in the tree, so we return `None`.</li><li><strong>Search for the Node:</strong><ol><li>If the `key` is less than the `root.val`, the node to be deleted is in the left subtree. We recursively call `deleteNode` on `root.left`.</li><li>If the `key` is greater than the `root.val`, the node is in the right subtree. We recursively call `deleteNode` on `root.right`.</li><li>If `key == root.val`, we have found the node to delete.</li></ol></li><li><strong>Deleting the Node (when `key == root.val`):</strong><ol><li><strong>Case 1: Node has no children (leaf node).</strong> We can simply remove it by returning `null`.</li><li><strong>Case 2: Node has one child.</strong> We replace the node with its child by returning the child.</li><li><strong>Case 3: Node has two children.</strong> This is the most complex case. To maintain the BST property, we need to replace the node with either its in-order successor (the smallest node in its right subtree) or its in-order predecessor (the largest node in its left subtree).<ol><li>Let's use the in-order successor. Find the minimum value in the right subtree.</li><li>Copy the value of the in-order successor to the node to be deleted.</li><li>Recursively call `deleteNode` on the right subtree to remove the in-order successor (which we know has at most one right child).</li></ol></li></ol></li><li><strong>Return Root:</strong> The function returns the (possibly updated) `root` of the subtree.</li></ol><p><strong>Time Complexity:</strong> O(H), where H is the height of the tree. In a balanced BST, this is O(log N). In the worst case (a skewed tree), it becomes O(N).</p><p><strong>Space Complexity:</strong> O(H) for the recursion stack. In the worst case, this is O(N).</p>", "solution_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deleteNode(self, root, key):\n        if not root:\n            return None\n\n        if key < root.val:\n            root.left = self.deleteNode(root.left, key)\n        elif key > root.val:\n            root.right = self.deleteNode(root.right, key)\n        else: # key == root.val\n            if not root.left:\n                return root.right\n            elif not root.right:\n                return root.left\n            \n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            min_node = self._find_min(root.right)\n            root.val = min_node.val\n            root.right = self.deleteNode(root.right, root.val)\n            \n        return root\n\n    def _find_min(self, node):\n        current = node\n        while current.left:\n            current = current.left\n        return current"}, "javascript": { "template": "function deleteNodeInABst(root, key) {\n  \n}", "solution_text": "<p><strong>Recursive Solution for Deleting a Node in a BST:</strong></p><p>This problem involves finding a node with a specific key and removing it while maintaining the properties of a Binary Search Tree (BST).</p><p><strong>Algorithm:</strong></p><ol><li><strong>Base Case:</strong> If the `root` is `null`, the key is not in the tree, so we return `null`.</li><li><strong>Search for the Node:</strong><ol><li>If the `key` is less than the `root.val`, the node to be deleted is in the left subtree. We recursively call `deleteNode` on `root.left`.</li><li>If the `key` is greater than the `root.val`, the node is in the right subtree. We recursively call `deleteNode` on `root.right`.</li><li>If `key == root.val`, we have found the node to delete.</li></ol></li><li><strong>Deleting the Node (when `key == root.val`):</strong><ol><li><strong>Case 1: Node has no children (leaf node).</strong> We can simply remove it by returning `null`.</li><li><strong>Case 2: Node has one child.</strong> We replace the node with its child by returning the child.</li><li><strong>Case 3: Node has two children.</strong> This is the most complex case. To maintain the BST property, we need to replace the node with either its in-order successor (the smallest node in its right subtree) or its in-order predecessor (the largest node in its left subtree).<ol><li>Let's use the in-order successor. Find the minimum value in the right subtree.</li><li>Copy the value of the in-order successor to the node to be deleted.</li><li>Recursively call `deleteNode` on the right subtree to remove the in-order successor (which we know has at most one right child).</li></ol></li></ol></li><li><strong>Return Root:</strong> The function returns the (possibly updated) `root` of the subtree.</li></ol><p><strong>Time Complexity:</strong> O(H), where H is the height of the tree. In a balanced BST, this is O(log N). In the worst case (a skewed tree), it becomes O(N).</p><p><strong>Space Complexity:</strong> O(H) for the recursion stack. In the worst case, this is O(N).</p>", "solution_code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} key\n * @return {TreeNode}\n */\nvar deleteNode = function(root, key) {\n    if (!root) {\n        return null;\n    }\n\n    if (key < root.val) {\n        root.left = deleteNode(root.left, key);\n    } else if (key > root.val) {\n        root.right = deleteNode(root.right, key);\n    } else {\n        if (!root.left) {\n            return root.right;\n        } else if (!root.right) {\n            return root.left;\n        }\n\n        let minNode = findMin(root.right);\n        root.val = minNode.val;\n        root.right = deleteNode(root.right, root.val);\n    }\n    return root;\n};\n\nfunction findMin(node) {\n    while (node.left) {\n        node = node.left;\n    }\n    return node;\n}"}, "typescript": { "template": "function deleteNodeInABst(root: TreeNode | null, key: number): TreeNode | null {\n  \n}", "solution_text": "<p><strong>Recursive Solution for Deleting a Node in a BST:</strong></p><p>This problem involves finding a node with a specific key and removing it while maintaining the properties of a Binary Search Tree (BST).</p><p><strong>Algorithm:</strong></p><ol><li><strong>Base Case:</strong> If the `root` is `null`, the key is not in the tree, so we return `null`.</li><li><strong>Search for the Node:</strong><ol><li>If the `key` is less than the `root.val`, the node to be deleted is in the left subtree. We recursively call `deleteNode` on `root.left`.</li><li>If the `key` is greater than the `root.val`, the node is in the right subtree. We recursively call `deleteNode` on `root.right`.</li><li>If `key == root.val`, we have found the node to delete.</li></ol></li><li><strong>Deleting the Node (when `key == root.val`):</strong><ol><li><strong>Case 1: Node has no children (leaf node).</strong> We can simply remove it by returning `null`.</li><li><strong>Case 2: Node has one child.</strong> We replace the node with its child by returning the child.</li><li><strong>Case 3: Node has two children.</strong> This is the most complex case. To maintain the BST property, we need to replace the node with either its in-order successor (the smallest node in its right subtree) or its in-order predecessor (the largest node in its left subtree).<ol><li>Let's use the in-order successor. Find the minimum value in the right subtree.</li><li>Copy the value of the in-order successor to the node to be deleted.</li><li>Recursively call `deleteNode` on the right subtree to remove the in-order successor (which we know has at most one right child).</li></ol></li></ol></li><li><strong>Return Root:</strong> The function returns the (possibly updated) `root` of the subtree.</li></ol><p><strong>Time Complexity:</strong> O(H), where H is the height of the tree. In a balanced BST, this is O(log N). In the worst case (a skewed tree), it becomes O(N).</p><p><strong>Space Complexity:</strong> O(H) for the recursion stack. In the worst case, this is O(N).</p>", "solution_code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction deleteNode(root: TreeNode | null, key: number): TreeNode | null {\n    if (!root) {\n        return null;\n    }\n\n    if (key < root.val) {\n        root.left = deleteNode(root.left, key);\n    } else if (key > root.val) {\n        root.right = deleteNode(root.right, key);\n    } else {\n        if (!root.left) {\n            return root.right;\n        } else if (!root.right) {\n            return root.left;\n        }\n\n        let minNode = findMin(root.right);\n        root.val = minNode.val;\n        root.right = deleteNode(root.right, root.val);\n    }\n    return root;\n}\n\nfunction findMin(node: TreeNode): TreeNode {\n    while (node.left) {\n        node = node.left;\n    }\n    return node;\n}"}, "java": { "template": "class Solution {\n    public TreeNode deleteNode(TreeNode root, int key) {\n        \n    }\n}", "solution_text": "<p><strong>Recursive Solution for Deleting a Node in a BST:</strong></p><p>This problem involves finding a node with a specific key and removing it while maintaining the properties of a Binary Search Tree (BST).</p><p><strong>Algorithm:</strong></p><ol><li><strong>Base Case:</strong> If the `root` is `null`, the key is not in the tree, so we return `null`.</li><li><strong>Search for the Node:</strong><ol><li>If the `key` is less than the `root.val`, the node to be deleted is in the left subtree. We recursively call `deleteNode` on `root.left`.</li><li>If the `key` is greater than the `root.val`, the node is in the right subtree. We recursively call `deleteNode` on `root.right`.</li><li>If `key == root.val`, we have found the node to delete.</li></ol></li><li><strong>Deleting the Node (when `key == root.val`):</strong><ol><li><strong>Case 1: Node has no children (leaf node).</strong> We can simply remove it by returning `null`.</li><li><strong>Case 2: Node has one child.</strong> We replace the node with its child by returning the child.</li><li><strong>Case 3: Node has two children.</strong> This is the most complex case. To maintain the BST property, we need to replace the node with either its in-order successor (the smallest node in its right subtree) or its in-order predecessor (the largest node in its left subtree).<ol><li>Let's use the in-order successor. Find the minimum value in the right subtree.</li><li>Copy the value of the in-order successor to the node to be deleted.</li><li>Recursively call `deleteNode` on the right subtree to remove the in-order successor (which we know has at most one right child).</li></ol></li></ol></li><li><strong>Return Root:</strong> The function returns the (possibly updated) `root` of the subtree.</li></ol><p><strong>Time Complexity:</strong> O(H), where H is the height of the tree. In a balanced BST, this is O(log N). In the worst case (a skewed tree), it becomes O(N).</p><p><strong>Space Complexity:</strong> O(H) for the recursion stack. In the worst case, this is O(N).</p>", "solution_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode deleteNode(TreeNode root, int key) {\n        if (root == null) {\n            return null;\n        }\n\n        if (key < root.val) {\n            root.left = deleteNode(root.left, key);\n        } else if (key > root.val) {\n            root.right = deleteNode(root.right, key);\n        } else {\n            if (root.left == null) {\n                return root.right;\n            } else if (root.right == null) {\n                return root.left;\n            }\n\n            TreeNode minNode = findMin(root.right);\n            root.val = minNode.val;\n            root.right = deleteNode(root.right, root.val);\n        }\n        return root;\n    }\n\n    private TreeNode findMin(TreeNode node) {\n        while (node.left != null) {\n            node = node.left;\n        }\n        return node;\n    }\n}"}}, "order_matters": false, "test_cases": [{"id": 1, "input": {"root": [5, 3, 6, 2, 4, null, 7], "key": 3}, "output": [5, 4, 6, 2, null, null, 7]}, {"id": 2, "input": {"root": [5, 3, 6, 2, 4, null, 7], "key": 0}, "output": [5, 3, 6, 2, 4, null, 7]}, {"id": 3, "input": {"root": [], "key": 0}, "output": []}, {"id": 4, "input": {"root": [5, 3, 6, 2, 4, null, 7], "key": 5}, "output": [6, 3, 7, 2, 4]}, {"id": 5, "input": {"root": [5, 3, 6, 2, 4, null, 7], "key": 7}, "output": [5, 3, 6, 2, 4]}, {"id": 6, "input": {"root": [1, null, 2], "key": 1}, "output": [2]}, {"id": 7, "input": {"root": [10, 5, 15, 3, 7, null, 18], "key": 10}, "output": [15, 5, 18, 3, 7]}, {"id": 8, "input": {"root": [10, 5, 15, 3, 7, 12, 18], "key": 15}, "output": [10, 5, 18, 3, 7, 12]}, {"id": 9, "input": {"root": [10, 5, 15, 3, 7, null, 18], "key": 3}, "output": [10, 5, 15, null, 7, null, 18]}, {"id": 10, "input": {"root": [0], "key": 0}, "output": []}]}