{
  "filename": "house-robber",
  "title": "House Robber",
  "keywords": [
    "house",
    "robber",
    "leetcode",
    "198",
    "given",
    "integer",
    "array",
    "nums",
    "where",
    "represents"
  ],
  "description": "<h2>House Robber</h2><p>Leetcode 198. House Robber</p><p></p><p>You are given an integer array `nums` where `nums[i]` represents the amount of money the `i`th house has. The houses are arranged in a straight line, i.e. the `i`th house is the neighbor of the `(i-1)`th and `(i+1)`th house.</p><p></p><p>You are planning to rob money from the houses, but you cannot rob **two adjacent houses** because the security system will automatically alert the police if two adjacent houses were *both* broken into.</p><p></p><p>Return the *maximum* amount of money you can rob **without** alerting the police.</p><h3>Examples:</h3><ul><li>Input: nums = [1,1,3,3]<br><br>Output: 4<br>`nums[0] + nums[2] = 1 + 3 = 4`.</li><li>Input: nums = [2,9,8,3,6]<br><br>Output: 16<br>`nums[0] + nums[2] + nums[4] = 2 + 8 + 6 = 16`.</li></ul><h3>Constraints:</h3><ul><li> `1 <= nums.length <= 100`</li><li> `0 <= nums[i] <= 100`</li></ul>",
  "languages": {
    "python": {
      "template": "def houseRobber(nums):\n    ",
      "solution_text": "<p><strong>Dynamic Programming Solution for House Robber:</strong></p><p>Find maximum money that can be robbed without robbing adjacent houses.</p><p><strong>Algorithm:</strong></p><ol><li>For each house, decide: rob current house + max from 2 houses back, or skip current house</li><li>dp[i] = max(nums[i] + dp[i-2], dp[i-1])</li><li>Base cases: dp[0] = nums[0], dp[1] = max(nums[0], nums[1])</li><li>Return dp[n-1] for maximum possible money</li></ol><p><strong>Time Complexity:</strong> O(n) - single pass through houses</p><p><strong>Space Complexity:</strong> O(1) - can optimize to use two variables</p>",
      "solution_code": "def houseRobber(nums):\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    \n    # dp[i] represents max money we can rob up to house i\n    prev2 = nums[0]  # dp[i-2]\n    prev1 = max(nums[0], nums[1])  # dp[i-1]\n    \n    for i in range(2, len(nums)):\n        current = max(nums[i] + prev2, prev1)\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1"
    },
    "javascript": {
      "template": "function houseRobber(nums) {\n  \n}",
      "solution_text": "<p><strong>Dynamic Programming Solution for House Robber:</strong></p><p>Find maximum money that can be robbed without robbing adjacent houses.</p><p><strong>Algorithm:</strong></p><ol><li>For each house, decide: rob current house + max from 2 houses back, or skip current house</li><li>dp[i] = max(nums[i] + dp[i-2], dp[i-1])</li><li>Base cases: dp[0] = nums[0], dp[1] = max(nums[0], nums[1])</li><li>Return dp[n-1] for maximum possible money</li></ol><p><strong>Time Complexity:</strong> O(n) - single pass through houses</p><p><strong>Space Complexity:</strong> O(1) - can optimize to use two variables</p>",
      "solution_code": "function houseRobber(nums) {\n    if (nums.length === 0) return 0;\n    if (nums.length === 1) return nums[0];\n    \n    // dp[i] represents max money we can rob up to house i\n    let prev2 = nums[0];  // dp[i-2]\n    let prev1 = Math.max(nums[0], nums[1]);  // dp[i-1]\n    \n    for (let i = 2; i < nums.length; i++) {\n        const current = Math.max(nums[i] + prev2, prev1);\n        prev2 = prev1;\n        prev1 = current;\n    }\n    \n    return prev1;\n}"
    },
    "typescript": {
      "template": "function houseRobber(nums: number[]): number {\n  \n}",
      "solution_text": "<p><strong>Dynamic Programming Solution for House Robber:</strong></p><p>Find maximum money that can be robbed without robbing adjacent houses.</p><p><strong>Algorithm:</strong></p><ol><li>For each house, decide: rob current house + max from 2 houses back, or skip current house</li><li>dp[i] = max(nums[i] + dp[i-2], dp[i-1])</li><li>Base cases: dp[0] = nums[0], dp[1] = max(nums[0], nums[1])</li><li>Return dp[n-1] for maximum possible money</li></ol><p><strong>Time Complexity:</strong> O(n) - single pass through houses</p><p><strong>Space Complexity:</strong> O(1) - can optimize to use two variables</p>",
      "solution_code": "function houseRobber(nums: number[]): number {\n    if (nums.length === 0) return 0;\n    if (nums.length === 1) return nums[0];\n    \n    // dp[i] represents max money we can rob up to house i\n    let prev2: number = nums[0];  // dp[i-2]\n    let prev1: number = Math.max(nums[0], nums[1]);  // dp[i-1]\n    \n    for (let i = 2; i < nums.length; i++) {\n        const current: number = Math.max(nums[i] + prev2, prev1);\n        prev2 = prev1;\n        prev1 = current;\n    }\n    \n    return prev1;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int houseRobber(int[] nums) {\n        \n    }\n}",
      "solution_text": "<p><strong>Dynamic Programming Solution for House Robber:</strong></p><p>Find maximum money that can be robbed without robbing adjacent houses.</p><p><strong>Algorithm:</strong></p><ol><li>For each house, decide: rob current house + max from 2 houses back, or skip current house</li><li>dp[i] = max(nums[i] + dp[i-2], dp[i-1])</li><li>Base cases: dp[0] = nums[0], dp[1] = max(nums[0], nums[1])</li><li>Return dp[n-1] for maximum possible money</li></ol><p><strong>Time Complexity:</strong> O(n) - single pass through houses</p><p><strong>Space Complexity:</strong> O(1) - can optimize to use two variables</p>",
      "solution_code": "class Solution {\n    public int houseRobber(int[] nums) {\n        if (nums.length == 0) return 0;\n        if (nums.length == 1) return nums[0];\n        \n        // dp[i] represents max money we can rob up to house i\n        int prev2 = nums[0];  // dp[i-2]\n        int prev1 = Math.max(nums[0], nums[1]);  // dp[i-1]\n        \n        for (int i = 2; i < nums.length; i++) {\n            int current = Math.max(nums[i] + prev2, prev1);\n            prev2 = prev1;\n            prev1 = current;\n        }\n        \n        return prev1;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "nums": [
          1,
          1,
          3,
          3
        ]
      },
      "output": 4
    },
    {
      "id": 2,
      "input": {
        "nums": [
          2,
          9,
          8,
          3,
          6
        ]
      },
      "output": 16
    },
    {
      "id": 3,
      "input": {
        "nums": [1]
      },
      "output": 1
    },
    {
      "id": 4,
      "input": {
        "nums": [2, 1]
      },
      "output": 2
    },
    {
      "id": 5,
      "input": {
        "nums": [5, 1, 3, 9]
      },
      "output": 14
    },
    {
      "id": 6,
      "input": {
        "nums": [2, 7, 9, 3, 1]
      },
      "output": 12
    },
    {
      "id": 7,
      "input": {
        "nums": [100, 1, 1, 100]
      },
      "output": 200
    },
    {
      "id": 8,
      "input": {
        "nums": [5, 5, 10, 100, 10, 5]
      },
      "output": 110
    },
    {
      "id": 9,
      "input": {
        "nums": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      },
      "output": 30
    },
    {
      "id": 10,
      "input": {
        "nums": [50, 1, 1, 50, 1, 1, 50]
      },
      "output": 150
    }
  ]
}