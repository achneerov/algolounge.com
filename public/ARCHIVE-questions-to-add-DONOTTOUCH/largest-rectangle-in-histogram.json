{
  "filename": "largest-rectangle-in-histogram",
  "title": "Largest Rectangle In Histogram",
  "keywords": [
    "largest",
    "rectangle",
    "histogram",
    "leetcode",
    "given",
    "array",
    "integers",
    "heights",
    "where",
    "represents"
  ],
  "description": "<h2>Largest Rectangle In Histogram</h2><p>Leetcode 84. Largest Rectangle In Histogram</p><p></p><p>You are given an array of integers `heights` where `heights[i]` represents the height of a bar. The width of each bar is `1`.</p><p>    </p><p>Return the area of the largest rectangle that can be formed among the bars.</p><p></p><p>Note: This chart is known as a [histogram](https://en.wikipedia.org/wiki/Histogram).</p><h3>Examples:</h3><ul><li>Input: heights = [7,1,7,2,2,4]<br><br>Output: 8</li><li>Input: heights = [1,3,7]<br><br>Output: 7</li></ul><h3>Constraints:</h3><ul><li> `1 <= heights.length <= 1000`.</li><li> `0 <= heights[i] <= 1000`</li></ul>",
  "languages": {
    "python": {
      "template": "def largestRectangleInHistogram(heights):\n    ",
      "solution_text": "<h3>Largest Rectangle in Histogram - Stack Solution</h3>\n\n<p><strong>Algorithm:</strong></p>\n<ol>\n<li>Use a stack to maintain indices of increasing heights</li>\n<li>For each bar, pop from stack while current height is smaller</li>\n<li>Calculate area using popped height as the smallest bar</li>\n<li>Track maximum area found</li>\n</ol>\n\n<p><strong>Time Complexity:</strong> O(n) - each element pushed and popped at most once</p>\n<p><strong>Space Complexity:</strong> O(n) - stack space</p>\n\n<p><strong>Key Insights:</strong></p>\n<ul>\n<li>Stack maintains increasing heights for potential rectangles</li>\n<li>When we find a smaller height, we can complete rectangles</li>\n<li>Width of rectangle determined by stack indices</li>\n</ul>",
      "solution_code": "def largestRectangleInHistogram(heights):\n    stack = []\n    max_area = 0\n    \n    for i, height in enumerate(heights):\n        # Pop from stack while current height is smaller\n        while stack and heights[stack[-1]] > height:\n            h = heights[stack.pop()]\n            # Width is determined by current index and previous stack top\n            w = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        \n        stack.append(i)\n    \n    # Process remaining bars in stack\n    while stack:\n        h = heights[stack.pop()]\n        w = len(heights) if not stack else len(heights) - stack[-1] - 1\n        max_area = max(max_area, h * w)\n    \n    return max_area"
    },
    "javascript": {
      "template": "function largestRectangleInHistogram(heights) {\n  \n}",
      "solution_text": "<h3>Largest Rectangle in Histogram - Stack Solution</h3>\n\n<p><strong>Algorithm:</strong></p>\n<ol>\n<li>Use a stack to maintain indices of increasing heights</li>\n<li>For each bar, pop from stack while current height is smaller</li>\n<li>Calculate area using popped height as the smallest bar</li>\n<li>Track maximum area found</li>\n</ol>\n\n<p><strong>Time Complexity:</strong> O(n) - each element pushed and popped at most once</p>\n<p><strong>Space Complexity:</strong> O(n) - stack space</p>\n\n<p><strong>Key Insights:</strong></p>\n<ul>\n<li>Stack maintains increasing heights for potential rectangles</li>\n<li>When we find a smaller height, we can complete rectangles</li>\n<li>Width of rectangle determined by stack indices</li>\n</ul>",
      "solution_code": "function largestRectangleInHistogram(heights) {\n    const stack = [];\n    let maxArea = 0;\n    \n    for (let i = 0; i < heights.length; i++) {\n        // Pop from stack while current height is smaller\n        while (stack.length > 0 && heights[stack[stack.length - 1]] > heights[i]) {\n            const h = heights[stack.pop()];\n            // Width is determined by current index and previous stack top\n            const w = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;\n            maxArea = Math.max(maxArea, h * w);\n        }\n        \n        stack.push(i);\n    }\n    \n    // Process remaining bars in stack\n    while (stack.length > 0) {\n        const h = heights[stack.pop()];\n        const w = stack.length === 0 ? heights.length : heights.length - stack[stack.length - 1] - 1;\n        maxArea = Math.max(maxArea, h * w);\n    }\n    \n    return maxArea;\n}"
    },
    "typescript": {
      "template": "function largestRectangleInHistogram(heights: number[]): number {\n  \n}",
      "solution_text": "<h3>Largest Rectangle in Histogram - Stack Solution</h3>\n\n<p><strong>Algorithm:</strong></p>\n<ol>\n<li>Use a stack to maintain indices of increasing heights</li>\n<li>For each bar, pop from stack while current height is smaller</li>\n<li>Calculate area using popped height as the smallest bar</li>\n<li>Track maximum area found</li>\n</ol>\n\n<p><strong>Time Complexity:</strong> O(n) - each element pushed and popped at most once</p>\n<p><strong>Space Complexity:</strong> O(n) - stack space</p>\n\n<p><strong>Key Insights:</strong></p>\n<ul>\n<li>Stack maintains increasing heights for potential rectangles</li>\n<li>When we find a smaller height, we can complete rectangles</li>\n<li>Width of rectangle determined by stack indices</li>\n</ul>",
      "solution_code": "function largestRectangleInHistogram(heights: number[]): number {\n    const stack: number[] = [];\n    let maxArea = 0;\n    \n    for (let i = 0; i < heights.length; i++) {\n        // Pop from stack while current height is smaller\n        while (stack.length > 0 && heights[stack[stack.length - 1]] > heights[i]) {\n            const h = heights[stack.pop()!];\n            // Width is determined by current index and previous stack top\n            const w = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;\n            maxArea = Math.max(maxArea, h * w);\n        }\n        \n        stack.push(i);\n    }\n    \n    // Process remaining bars in stack\n    while (stack.length > 0) {\n        const h = heights[stack.pop()!];\n        const w = stack.length === 0 ? heights.length : heights.length - stack[stack.length - 1] - 1;\n        maxArea = Math.max(maxArea, h * w);\n    }\n    \n    return maxArea;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int largestRectangleInHistogram(int[] heights) {\n        \n    }\n}",
      "solution_text": "<h3>Largest Rectangle in Histogram - Stack Solution</h3>\n\n<p><strong>Algorithm:</strong></p>\n<ol>\n<li>Use a stack to maintain indices of increasing heights</li>\n<li>For each bar, pop from stack while current height is smaller</li>\n<li>Calculate area using popped height as the smallest bar</li>\n<li>Track maximum area found</li>\n</ol>\n\n<p><strong>Time Complexity:</strong> O(n) - each element pushed and popped at most once</p>\n<p><strong>Space Complexity:</strong> O(n) - stack space</p>\n\n<p><strong>Key Insights:</strong></p>\n<ul>\n<li>Stack maintains increasing heights for potential rectangles</li>\n<li>When we find a smaller height, we can complete rectangles</li>\n<li>Width of rectangle determined by stack indices</li>\n</ul>",
      "solution_code": "import java.util.*;\n\nclass Solution {\n    public int largestRectangleInHistogram(int[] heights) {\n        Stack<Integer> stack = new Stack<>();\n        int maxArea = 0;\n        \n        for (int i = 0; i < heights.length; i++) {\n            // Pop from stack while current height is smaller\n            while (!stack.isEmpty() && heights[stack.peek()] > heights[i]) {\n                int h = heights[stack.pop()];\n                // Width is determined by current index and previous stack top\n                int w = stack.isEmpty() ? i : i - stack.peek() - 1;\n                maxArea = Math.max(maxArea, h * w);\n            }\n            \n            stack.push(i);\n        }\n        \n        // Process remaining bars in stack\n        while (!stack.isEmpty()) {\n            int h = heights[stack.pop()];\n            int w = stack.isEmpty() ? heights.length : heights.length - stack.peek() - 1;\n            maxArea = Math.max(maxArea, h * w);\n        }\n        \n        return maxArea;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "heights": [7, 1, 7, 2, 2, 4]
      },
      "output": 8
    },
    {
      "id": 2,
      "input": {
        "heights": [1, 3, 7]
      },
      "output": 7
    },
    {
      "id": 3,
      "input": {
        "heights": [2, 1, 5, 6, 2, 3]
      },
      "output": 10
    },
    {
      "id": 4,
      "input": {
        "heights": [1]
      },
      "output": 1
    },
    {
      "id": 5,
      "input": {
        "heights": [4, 4, 4, 4]
      },
      "output": 16
    },
    {
      "id": 6,
      "input": {
        "heights": [1, 2, 3, 4, 5]
      },
      "output": 9
    },
    {
      "id": 7,
      "input": {
        "heights": [5, 4, 3, 2, 1]
      },
      "output": 9
    },
    {
      "id": 8,
      "input": {
        "heights": [0, 9]
      },
      "output": 9
    },
    {
      "id": 9,
      "input": {
        "heights": [2, 4]
      },
      "output": 4
    },
    {
      "id": 10,
      "input": {
        "heights": [6, 7, 5, 2, 4, 5, 9, 3]
      },
      "output": 16
    }
  ]
}