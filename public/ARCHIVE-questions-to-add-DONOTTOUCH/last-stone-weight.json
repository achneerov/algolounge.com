{
  "filename": "last-stone-weight",
  "title": "Last Stone Weight",
  "keywords": [
    "last",
    "stone",
    "weight",
    "leetcode",
    "1046",
    "given",
    "array",
    "integers",
    "stones",
    "where"
  ],
  "description": "<h2>Last Stone Weight</h2><p>Leetcode 1046. Last Stone Weight</p><p></p><p>You are given an array of integers `stones` where `stones[i]` represents the weight of the `ith` stone.</p><p></p><p>We want to run a simulation on the stones as follows:</p><p></p><p>* At each step we choose the **two heaviest stones**, with weight `x` and `y` and smash them togethers</p><p>* If `x == y`, both stones are destroyed</p><p>* If `x < y`, the stone of weight `x` is destroyed, and the stone of weight `y` has new weight `y - x`.</p><p></p><p>Continue the simulation until there is no more than one stone remaining.</p><p></p><p>Return the weight of the last remaining stone or return `0` if none remain.</p><h3>Examples:</h3><ul><li>Input: stones = [2,3,6,2,4]<br><br>Output: 1<br>We smash 6 and 4 and are left with a 2, so the array becomes [2,3,2,2].\nWe smash 3 and 2 and are left with a 1, so the array becomes [1,2,2].\nWe smash 2 and 2, so the array becomes [1].</li><li>Input: stones = [1,2]<br><br>Output: 1</li></ul><h3>Constraints:</h3><ul><li> `1 <= stones.length <= 20`</li><li> `1 <= stones[i] <= 100`</li></ul>",
  "languages": {
    "python": {
      "template": "def lastStoneWeight(stones):\n    ",
      "solution_text": "<h3>Last Stone Weight - Max Heap Solution</h3>\n\n<p><strong>Algorithm:</strong></p>\n<ol>\n<li>Use a max heap to always get the two heaviest stones</li>\n<li>Pop two stones, smash them together</li>\n<li>If difference > 0, push back the remaining weight</li>\n<li>Continue until at most one stone remains</li>\n</ol>\n\n<p><strong>Time Complexity:</strong> O(n log n) - each heap operation is O(log n)</p>\n<p><strong>Space Complexity:</strong> O(n) - heap storage</p>\n\n<p><strong>Key Insights:</strong></p>\n<ul>\n<li>Max heap gives us heaviest stones efficiently</li>\n<li>Python uses min heap, so negate values for max heap behavior</li>\n<li>Continue until heap is empty or has one element</li>\n</ul>",
      "solution_code": "import heapq\n\ndef lastStoneWeight(stones):\n    # Python heapq is min heap, so negate values for max heap\n    heap = [-stone for stone in stones]\n    heapq.heapify(heap)\n    \n    while len(heap) > 1:\n        # Get two heaviest stones (remember they're negated)\n        first = -heapq.heappop(heap)\n        second = -heapq.heappop(heap)\n        \n        # If there's a difference, push it back\n        if first != second:\n            heapq.heappush(heap, -(first - second))\n    \n    # Return last stone weight or 0 if no stones remain\n    return -heap[0] if heap else 0"
    },
    "javascript": {
      "template": "function lastStoneWeight(stones) {\n  \n}",
      "solution_text": "<h3>Last Stone Weight - Max Heap Solution</h3>\n\n<p><strong>Algorithm:</strong></p>\n<ol>\n<li>Use a max heap to always get the two heaviest stones</li>\n<li>Pop two stones, smash them together</li>\n<li>If difference > 0, push back the remaining weight</li>\n<li>Continue until at most one stone remains</li>\n</ol>\n\n<p><strong>Time Complexity:</strong> O(n log n) - each heap operation is O(log n)</p>\n<p><strong>Space Complexity:</strong> O(n) - heap storage</p>\n\n<p><strong>Key Insights:</strong></p>\n<ul>\n<li>Max heap gives us heaviest stones efficiently</li>\n<li>JavaScript doesn't have built-in heap, so implement or use array with sorting</li>\n<li>Continue until heap is empty or has one element</li>\n</ul>",
      "solution_code": "function lastStoneWeight(stones) {\n    // Use array and sort approach since JS doesn't have built-in heap\n    const heap = [...stones];\n    \n    while (heap.length > 1) {\n        // Sort to get heaviest stones at the end\n        heap.sort((a, b) => a - b);\n        \n        // Get two heaviest stones\n        const first = heap.pop();\n        const second = heap.pop();\n        \n        // If there's a difference, push it back\n        if (first !== second) {\n            heap.push(first - second);\n        }\n    }\n    \n    // Return last stone weight or 0 if no stones remain\n    return heap.length > 0 ? heap[0] : 0;\n}"
    },
    "typescript": {
      "template": "function lastStoneWeight(stones: number[]): number {\n  \n}",
      "solution_text": "<h3>Last Stone Weight - Max Heap Solution</h3>\n\n<p><strong>Algorithm:</strong></p>\n<ol>\n<li>Use a max heap to always get the two heaviest stones</li>\n<li>Pop two stones, smash them together</li>\n<li>If difference > 0, push back the remaining weight</li>\n<li>Continue until at most one stone remains</li>\n</ol>\n\n<p><strong>Time Complexity:</strong> O(n log n) - each heap operation is O(log n)</p>\n<p><strong>Space Complexity:</strong> O(n) - heap storage</p>\n\n<p><strong>Key Insights:</strong></p>\n<ul>\n<li>Max heap gives us heaviest stones efficiently</li>\n<li>TypeScript doesn't have built-in heap, so implement or use array with sorting</li>\n<li>Continue until heap is empty or has one element</li>\n</ul>",
      "solution_code": "function lastStoneWeight(stones: number[]): number {\n    // Use array and sort approach since TS doesn't have built-in heap\n    const heap: number[] = [...stones];\n    \n    while (heap.length > 1) {\n        // Sort to get heaviest stones at the end\n        heap.sort((a, b) => a - b);\n        \n        // Get two heaviest stones\n        const first = heap.pop()!;\n        const second = heap.pop()!;\n        \n        // If there's a difference, push it back\n        if (first !== second) {\n            heap.push(first - second);\n        }\n    }\n    \n    // Return last stone weight or 0 if no stones remain\n    return heap.length > 0 ? heap[0] : 0;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int lastStoneWeight(int[] stones) {\n        \n    }\n}",
      "solution_text": "<h3>Last Stone Weight - Max Heap Solution</h3>\n\n<p><strong>Algorithm:</strong></p>\n<ol>\n<li>Use a max heap to always get the two heaviest stones</li>\n<li>Pop two stones, smash them together</li>\n<li>If difference > 0, push back the remaining weight</li>\n<li>Continue until at most one stone remains</li>\n</ol>\n\n<p><strong>Time Complexity:</strong> O(n log n) - each heap operation is O(log n)</p>\n<p><strong>Space Complexity:</strong> O(n) - heap storage</p>\n\n<p><strong>Key Insights:</strong></p>\n<ul>\n<li>Max heap gives us heaviest stones efficiently</li>\n<li>Java PriorityQueue is min heap by default, so use reverse comparator</li>\n<li>Continue until heap is empty or has one element</li>\n</ul>",
      "solution_code": "import java.util.*;\n\nclass Solution {\n    public int lastStoneWeight(int[] stones) {\n        // Use PriorityQueue as max heap (reverse natural order)\n        PriorityQueue<Integer> heap = new PriorityQueue<>(Collections.reverseOrder());\n        \n        // Add all stones to heap\n        for (int stone : stones) {\n            heap.offer(stone);\n        }\n        \n        while (heap.size() > 1) {\n            // Get two heaviest stones\n            int first = heap.poll();\n            int second = heap.poll();\n            \n            // If there's a difference, push it back\n            if (first != second) {\n                heap.offer(first - second);\n            }\n        }\n        \n        // Return last stone weight or 0 if no stones remain\n        return heap.isEmpty() ? 0 : heap.peek();\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "stones": [2, 3, 6, 2, 4]
      },
      "output": 1
    },
    {
      "id": 2,
      "input": {
        "stones": [1, 2]
      },
      "output": 1
    },
    {
      "id": 3,
      "input": {
        "stones": [1]
      },
      "output": 1
    },
    {
      "id": 4,
      "input": {
        "stones": [3, 7, 2]
      },
      "output": 2
    },
    {
      "id": 5,
      "input": {
        "stones": [9, 3, 2, 10]
      },
      "output": 1
    },
    {
      "id": 6,
      "input": {
        "stones": [5, 5]
      },
      "output": 0
    },
    {
      "id": 7,
      "input": {
        "stones": [8, 7, 6, 5, 4, 3, 2]
      },
      "output": 1
    },
    {
      "id": 8,
      "input": {
        "stones": [20, 1, 1]
      },
      "output": 18
    },
    {
      "id": 9,
      "input": {
        "stones": [4, 3, 4, 3]
      },
      "output": 0
    },
    {
      "id": 10,
      "input": {
        "stones": [7, 6, 7, 6, 9]
      },
      "output": 3
    }
  ]
}