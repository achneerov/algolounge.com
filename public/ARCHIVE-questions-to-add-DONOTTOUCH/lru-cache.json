{
  "filename": "lru-cache",
  "title": "LRU Cache",
  "keywords": [
    "lru",
    "cache",
    "leetcode",
    "146",
    "implement",
    "least",
    "recently",
    "used",
    "https",
    "wikipedia"
  ],
  "description": "<h2>LRU Cache</h2><p>Leetcode 146. LRU Cache</p><p>Implement the <a href=\"https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\">Least Recently Used (LRU)</a> cache class <code>LRUCache</code>. The class should support the following operations:</p><ul><li><code>LRUCache(int capacity)</code> Initialize the LRU cache of size <code>capacity</code>.</li><li><code>int get(int key)</code> Return the value corresponding to the <code>key</code> if the <code>key</code> exists, otherwise return <code>-1</code>.</li><li><code>void put(int key, int value)</code> Update the <code>value</code> of the <code>key</code> if the <code>key</code> exists. Otherwise, add the <code>key</code>-<code>value</code> pair to the cache. If the introduction of the new pair causes the cache to exceed its capacity, remove the least recently used key.</li></ul><p>A key is considered used if a <code>get</code> or a <code>put</code> operation is called on it.</p><p>Ensure that <code>get</code> and <code>put</code> each run in <strong>O(1)</strong> average time complexity.</p><h3>Examples</h3><ul><li><strong>Input:</strong><br><code>[\"LRUCache\", [2], \"put\", [1, 10], \"get\", [1], \"put\", [2, 20], \"put\", [3, 30], \"get\", [2], \"get\", [1]]</code><br><br><strong>Output:</strong><br><code>[null, null, 10, null, null, 20, -1]</code><br><br><strong>Explanation:</strong><br><code>LRUCache lRUCache = new LRUCache(2);<br>lRUCache.put(1, 10);  // cache: {1=10}<br>lRUCache.get(1);      // return 10<br>lRUCache.put(2, 20);  // cache: {1=10, 2=20}<br>lRUCache.put(3, 30);  // cache: {2=20, 3=30}, key=1 was evicted<br>lRUCache.get(2);      // returns 20<br>lRUCache.get(1);      // return -1 (not found)</code></li></ul><h3>Constraints</h3><ul><li><code>1 <= capacity <= 100</code></li><li><code>0 <= key <= 1000</code></li><li><code>0 <= value <= 1000</code></li></ul>",
  "languages": {
    "python": {
      "template": "class LRUCache:\n    def __init__(self, capacity: int):\n        \n    \n    def get(self, key: int) -> int:\n        \n    \n    def put(self, key: int, value: int) -> None:\n        ",
      "solution_text": "Comprehensive LRU Cache implementation:\n\n**Algorithm:**\nThis implements an LRU Cache using a combination of a hash map and a doubly linked list to achieve O(1) time complexity for both get and put operations.\n\n**Time Complexity:** O(1) for both get and put operations\n**Space Complexity:** O(capacity) for storing the cache entries\n\n**Key Insights:**\n- Use hash map for O(1) key lookups\n- Use doubly linked list to maintain order and enable O(1) insertions/deletions\n- Move accessed nodes to front (most recently used)\n- Remove nodes from back (least recently used) when capacity exceeded",
      "solution_code": "class LRUCache:\n    \n    class Node:\n        def __init__(self, key=0, value=0):\n            self.key = key\n            self.value = value\n            self.prev = None\n            self.next = None\n    \n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}  # key -> node\n        \n        # Create dummy head and tail nodes\n        self.head = self.Node()\n        self.tail = self.Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n    \n    def _add_node(self, node):\n        \"\"\"Add node right after head\"\"\"\n        node.prev = self.head\n        node.next = self.head.next\n        \n        self.head.next.prev = node\n        self.head.next = node\n    \n    def _remove_node(self, node):\n        \"\"\"Remove an existing node from the linked list\"\"\"\n        prev_node = node.prev\n        next_node = node.next\n        \n        prev_node.next = next_node\n        next_node.prev = prev_node\n    \n    def _move_to_head(self, node):\n        \"\"\"Move node to head (mark as most recently used)\"\"\"\n        self._remove_node(node)\n        self._add_node(node)\n    \n    def _pop_tail(self):\n        \"\"\"Pop the last node (least recently used)\"\"\"\n        last_node = self.tail.prev\n        self._remove_node(last_node)\n        return last_node\n    \n    def get(self, key: int) -> int:\n        node = self.cache.get(key)\n        \n        if not node:\n            return -1\n        \n        # Move to head (mark as recently used)\n        self._move_to_head(node)\n        \n        return node.value\n    \n    def put(self, key: int, value: int) -> None:\n        node = self.cache.get(key)\n        \n        if not node:\n            new_node = self.Node(key, value)\n            \n            if len(self.cache) >= self.capacity:\n                # Remove least recently used\n                tail = self._pop_tail()\n                del self.cache[tail.key]\n            \n            self.cache[key] = new_node\n            self._add_node(new_node)\n        else:\n            # Update existing node\n            node.value = value\n            self._move_to_head(node)"
    },
    "javascript": {
      "template": "class LRUCache {\n    constructor(capacity) {\n        \n    }\n    \n    get(key) {\n        \n    }\n    \n    put(key, value) {\n        \n    }\n}",
      "solution_text": "Comprehensive LRU Cache implementation:\n\n**Algorithm:**\nThis implements an LRU Cache using a combination of a hash map and a doubly linked list to achieve O(1) time complexity for both get and put operations.\n\n**Time Complexity:** O(1) for both get and put operations\n**Space Complexity:** O(capacity) for storing the cache entries\n\n**Key Insights:**\n- Use hash map for O(1) key lookups\n- Use doubly linked list to maintain order and enable O(1) insertions/deletions\n- Move accessed nodes to front (most recently used)\n- Remove nodes from back (least recently used) when capacity exceeded",
      "solution_code": "class LRUCache {\n    constructor(capacity) {\n        this.capacity = capacity;\n        this.cache = new Map(); // key -> node\n        \n        // Create dummy head and tail nodes\n        this.head = { key: 0, value: 0, prev: null, next: null };\n        this.tail = { key: 0, value: 0, prev: null, next: null };\n        this.head.next = this.tail;\n        this.tail.prev = this.head;\n    }\n    \n    _addNode(node) {\n        // Add node right after head\n        node.prev = this.head;\n        node.next = this.head.next;\n        \n        this.head.next.prev = node;\n        this.head.next = node;\n    }\n    \n    _removeNode(node) {\n        // Remove an existing node from the linked list\n        const prevNode = node.prev;\n        const nextNode = node.next;\n        \n        prevNode.next = nextNode;\n        nextNode.prev = prevNode;\n    }\n    \n    _moveToHead(node) {\n        // Move node to head (mark as most recently used)\n        this._removeNode(node);\n        this._addNode(node);\n    }\n    \n    _popTail() {\n        // Pop the last node (least recently used)\n        const lastNode = this.tail.prev;\n        this._removeNode(lastNode);\n        return lastNode;\n    }\n    \n    get(key) {\n        const node = this.cache.get(key);\n        \n        if (!node) {\n            return -1;\n        }\n        \n        // Move to head (mark as recently used)\n        this._moveToHead(node);\n        \n        return node.value;\n    }\n    \n    put(key, value) {\n        const node = this.cache.get(key);\n        \n        if (!node) {\n            const newNode = { key, value, prev: null, next: null };\n            \n            if (this.cache.size >= this.capacity) {\n                // Remove least recently used\n                const tail = this._popTail();\n                this.cache.delete(tail.key);\n            }\n            \n            this.cache.set(key, newNode);\n            this._addNode(newNode);\n        } else {\n            // Update existing node\n            node.value = value;\n            this._moveToHead(node);\n        }\n    }\n}"
    },
    "typescript": {
      "template": "interface Node {\n    key: number;\n    value: number;\n    prev: Node | null;\n    next: Node | null;\n}\n\nclass LRUCache {\n    constructor(capacity: number) {\n        \n    }\n    \n    get(key: number): number {\n        \n    }\n    \n    put(key: number, value: number): void {\n        \n    }\n}",
      "solution_text": "Comprehensive LRU Cache implementation:\n\n**Algorithm:**\nThis implements an LRU Cache using a combination of a hash map and a doubly linked list to achieve O(1) time complexity for both get and put operations.\n\n**Time Complexity:** O(1) for both get and put operations\n**Space Complexity:** O(capacity) for storing the cache entries\n\n**Key Insights:**\n- Use hash map for O(1) key lookups\n- Use doubly linked list to maintain order and enable O(1) insertions/deletions\n- Move accessed nodes to front (most recently used)\n- Remove nodes from back (least recently used) when capacity exceeded",
      "solution_code": "interface Node {\n    key: number;\n    value: number;\n    prev: Node | null;\n    next: Node | null;\n}\n\nclass LRUCache {\n    private capacity: number;\n    private cache: Map<number, Node>;\n    private head: Node;\n    private tail: Node;\n    \n    constructor(capacity: number) {\n        this.capacity = capacity;\n        this.cache = new Map<number, Node>();\n        \n        // Create dummy head and tail nodes\n        this.head = { key: 0, value: 0, prev: null, next: null };\n        this.tail = { key: 0, value: 0, prev: null, next: null };\n        this.head.next = this.tail;\n        this.tail.prev = this.head;\n    }\n    \n    private _addNode(node: Node): void {\n        // Add node right after head\n        node.prev = this.head;\n        node.next = this.head.next;\n        \n        this.head.next!.prev = node;\n        this.head.next = node;\n    }\n    \n    private _removeNode(node: Node): void {\n        // Remove an existing node from the linked list\n        const prevNode = node.prev!;\n        const nextNode = node.next!;\n        \n        prevNode.next = nextNode;\n        nextNode.prev = prevNode;\n    }\n    \n    private _moveToHead(node: Node): void {\n        // Move node to head (mark as most recently used)\n        this._removeNode(node);\n        this._addNode(node);\n    }\n    \n    private _popTail(): Node {\n        // Pop the last node (least recently used)\n        const lastNode = this.tail.prev!;\n        this._removeNode(lastNode);\n        return lastNode;\n    }\n    \n    get(key: number): number {\n        const node = this.cache.get(key);\n        \n        if (!node) {\n            return -1;\n        }\n        \n        // Move to head (mark as recently used)\n        this._moveToHead(node);\n        \n        return node.value;\n    }\n    \n    put(key: number, value: number): void {\n        const node = this.cache.get(key);\n        \n        if (!node) {\n            const newNode: Node = { key, value, prev: null, next: null };\n            \n            if (this.cache.size >= this.capacity) {\n                // Remove least recently used\n                const tail = this._popTail();\n                this.cache.delete(tail.key);\n            }\n            \n            this.cache.set(key, newNode);\n            this._addNode(newNode);\n        } else {\n            // Update existing node\n            node.value = value;\n            this._moveToHead(node);\n        }\n    }\n}"
    },
    "java": {
      "template": "import java.util.*;\n\nclass LRUCache {\n    public LRUCache(int capacity) {\n        \n    }\n    \n    public int get(int key) {\n        \n    }\n    \n    public void put(int key, int value) {\n        \n    }\n}",
      "solution_text": "Comprehensive LRU Cache implementation:\n\n**Algorithm:**\nThis implements an LRU Cache using a combination of a hash map and a doubly linked list to achieve O(1) time complexity for both get and put operations.\n\n**Time Complexity:** O(1) for both get and put operations\n**Space Complexity:** O(capacity) for storing the cache entries\n\n**Key Insights:**\n- Use hash map for O(1) key lookups\n- Use doubly linked list to maintain order and enable O(1) insertions/deletions\n- Move accessed nodes to front (most recently used)\n- Remove nodes from back (least recently used) when capacity exceeded",
      "solution_code": "import java.util.*;\n\nclass LRUCache {\n    \n    class Node {\n        int key;\n        int value;\n        Node prev;\n        Node next;\n        \n        Node(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n    \n    private int capacity;\n    private Map<Integer, Node> cache;\n    private Node head;\n    private Node tail;\n    \n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        this.cache = new HashMap<>();\n        \n        // Create dummy head and tail nodes\n        this.head = new Node(0, 0);\n        this.tail = new Node(0, 0);\n        this.head.next = this.tail;\n        this.tail.prev = this.head;\n    }\n    \n    private void addNode(Node node) {\n        // Add node right after head\n        node.prev = head;\n        node.next = head.next;\n        \n        head.next.prev = node;\n        head.next = node;\n    }\n    \n    private void removeNode(Node node) {\n        // Remove an existing node from the linked list\n        Node prevNode = node.prev;\n        Node nextNode = node.next;\n        \n        prevNode.next = nextNode;\n        nextNode.prev = prevNode;\n    }\n    \n    private void moveToHead(Node node) {\n        // Move node to head (mark as most recently used)\n        removeNode(node);\n        addNode(node);\n    }\n    \n    private Node popTail() {\n        // Pop the last node (least recently used)\n        Node lastNode = tail.prev;\n        removeNode(lastNode);\n        return lastNode;\n    }\n    \n    public int get(int key) {\n        Node node = cache.get(key);\n        \n        if (node == null) {\n            return -1;\n        }\n        \n        // Move to head (mark as recently used)\n        moveToHead(node);\n        \n        return node.value;\n    }\n    \n    public void put(int key, int value) {\n        Node node = cache.get(key);\n        \n        if (node == null) {\n            Node newNode = new Node(key, value);\n            \n            if (cache.size() >= capacity) {\n                // Remove least recently used\n                Node tail = popTail();\n                cache.remove(tail.key);\n            }\n            \n            cache.put(key, newNode);\n            addNode(newNode);\n        } else {\n            // Update existing node\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": [["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]],
      "output": [null, null, null, 1, null, -1, null, -1, 3, 4]
    },
    {
      "id": 2,
      "input": [["LRUCache", "put", "get", "put", "get", "get"], [[1], [2, 1], [2], [3, 2], [2], [3]]],
      "output": [null, null, 1, null, -1, 2]
    },
    {
      "id": 3,
      "input": [["LRUCache", "get"], [[1], [1]]],
      "output": [null, -1]
    },
    {
      "id": 4,
      "input": [["LRUCache", "put", "put", "put", "put", "get", "get"], [[2], [1, 10], [2, 20], [1, 15], [3, 30], [2], [1]]],
      "output": [null, null, null, null, null, -1, 15]
    },
    {
      "id": 5,
      "input": [["LRUCache", "put", "put", "put", "get", "get", "get"], [[3], [1, 1], [2, 2], [3, 3], [1], [2], [3]]],
      "output": [null, null, null, null, 1, 2, 3]
    },
    {
      "id": 6,
      "input": [["LRUCache", "put", "put", "get", "put", "put", "get"], [[2], [2, 1], [1, 1], [2], [4, 1], [3, 1], [1]]],
      "output": [null, null, null, 1, null, null, -1]
    },
    {
      "id": 7,
      "input": [["LRUCache", "put", "put", "put", "put", "put", "get", "put", "get", "get", "put", "get", "put", "put", "put", "get", "put", "get", "get", "get", "get", "put", "put", "get", "get", "get", "put", "put", "get", "put", "get", "put", "get", "get", "get", "put", "put", "put", "get", "put", "get", "get", "put", "put", "get", "put", "put", "put", "put", "get", "put", "put", "get", "put", "put", "get", "put", "put", "put", "put", "put", "get", "put", "put", "get", "put", "get", "get", "get", "put", "get", "get", "put", "put", "put", "put", "get", "put", "put", "put", "put", "get", "get", "get", "put", "put", "put", "get", "put", "put", "put", "get", "put", "put", "put", "get", "get", "get", "put", "put", "put", "put", "get", "put", "put", "put", "put", "put", "put", "put"], [[10], [10, 13], [3, 17], [6, 11], [10, 5], [9, 10], [13], [2, 19], [2], [3], [5, 25], [8], [9, 22], [5, 5], [1, 30], [11], [9, 12], [7], [5], [8], [9], [4, 30], [9, 3], [9], [10], [10], [6, 14], [3, 1], [3], [10, 11], [8], [2, 14], [1], [5], [4], [11, 4], [12, 24], [5, 18], [13], [7, 23], [8], [12], [3, 27], [2, 12], [5], [2, 9], [13, 4], [8, 18], [1, 7], [6], [9, 29], [8, 21], [5], [6, 30], [1, 12], [10], [4, 15], [7, 22], [11, 26], [8, 17], [9, 29], [5], [3, 4], [11, 30], [12], [4, 29], [3], [9], [6], [3, 4], [1], [10], [3, 29], [10, 28], [1, 20], [11, 13], [3], [3, 12], [3, 8], [10, 9], [3, 26], [8], [7], [5], [13, 17], [2, 27], [11, 15], [12], [9, 19], [2, 15], [3, 16], [1], [12, 17], [9, 1], [6, 19], [4], [5], [5], [8, 1], [11, 7], [5, 2], [9, 28], [1], [2, 2], [7, 4], [4, 22], [7, 24], [9, 26], [13, 28], [11, 26]]],
      "output": [null, null, null, null, null, null, -1, null, 19, 17, null, -1, null, null, null, -1, null, -1, 5, -1, 12, null, null, 3, 5, 5, null, null, 1, null, -1, null, 30, 5, 30, null, null, null, -1, null, -1, 24, null, null, 18, null, null, null, null, 14, null, null, 18, null, null, 11, null, null, null, null, null, 18, null, null, -1, null, 4, 29, 30, null, 12, 11, null, null, null, null, 29, null, null, null, null, 17, -1, 18, null, null, null, -1, null, null, null, 20, null, null, null, -1, 18, 18, null, null, null, null, 20, null, null, null, null, null, null, null]
    },
    {
      "id": 8,
      "input": [["LRUCache", "put", "get", "put", "get", "put", "get"], [[2], [1, 0], [1], [2, 2], [1], [1, 1], [1]]],
      "output": [null, null, 0, null, 0, null, 1]
    },
    {
      "id": 9,
      "input": [["LRUCache", "put", "put", "put", "get", "put", "get", "get", "put", "get", "get"], [[3], [1, 1], [2, 2], [3, 3], [1], [4, 4], [2], [1], [5, 5], [3], [4]]],
      "output": [null, null, null, null, 1, null, -1, 1, null, -1, 4]
    },
    {
      "id": 10,
      "input": [["LRUCache", "put", "put", "get", "get", "put", "put", "get", "get", "get", "get"], [[4], [1, 100], [2, 200], [1], [2], [3, 300], [4, 400], [1], [2], [3], [4]]],
      "output": [null, null, null, 100, 200, null, null, 100, 200, 300, 400]
    }
  ]
}