{
  "filename": "merge-k-sorted-linked-lists",
  "title": "Merge K Sorted Linked Lists",
  "keywords": [
    "merge",
    "sorted",
    "linked",
    "lists",
    "leetcode",
    "given",
    "array",
    "where",
    "each",
    "list"
  ],
  "description": "<h2>Merge K Sorted Linked Lists</h2><p>Leetcode 23. Merge K Sorted Lists</p><p></p><p>You are given an array of `k` linked lists `lists`, where each list is sorted in ascending order.</p><p></p><p>Return the **sorted** linked list that is the result of merging all of the individual linked lists.</p><h3>Examples:</h3><ul><li>Input: lists = [[1,2,4],[1,3,5],[3,6]]<br><br>Output: [1,1,2,3,3,4,5,6]</li><li>Input: lists = []<br><br>Output: []</li><li>Input: lists = [[]]<br><br>Output: []</li></ul><h3>Constraints:</h3><ul><li> `0 <= lists.length <= 1000`</li><li> `0 <= lists[i].length <= 100`</li><li> `-1000 <= lists[i][j] <= 1000`</li></ul>",
  "languages": {
    "python": {
      "template": "def mergeKSortedLinkedLists(lists):\n    ",
      "solution_text": "<h2>Solution: Divide and Conquer Merge</h2>\n\n<h3>Algorithm:</h3>\n<ul>\n<li>Use divide and conquer approach to merge lists pairwise</li>\n<li>Merge two sorted arrays at a time using two pointers</li>\n<li>Continue until only one merged list remains</li>\n<li>Handle edge cases like empty lists</li>\n</ul>\n\n<h3>Time Complexity:</h3>\n<p>O(n log k) - where n is total nodes and k is number of lists</p>\n\n<h3>Space Complexity:</h3>\n<p>O(1) - constant extra space for merging</p>\n\n<h3>Key Insights:</h3>\n<ul>\n<li>Pairwise merging reduces complexity from O(nk) to O(n log k)</li>\n<li>Two pointer technique for merging sorted arrays</li>\n<li>Divide and conquer minimizes number of comparisons</li>\n</ul>",
      "solution_code": "def mergeKSortedLinkedLists(lists):\n    if not lists:\n        return []\n    \n    def mergeTwoLists(list1, list2):\n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        result = []\n        i, j = 0, 0\n        \n        while i < len(list1) and j < len(list2):\n            if list1[i] <= list2[j]:\n                result.append(list1[i])\n                i += 1\n            else:\n                result.append(list2[j])\n                j += 1\n        \n        # Add remaining elements\n        result.extend(list1[i:])\n        result.extend(list2[j:])\n        \n        return result\n    \n    # Merge lists pairwise using divide and conquer\n    while len(lists) > 1:\n        merged_lists = []\n        \n        for i in range(0, len(lists), 2):\n            list1 = lists[i]\n            list2 = lists[i + 1] if i + 1 < len(lists) else []\n            merged_lists.append(mergeTwoLists(list1, list2))\n        \n        lists = merged_lists\n    \n    return lists[0]"
    },
    "javascript": {
      "template": "function mergeKSortedLinkedLists(lists) {\n  \n}",
      "solution_text": "<h2>Solution: Divide and Conquer Merge</h2>\n\n<h3>Algorithm:</h3>\n<ul>\n<li>Use divide and conquer approach to merge lists pairwise</li>\n<li>Merge two sorted arrays at a time using two pointers</li>\n<li>Continue until only one merged list remains</li>\n<li>Handle edge cases like empty lists</li>\n</ul>\n\n<h3>Time Complexity:</h3>\n<p>O(n log k) - where n is total nodes and k is number of lists</p>\n\n<h3>Space Complexity:</h3>\n<p>O(1) - constant extra space for merging</p>\n\n<h3>Key Insights:</h3>\n<ul>\n<li>Pairwise merging reduces complexity from O(nk) to O(n log k)</li>\n<li>Two pointer technique for merging sorted arrays</li>\n<li>Divide and conquer minimizes number of comparisons</li>\n</ul>",
      "solution_code": "function mergeKSortedLinkedLists(lists) {\n    if (!lists || lists.length === 0) {\n        return [];\n    }\n    \n    function mergeTwoLists(list1, list2) {\n        if (!list1) return list2;\n        if (!list2) return list1;\n        \n        const result = [];\n        let i = 0, j = 0;\n        \n        while (i < list1.length && j < list2.length) {\n            if (list1[i] <= list2[j]) {\n                result.push(list1[i]);\n                i++;\n            } else {\n                result.push(list2[j]);\n                j++;\n            }\n        }\n        \n        // Add remaining elements\n        while (i < list1.length) {\n            result.push(list1[i]);\n            i++;\n        }\n        while (j < list2.length) {\n            result.push(list2[j]);\n            j++;\n        }\n        \n        return result;\n    }\n    \n    // Merge lists pairwise using divide and conquer\n    while (lists.length > 1) {\n        const mergedLists = [];\n        \n        for (let i = 0; i < lists.length; i += 2) {\n            const list1 = lists[i];\n            const list2 = i + 1 < lists.length ? lists[i + 1] : [];\n            mergedLists.push(mergeTwoLists(list1, list2));\n        }\n        \n        lists = mergedLists;\n    }\n    \n    return lists[0];\n}"
    },
    "typescript": {
      "template": "function mergeKSortedLinkedLists(lists: number[][]): number[] {\n  \n}",
      "solution_text": "<h2>Solution: Divide and Conquer Merge</h2>\n\n<h3>Algorithm:</h3>\n<ul>\n<li>Use divide and conquer approach to merge lists pairwise</li>\n<li>Merge two sorted arrays at a time using two pointers</li>\n<li>Continue until only one merged list remains</li>\n<li>Handle edge cases like empty lists</li>\n</ul>\n\n<h3>Time Complexity:</h3>\n<p>O(n log k) - where n is total nodes and k is number of lists</p>\n\n<h3>Space Complexity:</h3>\n<p>O(1) - constant extra space for merging</p>\n\n<h3>Key Insights:</h3>\n<ul>\n<li>Pairwise merging reduces complexity from O(nk) to O(n log k)</li>\n<li>Two pointer technique for merging sorted arrays</li>\n<li>Divide and conquer minimizes number of comparisons</li>\n</ul>",
      "solution_code": "function mergeKSortedLinkedLists(lists: number[][]): number[] {\n    if (!lists || lists.length === 0) {\n        return [];\n    }\n    \n    function mergeTwoLists(list1: number[], list2: number[]): number[] {\n        if (!list1) return list2;\n        if (!list2) return list1;\n        \n        const result: number[] = [];\n        let i = 0, j = 0;\n        \n        while (i < list1.length && j < list2.length) {\n            if (list1[i] <= list2[j]) {\n                result.push(list1[i]);\n                i++;\n            } else {\n                result.push(list2[j]);\n                j++;\n            }\n        }\n        \n        // Add remaining elements\n        while (i < list1.length) {\n            result.push(list1[i]);\n            i++;\n        }\n        while (j < list2.length) {\n            result.push(list2[j]);\n            j++;\n        }\n        \n        return result;\n    }\n    \n    // Merge lists pairwise using divide and conquer\n    while (lists.length > 1) {\n        const mergedLists: number[][] = [];\n        \n        for (let i = 0; i < lists.length; i += 2) {\n            const list1 = lists[i];\n            const list2 = i + 1 < lists.length ? lists[i + 1] : [];\n            mergedLists.push(mergeTwoLists(list1, list2));\n        }\n        \n        lists = mergedLists;\n    }\n    \n    return lists[0];\n}"
    },
    "java": {
      "template": "class Solution {\n    public int[] mergeKSortedLinkedLists(int[][] lists) {\n        \n    }\n}",
      "solution_text": "<h2>Solution: Divide and Conquer Merge</h2>\n\n<h3>Algorithm:</h3>\n<ul>\n<li>Use divide and conquer approach to merge lists pairwise</li>\n<li>Merge two sorted arrays at a time using two pointers</li>\n<li>Continue until only one merged list remains</li>\n<li>Handle edge cases like empty lists</li>\n</ul>\n\n<h3>Time Complexity:</h3>\n<p>O(n log k) - where n is total nodes and k is number of lists</p>\n\n<h3>Space Complexity:</h3>\n<p>O(1) - constant extra space for merging</p>\n\n<h3>Key Insights:</h3>\n<ul>\n<li>Pairwise merging reduces complexity from O(nk) to O(n log k)</li>\n<li>Two pointer technique for merging sorted arrays</li>\n<li>Divide and conquer minimizes number of comparisons</li>\n</ul>",
      "solution_code": "import java.util.*;\n\nclass Solution {\n    public int[] mergeKSortedLinkedLists(int[][] lists) {\n        if (lists == null || lists.length == 0) {\n            return new int[0];\n        }\n        \n        List<int[]> listsCopy = new ArrayList<>();\n        for (int[] list : lists) {\n            if (list != null && list.length > 0) {\n                listsCopy.add(list);\n            }\n        }\n        \n        if (listsCopy.isEmpty()) {\n            return new int[0];\n        }\n        \n        // Merge lists pairwise using divide and conquer\n        while (listsCopy.size() > 1) {\n            List<int[]> mergedLists = new ArrayList<>();\n            \n            for (int i = 0; i < listsCopy.size(); i += 2) {\n                int[] list1 = listsCopy.get(i);\n                int[] list2 = i + 1 < listsCopy.size() ? listsCopy.get(i + 1) : new int[0];\n                mergedLists.add(mergeTwoLists(list1, list2));\n            }\n            \n            listsCopy = mergedLists;\n        }\n        \n        return listsCopy.get(0);\n    }\n    \n    private int[] mergeTwoLists(int[] list1, int[] list2) {\n        if (list1 == null || list1.length == 0) return list2;\n        if (list2 == null || list2.length == 0) return list1;\n        \n        int[] result = new int[list1.length + list2.length];\n        int i = 0, j = 0, k = 0;\n        \n        while (i < list1.length && j < list2.length) {\n            if (list1[i] <= list2[j]) {\n                result[k++] = list1[i++];\n            } else {\n                result[k++] = list2[j++];\n            }\n        }\n        \n        // Add remaining elements\n        while (i < list1.length) {\n            result[k++] = list1[i++];\n        }\n        while (j < list2.length) {\n            result[k++] = list2[j++];\n        }\n        \n        return result;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "lists": [[1, 4, 5], [1, 3, 4], [2, 6]]
      },
      "output": [1, 1, 2, 3, 4, 4, 5, 6]
    },
    {
      "id": 2,
      "input": {
        "lists": []
      },
      "output": []
    },
    {
      "id": 3,
      "input": {
        "lists": [[]]
      },
      "output": []
    },
    {
      "id": 4,
      "input": {
        "lists": [[1], [0]]
      },
      "output": [0, 1]
    },
    {
      "id": 5,
      "input": {
        "lists": [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
      },
      "output": [1, 2, 3, 4, 5, 6, 7, 8, 9]
    },
    {
      "id": 6,
      "input": {
        "lists": [[-1, 0, 1], [-2, 3], [5]]
      },
      "output": [-2, -1, 0, 1, 3, 5]
    },
    {
      "id": 7,
      "input": {
        "lists": [[1], [1], [1]]
      },
      "output": [1, 1, 1]
    },
    {
      "id": 8,
      "input": {
        "lists": [[1, 2], [], [3, 4]]
      },
      "output": [1, 2, 3, 4]
    },
    {
      "id": 9,
      "input": {
        "lists": [[0, 2, 5], [1, 6, 8], [1, 6, 8]]
      },
      "output": [0, 1, 1, 2, 5, 6, 6, 8, 8]
    },
    {
      "id": 10,
      "input": {
        "lists": [[-1000], [0], [1000]]
      },
      "output": [-1000, 0, 1000]
    }
  ]
}