{
  "filename": "min-cost-climbing-stairs",
  "title": "Min Cost Climbing Stairs",
  "keywords": [
    "min",
    "cost",
    "climbing",
    "stairs",
    "leetcode",
    "746",
    "given",
    "array",
    "integers",
    "where"
  ],
  "description": "<h2>Min Cost Climbing Stairs</h2><p>Leetcode 746. Min Cost Climbing Stairs</p><p></p><p>You are given an array of integers `cost` where `cost[i]` is the cost of taking a step from the `ith` floor of a staircase. After paying the cost, you can step to either the `(i + 1)th` floor or the `(i + 2)th` floor.</p><p></p><p>You may choose to start at the index `0` or the index `1` floor.</p><p></p><p>Return the minimum cost to reach the top of the staircase, i.e. just past the last index in `cost`.</p><h3>Examples:</h3><ul><li>Input: cost = [1,2,3]<br><br>Output: 2<br>We can start at index = `1` and pay the cost of `cost[1] = 2` and take two steps to reach the top. The total cost is `2`.</li><li>Input: cost = [1,2,1,2,1,1,1]<br><br>Output: 4<br>Start at index = `0`.\n* Pay the cost of `cost[0] = 1` and take two steps to reach index = `2`.\n* Pay the cost of `cost[2] = 1` and take two steps to reach index = `4`.\n* Pay the cost of `cost[4] = 1` and take two steps to reach index = `6`.\n* Pay the cost of `cost[6] = 1` and take one step to reach the top.\n* The total cost is `4`.</li></ul><h3>Constraints:</h3><ul><li> `2 <= cost.length <= 100`</li><li> `0 <= cost[i] <= 100`</li></ul>",
  "languages": {
    "python": {
      "template": "def minCostClimbingStairs(cost):\n    ",
      "solution_text": "<h2>Dynamic Programming Solution for Climbing Stairs</h2>\n\n<p><strong>Algorithm:</strong></p>\n<ul>\n<li>Use dynamic programming to find minimum cost to reach each step</li>\n<li>For each step, we can either come from step i-1 or i-2</li>\n<li>Choose the path with minimum cost</li>\n<li>Can start from step 0 or step 1</li>\n</ul>\n\n<p><strong>Time Complexity:</strong> O(n) - single pass through the array</p>\n<p><strong>Space Complexity:</strong> O(1) - optimized to use only two variables</p>\n\n<p><strong>Key Insights:</strong></p>\n<ul>\n<li>Bottom-up dynamic programming approach</li>\n<li>Space optimization using rolling variables</li>\n<li>Handle edge cases for small arrays</li>\n</ul>",
      "solution_code": "def minCostClimbingStairs(cost):\n    if not cost:\n        return 0\n    if len(cost) <= 2:\n        return min(cost)\n    \n    # We can start from step 0 or step 1\n    prev2 = cost[0]\n    prev1 = cost[1]\n    \n    # Calculate min cost to reach each step\n    for i in range(2, len(cost)):\n        current = cost[i] + min(prev1, prev2)\n        prev2 = prev1\n        prev1 = current\n    \n    # We can reach the top from either of the last two steps\n    return min(prev1, prev2)"
    },
    "javascript": {
      "template": "function minCostClimbingStairs(cost) {\n  \n}",
      "solution_text": "<h2>Dynamic Programming Solution for Climbing Stairs</h2>\n\n<p><strong>Algorithm:</strong></p>\n<ul>\n<li>Use dynamic programming to find minimum cost to reach each step</li>\n<li>For each step, we can either come from step i-1 or i-2</li>\n<li>Choose the path with minimum cost</li>\n<li>Can start from step 0 or step 1</li>\n</ul>\n\n<p><strong>Time Complexity:</strong> O(n) - single pass through the array</p>\n<p><strong>Space Complexity:</strong> O(1) - optimized to use only two variables</p>\n\n<p><strong>Key Insights:</strong></p>\n<ul>\n<li>Bottom-up dynamic programming approach</li>\n<li>Space optimization using rolling variables</li>\n<li>Handle edge cases for small arrays</li>\n</ul>",
      "solution_code": "function minCostClimbingStairs(cost) {\n    if (!cost || cost.length === 0) return 0;\n    if (cost.length <= 2) return Math.min(...cost);\n    \n    // We can start from step 0 or step 1\n    let prev2 = cost[0];\n    let prev1 = cost[1];\n    \n    // Calculate min cost to reach each step\n    for (let i = 2; i < cost.length; i++) {\n        const current = cost[i] + Math.min(prev1, prev2);\n        prev2 = prev1;\n        prev1 = current;\n    }\n    \n    // We can reach the top from either of the last two steps\n    return Math.min(prev1, prev2);\n}"
    },
    "typescript": {
      "template": "function minCostClimbingStairs(cost: number[]): number {\n  \n}",
      "solution_text": "<h2>Dynamic Programming Solution for Climbing Stairs</h2>\n\n<p><strong>Algorithm:</strong></p>\n<ul>\n<li>Use dynamic programming to find minimum cost to reach each step</li>\n<li>For each step, we can either come from step i-1 or i-2</li>\n<li>Choose the path with minimum cost</li>\n<li>Can start from step 0 or step 1</li>\n</ul>\n\n<p><strong>Time Complexity:</strong> O(n) - single pass through the array</p>\n<p><strong>Space Complexity:</strong> O(1) - optimized to use only two variables</p>\n\n<p><strong>Key Insights:</strong></p>\n<ul>\n<li>Bottom-up dynamic programming approach</li>\n<li>Space optimization using rolling variables</li>\n<li>Handle edge cases for small arrays</li>\n</ul>",
      "solution_code": "function minCostClimbingStairs(cost: number[]): number {\n    if (!cost || cost.length === 0) return 0;\n    if (cost.length <= 2) return Math.min(...cost);\n    \n    // We can start from step 0 or step 1\n    let prev2 = cost[0];\n    let prev1 = cost[1];\n    \n    // Calculate min cost to reach each step\n    for (let i = 2; i < cost.length; i++) {\n        const current = cost[i] + Math.min(prev1, prev2);\n        prev2 = prev1;\n        prev1 = current;\n    }\n    \n    // We can reach the top from either of the last two steps\n    return Math.min(prev1, prev2);\n}"
    },
    "java": {
      "template": "class Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        \n    }\n}",
      "solution_text": "<h2>Dynamic Programming Solution for Climbing Stairs</h2>\n\n<p><strong>Algorithm:</strong></p>\n<ul>\n<li>Use dynamic programming to find minimum cost to reach each step</li>\n<li>For each step, we can either come from step i-1 or i-2</li>\n<li>Choose the path with minimum cost</li>\n<li>Can start from step 0 or step 1</li>\n</ul>\n\n<p><strong>Time Complexity:</strong> O(n) - single pass through the array</p>\n<p><strong>Space Complexity:</strong> O(1) - optimized to use only two variables</p>\n\n<p><strong>Key Insights:</strong></p>\n<ul>\n<li>Bottom-up dynamic programming approach</li>\n<li>Space optimization using rolling variables</li>\n<li>Handle edge cases for small arrays</li>\n</ul>",
      "solution_code": "class Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        if (cost == null || cost.length == 0) return 0;\n        if (cost.length <= 2) {\n            return Math.min(cost[0], cost[cost.length - 1]);\n        }\n        \n        // We can start from step 0 or step 1\n        int prev2 = cost[0];\n        int prev1 = cost[1];\n        \n        // Calculate min cost to reach each step\n        for (int i = 2; i < cost.length; i++) {\n            int current = cost[i] + Math.min(prev1, prev2);\n            prev2 = prev1;\n            prev1 = current;\n        }\n        \n        // We can reach the top from either of the last two steps\n        return Math.min(prev1, prev2);\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "cost": [10,15,20]
      },
      "output": 15
    },
    {
      "id": 2,
      "input": {
        "cost": [1,100,1,1,1,100,1,1,100,1]
      },
      "output": 6
    },
    {
      "id": 3,
      "input": {
        "cost": [1,2,3]
      },
      "output": 2
    },
    {
      "id": 4,
      "input": {
        "cost": [1,2,1,2,1,1,1]
      },
      "output": 4
    },
    {
      "id": 5,
      "input": {
        "cost": [0,0,0,1]
      },
      "output": 0
    },
    {
      "id": 6,
      "input": {
        "cost": [1,0,0,0]
      },
      "output": 0
    },
    {
      "id": 7,
      "input": {
        "cost": [5,10]
      },
      "output": 5
    },
    {
      "id": 8,
      "input": {
        "cost": [10,5]
      },
      "output": 5
    },
    {
      "id": 9,
      "input": {
        "cost": [1,2,3,4,5]
      },
      "output": 6
    },
    {
      "id": 10,
      "input": {
        "cost": [0,1,2,2]
      },
      "output": 2
    }
  ]
}