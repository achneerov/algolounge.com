{
  "filename": "three-integer-sum",
  "title": "3Sum",
  "keywords": [
    "3sum",
    "leetcode",
    "given",
    "integer",
    "array",
    "nums",
    "return",
    "all",
    "triplets",
    "where"
  ],
  "description": "<h2>3Sum</h2><p>Leetcode 15. 3Sum</p><p></p><p>Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` where `nums[i] + nums[j] + nums[k] == 0`, and the indices `i`, `j` and `k` are all distinct.</p><p></p><p>The output should *not* contain any duplicate triplets. You may return the output and the triplets in **any order**.</p><h3>Examples:</h3><ul><li>Input: nums = [-1,0,1,2,-1,-4]<br><br>Output: [[-1,-1,2],[-1,0,1]]<br>`nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.`\n`nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.`\n`nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.`\nThe distinct triplets are `[-1,0,1]` and `[-1,-1,2]`.</li><li>Input: nums = [0,1,1]<br><br>Output: []<br>The only possible triplet does not sum up to 0.</li><li>Input: nums = [0,0,0]<br><br>Output: [[0,0,0]]<br>The only possible triplet sums up to 0.</li></ul><h3>Constraints:</h3><ul><li> `3 <= nums.length <= 1000`</li><li> `-10^5 <= nums[i] <= 10^5`</li></ul>",
  "languages": {
    "python": {
      "template": "def solve3sum(nums):\n    ",
      "solution_text": "Three Sum using sorting and two pointers:\n\n**Algorithm:**\n1. Sort the array to enable two pointers technique\n2. Fix first element and use two pointers for remaining two\n3. Skip duplicates to avoid duplicate triplets\n4. Move pointers based on sum comparison with target\n\n**Time Complexity:** O(n²) - nested loops with two pointers\n**Space Complexity:** O(1) - excluding output array\n\n**Key Insights:**\n- Sorting enables duplicate skipping and two pointers\n- Fix one element, find pair with remaining two pointers\n- Careful duplicate handling prevents redundant results",
      "solution_code": "def threeSum(nums):\n    nums.sort()\n    result = []\n    n = len(nums)\n    \n    for i in range(n-2):\n        # Skip duplicates for first number\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        \n        left, right = i+1, n-1\n        \n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            if current_sum == 0:\n                result.append([nums[i], nums[left], nums[right]])\n                \n                # Skip duplicates\n                while left < right and nums[left] == nums[left+1]:\n                    left += 1\n                while left < right and nums[right] == nums[right-1]:\n                    right -= 1\n                \n                left += 1\n                right -= 1\n            elif current_sum < 0:\n                left += 1\n            else:\n                right -= 1\n    \n    return result"
    },
    "javascript": {
      "template": "function solve3sum(nums) {\n  \n}",
      "solution_text": "Three Sum using sorting and two pointers:\n\n**Algorithm:**\n1. Sort the array to enable two pointers technique\n2. Fix first element and use two pointers for remaining two\n3. Skip duplicates to avoid duplicate triplets\n4. Move pointers based on sum comparison with target\n\n**Time Complexity:** O(n²) - nested loops with two pointers\n**Space Complexity:** O(1) - excluding output array\n\n**Key Insights:**\n- Sorting enables duplicate skipping and two pointers\n- Fix one element, find pair with remaining two pointers\n- Careful duplicate handling prevents redundant results",
      "solution_code": "function threeSum(nums) {\n    nums.sort((a, b) => a - b);\n    const result = [];\n    const n = nums.length;\n    \n    for (let i = 0; i < n-2; i++) {\n        // Skip duplicates for first number\n        if (i > 0 && nums[i] === nums[i-1]) continue;\n        \n        let left = i+1, right = n-1;\n        \n        while (left < right) {\n            const currentSum = nums[i] + nums[left] + nums[right];\n            \n            if (currentSum === 0) {\n                result.push([nums[i], nums[left], nums[right]]);\n                \n                // Skip duplicates\n                while (left < right && nums[left] === nums[left+1]) left++;\n                while (left < right && nums[right] === nums[right-1]) right--;\n                \n                left++;\n                right--;\n            } else if (currentSum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    \n    return result;\n}"
    },
    "typescript": {
      "template": "function solve3sum(nums: number[]): number[] {\n  \n}",
      "solution_text": "Three Sum using sorting and two pointers:\n\n**Algorithm:**\n1. Sort the array to enable two pointers technique\n2. Fix first element and use two pointers for remaining two\n3. Skip duplicates to avoid duplicate triplets\n4. Move pointers based on sum comparison with target\n\n**Time Complexity:** O(n²) - nested loops with two pointers\n**Space Complexity:** O(1) - excluding output array\n\n**Key Insights:**\n- Sorting enables duplicate skipping and two pointers\n- Fix one element, find pair with remaining two pointers\n- Careful duplicate handling prevents redundant results",
      "solution_code": "function threeSum(nums: number[]): number[][] {\n    nums.sort((a, b) => a - b);\n    const result: number[][] = [];\n    const n = nums.length;\n    \n    for (let i = 0; i < n-2; i++) {\n        // Skip duplicates for first number\n        if (i > 0 && nums[i] === nums[i-1]) continue;\n        \n        let left = i+1, right = n-1;\n        \n        while (left < right) {\n            const currentSum = nums[i] + nums[left] + nums[right];\n            \n            if (currentSum === 0) {\n                result.push([nums[i], nums[left], nums[right]]);\n                \n                // Skip duplicates\n                while (left < right && nums[left] === nums[left+1]) left++;\n                while (left < right && nums[right] === nums[right-1]) right--;\n                \n                left++;\n                right--;\n            } else if (currentSum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    \n    return result;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int[] solve3sum(int[] nums) {\n        \n    }\n}",
      "solution_text": "Three Sum using sorting and two pointers:\n\n**Algorithm:**\n1. Sort the array to enable two pointers technique\n2. Fix first element and use two pointers for remaining two\n3. Skip duplicates to avoid duplicate triplets\n4. Move pointers based on sum comparison with target\n\n**Time Complexity:** O(n²) - nested loops with two pointers\n**Space Complexity:** O(1) - excluding output array\n\n**Key Insights:**\n- Sorting enables duplicate skipping and two pointers\n- Fix one element, find pair with remaining two pointers\n- Careful duplicate handling prevents redundant results",
      "solution_code": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> result = new ArrayList<>();\n        int n = nums.length;\n        \n        for (int i = 0; i < n-2; i++) {\n            // Skip duplicates for first number\n            if (i > 0 && nums[i] == nums[i-1]) continue;\n            \n            int left = i+1, right = n-1;\n            \n            while (left < right) {\n                int currentSum = nums[i] + nums[left] + nums[right];\n                \n                if (currentSum == 0) {\n                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));\n                    \n                    // Skip duplicates\n                    while (left < right && nums[left] == nums[left+1]) left++;\n                    while (left < right && nums[right] == nums[right-1]) right--;\n                    \n                    left++;\n                    right--;\n                } else if (currentSum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        \n        return result;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "nums": [
          -1,
          0,
          1,
          2,
          -1,
          -4
        ]
      },
      "output": [
        [
          -1,
          -1,
          2
        ],
        [
          -1,
          0,
          1
        ]
      ]
    },
    {
      "id": 2,
      "input": {
        "nums": [
          0,
          1,
          1
        ]
      },
      "output": []
    },
    {
      "id": 3,
      "input": {
        "nums": [
          0,
          0,
          0
        ]
      },
      "output": [
        [
          0,
          0,
          0
        ]
      ]
    }
  ]
}