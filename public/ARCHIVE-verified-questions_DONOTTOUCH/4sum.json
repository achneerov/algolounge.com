{
  "filename": "4sum",
  "title": "4Sum",
  "keywords": [
    "4sum",
    "leetcode",
    "given",
    "integer",
    "array",
    "nums",
    "size",
    "return",
    "all",
    "unique"
  ],
  "description": "<h2>4Sum</h2><p>Leetcode 18. 4Sum</p><p>You are given an integer array <code>nums</code> of size <code>n</code>, return an array of all the unique quadruplets <code>[nums[a], nums[b], nums[c], nums[d]]</code> such that:</p><ul><li><code>0 <= a, b, c, d < n</code></li><li><code>a, b, c,</code> and <code>d</code> are <strong>distinct</strong>.</li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>You may return the answer in <strong>any order</strong>.</p><p><strong>Note:</strong> <code>[1,0,3,2]</code> and <code>[3,0,1,2]</code> are considered as same quadruplets.</p><h3>Examples</h3><ul><li><strong>Input:</strong> nums = [3,2,3,-3,1,0], target = 3<br><strong>Output:</strong> [[-3,0,3,3],[-3,1,2,3]]</li><li><strong>Input:</strong> nums = [1,-1,1,-1,1,-1], target = 2<br><strong>Output:</strong> [[-1,1,1,1]]</li></ul><h3>Constraints</h3><ul><li><code>1 <= nums.length <= 200</code></li><li><code>-1,000,000,000 <= nums[i] <= 1,000,000,000</code></li><li><code>-1,000,000,000 <= target <= 1,000,000,000</code></li></ul>",
  "languages": {
    "python": {
      "template": "def solve4sum(nums, target):\n    ",
      "solution_text": "Efficient Multi-Sum solution using sorting and two-pointers:\n\n**Algorithm:**\n1. Sort the input array to enable two-pointers technique\n2. Use nested loops with early termination for efficiency\n3. Apply two-pointers to find remaining sum combinations\n4. Skip duplicates to ensure unique quadruplets/triplets\n\n**Time Complexity:** O(n³) for 4Sum, O(n²) for 3Sum\n**Space Complexity:** O(1) excluding output array\n\n**Key Insights:**\n- Sorting enables duplicate skipping and two-pointers\n- Early termination when current sum is too large/small\n- Careful duplicate handling prevents redundant results",
      "solution_code": "def solve4sum(nums, target):\n    if len(nums) < 4:\n        return []\n    \n    nums.sort()\n    result = []\n    n = len(nums)\n    \n    for i in range(n - 3):\n        # Skip duplicates for first number\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n            \n        # Early termination if minimum possible sum is too large\n        if nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target:\n            break\n            \n        # Early termination if maximum possible sum is too small\n        if nums[i] + nums[n - 1] + nums[n - 2] + nums[n - 3] < target:\n            continue\n        \n        for j in range(i + 1, n - 2):\n            # Skip duplicates for second number\n            if j > i + 1 and nums[j] == nums[j - 1]:\n                continue\n            \n            # Two pointers for remaining two numbers\n            left, right = j + 1, n - 1\n            \n            while left < right:\n                current_sum = nums[i] + nums[j] + nums[left] + nums[right]\n                \n                if current_sum == target:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    \n                    # Skip duplicates\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    \n                    left += 1\n                    right -= 1\n                elif current_sum < target:\n                    left += 1\n                else:\n                    right -= 1\n    \n    return result"
    },
    "javascript": {
      "template": "function solve4sum(nums, target) {\n  \n}",
      "solution_text": "Efficient Multi-Sum solution using sorting and two-pointers:\n\n**Algorithm:**\n1. Sort the input array to enable two-pointers technique\n2. Use nested loops with early termination for efficiency\n3. Apply two-pointers to find remaining sum combinations\n4. Skip duplicates to ensure unique quadruplets/triplets\n\n**Time Complexity:** O(n³) for 4Sum, O(n²) for 3Sum\n**Space Complexity:** O(1) excluding output array\n\n**Key Insights:**\n- Sorting enables duplicate skipping and two-pointers\n- Early termination when current sum is too large/small\n- Careful duplicate handling prevents redundant results",
      "solution_code": "function solve4sum(nums, target) {\n    if (nums.length < 4) return [];\n    \n    nums.sort((a, b) => a - b);\n    const result = [];\n    const n = nums.length;\n    \n    for (let i = 0; i < n - 3; i++) {\n        // Skip duplicates for first number\n        if (i > 0 && nums[i] === nums[i - 1]) continue;\n        \n        // Early termination optimizations\n        if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) break;\n        if (nums[i] + nums[n - 1] + nums[n - 2] + nums[n - 3] < target) continue;\n        \n        for (let j = i + 1; j < n - 2; j++) {\n            // Skip duplicates for second number\n            if (j > i + 1 && nums[j] === nums[j - 1]) continue;\n            \n            // Two pointers for remaining two numbers\n            let left = j + 1, right = n - 1;\n            \n            while (left < right) {\n                const currentSum = nums[i] + nums[j] + nums[left] + nums[right];\n                \n                if (currentSum === target) {\n                    result.push([nums[i], nums[j], nums[left], nums[right]]);\n                    \n                    // Skip duplicates\n                    while (left < right && nums[left] === nums[left + 1]) left++;\n                    while (left < right && nums[right] === nums[right - 1]) right--;\n                    \n                    left++;\n                    right--;\n                } else if (currentSum < target) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n    }\n    \n    return result;\n}"
    },
    "typescript": {
      "template": "function solve4sum(nums: number[], target: number): number[][] {\n  \n}",
      "solution_text": "Efficient Multi-Sum solution using sorting and two-pointers:\n\n**Algorithm:**\n1. Sort the input array to enable two-pointers technique\n2. Use nested loops with early termination for efficiency\n3. Apply two-pointers to find remaining sum combinations\n4. Skip duplicates to ensure unique quadruplets/triplets\n\n**Time Complexity:** O(n³) for 4Sum, O(n²) for 3Sum\n**Space Complexity:** O(1) excluding output array\n\n**Key Insights:**\n- Sorting enables duplicate skipping and two-pointers\n- Early termination when current sum is too large/small\n- Careful duplicate handling prevents redundant results",
      "solution_code": "function solve4sum(nums: number[], target: number): number[][] {\n    if (nums.length < 4) return [];\n    \n    nums.sort((a, b) => a - b);\n    const result: number[][] = [];\n    const n = nums.length;\n    \n    for (let i = 0; i < n - 3; i++) {\n        // Skip duplicates for first number\n        if (i > 0 && nums[i] === nums[i - 1]) continue;\n        \n        // Early termination optimizations\n        if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) break;\n        if (nums[i] + nums[n - 1] + nums[n - 2] + nums[n - 3] < target) continue;\n        \n        for (let j = i + 1; j < n - 2; j++) {\n            // Skip duplicates for second number\n            if (j > i + 1 && nums[j] === nums[j - 1]) continue;\n            \n            // Two pointers for remaining two numbers\n            let left = j + 1, right = n - 1;\n            \n            while (left < right) {\n                const currentSum = nums[i] + nums[j] + nums[left] + nums[right];\n                \n                if (currentSum === target) {\n                    result.push([nums[i], nums[j], nums[left], nums[right]]);\n                    \n                    // Skip duplicates\n                    while (left < right && nums[left] === nums[left + 1]) left++;\n                    while (left < right && nums[right] === nums[right - 1]) right--;\n                    \n                    left++;\n                    right--;\n                } else if (currentSum < target) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n    }\n    \n    return result;\n}"
    },
    "java": {
      "template": "class Solution {\n    public List<List<Integer>> solve4sum(int[] nums, int target) {\n        \n    }\n}",
      "solution_text": "Efficient Multi-Sum solution using sorting and two-pointers:\n\n**Algorithm:**\n1. Sort the input array to enable two-pointers technique\n2. Use nested loops with early termination for efficiency\n3. Apply two-pointers to find remaining sum combinations\n4. Skip duplicates to ensure unique quadruplets/triplets\n\n**Time Complexity:** O(n³) for 4Sum, O(n²) for 3Sum\n**Space Complexity:** O(1) excluding output array\n\n**Key Insights:**\n- Sorting enables duplicate skipping and two-pointers\n- Early termination when current sum is too large/small\n- Careful duplicate handling prevents redundant results",
      "solution_code": "class Solution {\n    public List<List<Integer>> solve4sum(int[] nums, int target) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (nums.length < 4) return result;\n        \n        Arrays.sort(nums);\n        int n = nums.length;\n        \n        for (int i = 0; i < n - 3; i++) {\n            // Skip duplicates for first number\n            if (i > 0 && nums[i] == nums[i - 1]) continue;\n            \n            // Early termination optimizations\n            if ((long)nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) break;\n            if ((long)nums[i] + nums[n - 1] + nums[n - 2] + nums[n - 3] < target) continue;\n            \n            for (int j = i + 1; j < n - 2; j++) {\n                // Skip duplicates for second number\n                if (j > i + 1 && nums[j] == nums[j - 1]) continue;\n                \n                // Two pointers for remaining two numbers\n                int left = j + 1, right = n - 1;\n                \n                while (left < right) {\n                    long currentSum = (long)nums[i] + nums[j] + nums[left] + nums[right];\n                    \n                    if (currentSum == target) {\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n                        \n                        // Skip duplicates\n                        while (left < right && nums[left] == nums[left + 1]) left++;\n                        while (left < right && nums[right] == nums[right - 1]) right--;\n                        \n                        left++;\n                        right--;\n                    } else if (currentSum < target) {\n                        left++;\n                    } else {\n                        right--;\n                    }\n                }\n            }\n        }\n        \n        return result;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "nums": [
          3,
          2,
          3,
          -3,
          1,
          0
        ],
        "target": 3
      },
      "output": [
        [
          -3,
          0,
          3,
          3
        ],
        [
          -3,
          1,
          2,
          3
        ]
      ]
    },
    {
      "id": 2,
      "input": {
        "nums": [
          1,
          -1,
          1,
          -1,
          1,
          -1
        ],
        "target": 2
      },
      "output": [
        [
          -1,
          1,
          1,
          1
        ]
      ]
    },
    {
      "id": 3,
      "input": {
        "nums": [1, 0, -1, 0, -2, 2],
        "target": 0
      },
      "output": [
        [-2, -1, 1, 2],
        [-2, 0, 0, 2],
        [-1, 0, 0, 1]
      ]
    },
    {
      "id": 4,
      "input": {
        "nums": [2, 2, 2, 2, 2],
        "target": 8
      },
      "output": [
        [2, 2, 2, 2]
      ]
    },
    {
      "id": 5,
      "input": {
        "nums": [1, 2, 3, 4],
        "target": 10
      },
      "output": [
        [1, 2, 3, 4]
      ]
    },
    {
      "id": 6,
      "input": {
        "nums": [-3, -2, -1, 0, 0, 1, 2, 3],
        "target": 0
      },
      "output": [
        [-3, -2, 2, 3],
        [-3, -1, 1, 3],
        [-3, 0, 1, 2],
        [-2, -1, 0, 3],
        [-2, -1, 1, 2],
        [-2, 0, 0, 2],
        [-1, 0, 0, 1]
      ]
    },
    {
      "id": 7,
      "input": {
        "nums": [1, 1, 1, 1],
        "target": 4
      },
      "output": [
        [1, 1, 1, 1]
      ]
    },
    {
      "id": 8,
      "input": {
        "nums": [0],
        "target": 0
      },
      "output": []
    },
    {
      "id": 9,
      "input": {
        "nums": [1, -2, -5, -4, -3, 3, 3, 5],
        "target": -11
      },
      "output": [
        [-5, -4, -3, 1]
      ]
    },
    {
      "id": 10,
      "input": {
        "nums": [1000000000, 1000000000, 1000000000, 1000000000],
        "target": -294967268
      },
      "output": []
    }
  ]
}