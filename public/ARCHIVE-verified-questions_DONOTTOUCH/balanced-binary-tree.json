{
  "filename": "balanced-binary-tree",
  "title": "Balanced Binary Tree",
  "keywords": [
    "balanced",
    "binary",
    "tree",
    "leetcode",
    "110",
    "given",
    "return",
    "true",
    "height",
    "false"
  ],
  "description": "<h2>Balanced Binary Tree</h2><p>Given a binary tree, return <code>true</code> if it is <strong>height-balanced</strong> and <code>false</code> otherwise.</p><p>A <strong>height-balanced</strong> binary tree is defined as a binary tree in which the left and right subtrees of every node differ in height by no more than 1.</p><h3>Examples</h3><ul><li><strong>Example 1:</strong><br>Input: root = [3,9,20,null,null,15,7]<br>Output: true<br>Explanation: The tree is balanced as the height difference between left and right subtrees is at most 1 for all nodes.</li><li><strong>Example 2:</strong><br>Input: root = [1,2,2,3,3,null,null,4,4]<br>Output: false<br>Explanation: The tree is not balanced because the left subtree of the root has height 3 while the right subtree has height 1.</li><li><strong>Example 3:</strong><br>Input: root = []<br>Output: true<br>Explanation: An empty tree is considered balanced.</li></ul><h3>Constraints</h3><ul><li>The number of nodes in the tree is in the range <code>[0, 1000]</code>.</li><li><code>-1000 <= Node.val <= 1000</code></li></ul>",
  "languages": {
    "python": {
      "template": "def isBalanced(root):\n    ",
      "solution_text": "Check if binary tree is height-balanced:\n\n**Algorithm:**\n1. Use helper function to compute height and check balance\n2. For each node, check if left and right subtrees are balanced\n3. Check if height difference is at most 1\n4. Return -1 if unbalanced, otherwise return height\n\n**Time Complexity:** O(n) - visit each node once\n**Space Complexity:** O(h) - recursion stack depth\n\n**Key Insights:**\n- Combine height calculation with balance checking\n- Early termination when imbalance is detected\n- Bottom-up approach for efficiency",
      "solution_code": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef isBalanced(root):\n    def check_balance(node):\n        # Base case: empty tree is balanced with height 0\n        if not node:\n            return 0\n        \n        # Check left subtree\n        left_height = check_balance(node.left)\n        if left_height == -1:\n            return -1  # Left subtree is unbalanced\n        \n        # Check right subtree\n        right_height = check_balance(node.right)\n        if right_height == -1:\n            return -1  # Right subtree is unbalanced\n        \n        # Check balance condition\n        if abs(left_height - right_height) > 1:\n            return -1  # Current node is unbalanced\n        \n        # Return height of current subtree\n        return max(left_height, right_height) + 1\n    \n    return check_balance(root) != -1"
    },
    "javascript": {
      "template": "function isBalanced(root) {\n  \n}",
      "solution_text": "Check if binary tree is height-balanced:\n\n**Algorithm:**\n1. Use helper function to compute height and check balance\n2. For each node, check if left and right subtrees are balanced\n3. Check if height difference is at most 1\n4. Return -1 if unbalanced, otherwise return height\n\n**Time Complexity:** O(n) - visit each node once\n**Space Complexity:** O(h) - recursion stack depth\n\n**Key Insights:**\n- Combine height calculation with balance checking\n- Early termination when imbalance is detected\n- Bottom-up approach for efficiency",
      "solution_code": "// Definition for a binary tree node.\nfunction TreeNode(val, left, right) {\n    this.val = (val===undefined ? 0 : val);\n    this.left = (left===undefined ? null : left);\n    this.right = (right===undefined ? null : right);\n}\n\nfunction isBalanced(root) {\n    function checkBalance(node) {\n        // Base case: empty tree is balanced with height 0\n        if (!node) return 0;\n        \n        // Check left subtree\n        const leftHeight = checkBalance(node.left);\n        if (leftHeight === -1) return -1; // Left subtree is unbalanced\n        \n        // Check right subtree\n        const rightHeight = checkBalance(node.right);\n        if (rightHeight === -1) return -1; // Right subtree is unbalanced\n        \n        // Check balance condition\n        if (Math.abs(leftHeight - rightHeight) > 1) {\n            return -1; // Current node is unbalanced\n        }\n        \n        // Return height of current subtree\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n    \n    return checkBalance(root) !== -1;\n}"
    },
    "typescript": {
      "template": "function isBalanced(root: TreeNode | null): boolean {\n  \n}",
      "solution_text": "Check if binary tree is height-balanced:\n\n**Algorithm:**\n1. Use helper function to compute height and check balance\n2. For each node, check if left and right subtrees are balanced\n3. Check if height difference is at most 1\n4. Return -1 if unbalanced, otherwise return height\n\n**Time Complexity:** O(n) - visit each node once\n**Space Complexity:** O(h) - recursion stack depth\n\n**Key Insights:**\n- Combine height calculation with balance checking\n- Early termination when imbalance is detected\n- Bottom-up approach for efficiency",
      "solution_code": "// Definition for a binary tree node.\nclass TreeNode {\n    val: number;\n    left: TreeNode | null;\n    right: TreeNode | null;\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = (val===undefined ? 0 : val);\n        this.left = (left===undefined ? null : left);\n        this.right = (right===undefined ? null : right);\n    }\n}\n\nfunction isBalanced(root: TreeNode | null): boolean {\n    function checkBalance(node: TreeNode | null): number {\n        // Base case: empty tree is balanced with height 0\n        if (!node) return 0;\n        \n        // Check left subtree\n        const leftHeight = checkBalance(node.left);\n        if (leftHeight === -1) return -1; // Left subtree is unbalanced\n        \n        // Check right subtree\n        const rightHeight = checkBalance(node.right);\n        if (rightHeight === -1) return -1; // Right subtree is unbalanced\n        \n        // Check balance condition\n        if (Math.abs(leftHeight - rightHeight) > 1) {\n            return -1; // Current node is unbalanced\n        }\n        \n        // Return height of current subtree\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n    \n    return checkBalance(root) !== -1;\n}"
    },
    "java": {
      "template": "class Solution {\n    public boolean isBalanced(TreeNode root) {\n        \n    }\n}",
      "solution_text": "Check if binary tree is height-balanced:\n\n**Algorithm:**\n1. Use helper function to compute height and check balance\n2. For each node, check if left and right subtrees are balanced\n3. Check if height difference is at most 1\n4. Return -1 if unbalanced, otherwise return height\n\n**Time Complexity:** O(n) - visit each node once\n**Space Complexity:** O(h) - recursion stack depth\n\n**Key Insights:**\n- Combine height calculation with balance checking\n- Early termination when imbalance is detected\n- Bottom-up approach for efficiency",
      "solution_code": "// Definition for a binary tree node.\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        return checkBalance(root) != -1;\n    }\n    \n    private int checkBalance(TreeNode node) {\n        // Base case: empty tree is balanced with height 0\n        if (node == null) return 0;\n        \n        // Check left subtree\n        int leftHeight = checkBalance(node.left);\n        if (leftHeight == -1) return -1; // Left subtree is unbalanced\n        \n        // Check right subtree\n        int rightHeight = checkBalance(node.right);\n        if (rightHeight == -1) return -1; // Right subtree is unbalanced\n        \n        // Check balance condition\n        if (Math.abs(leftHeight - rightHeight) > 1) {\n            return -1; // Current node is unbalanced\n        }\n        \n        // Return height of current subtree\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "root": []
      },
      "output": true
    },
    {
      "id": 2,
      "input": {
        "root": [1]
      },
      "output": true
    },
    {
      "id": 3,
      "input": {
        "root": [3, 9, 20, null, null, 15, 7]
      },
      "output": true
    },
    {
      "id": 4,
      "input": {
        "root": [1, 2, 2, 3, 3, null, null, 4, 4]
      },
      "output": false
    },
    {
      "id": 5,
      "input": {
        "root": [1, 2, 3]
      },
      "output": true
    },
    {
      "id": 6,
      "input": {
        "root": [1, 2, null, 3, null, 4]
      },
      "output": false
    },
    {
      "id": 7,
      "input": {
        "root": [1, null, 2, null, 3]
      },
      "output": false
    },
    {
      "id": 8,
      "input": {
        "root": [1, 2, 3, 4, 5, 6, null, 8]
      },
      "output": true
    },
    {
      "id": 9,
      "input": {
        "root": [5, 4, 8, 11, null, 13, 4, 7, 2, null, null, null, 1]
      },
      "output": true
    },
    {
      "id": 10,
      "input": {
        "root": [1, 2, 2, 3, null, null, 3, 4, null, null, 4]
      },
      "output": false
    },
    {
      "id": 11,
      "input": {
        "root": [10, 5, 15, null, null, 6, 20]
      },
      "output": true
    },
    {
      "id": 12,
      "input": {
        "root": [1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, null, null, 5, 5]
      },
      "output": false
    }
  ]
}