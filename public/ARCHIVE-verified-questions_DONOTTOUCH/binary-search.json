{
  "filename": "binary-search",
  "title": "Binary Search",
  "keywords": [
    "binary",
    "search",
    "leetcode",
    "704",
    "given",
    "array",
    "distinct",
    "integers",
    "nums",
    "sorted"
  ],
  "description": "<h2>Binary Search</h2><p>Leetcode 704. Binary Search</p><p>You are given an array of <strong>distinct</strong> integers <code>nums</code>, sorted in ascending order, and an integer <code>target</code>.</p><p>Implement a function to search for <code>target</code> within <code>nums</code>. If it exists, then return its index, otherwise, return <code>-1</code>.</p><p>Your solution must run in O(log n) time.</p><h3>Examples</h3><ul><li>Input: <code>nums = [-1,0,2,4,6,8]</code>, <code>target = 4</code><br>Output: <code>3</code></li><li>Input: <code>nums = [-1,0,2,4,6,8]</code>, <code>target = 3</code><br>Output: <code>-1</code></li></ul><h3>Constraints</h3><ul><li><code>1 <= nums.length <= 10000</code></li><li><code>-10000 < nums[i], target < 10000</code></li><li>All the integers in <code>nums</code> are <strong>unique</strong></li></ul>",
  "languages": {
    "python": {
      "template": "def binarySearch(nums, target):\n    ",
      "solution_text": "Classic Binary Search implementation:\n\n**Algorithm:**\n1. Initialize left and right pointers to array bounds\n2. While left <= right, calculate middle index\n3. Compare middle element with target\n4. Adjust search space based on comparison\n\n**Time Complexity:** O(log n) - halves search space each iteration\n**Space Complexity:** O(1) - constant extra space\n\n**Key Insights:**\n- Requires sorted input array\n- Avoids integer overflow with left + (right - left) // 2\n- Returns -1 if target not found",
      "solution_code": "def binarySearch(nums, target):\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        # Avoid integer overflow\n        mid = left + (right - left) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1"
    },
    "javascript": {
      "template": "function binarySearch(nums, target) {\n  \n}",
      "solution_text": "Classic Binary Search implementation:\n\n**Algorithm:**\n1. Initialize left and right pointers to array bounds\n2. While left <= right, calculate middle index\n3. Compare middle element with target\n4. Adjust search space based on comparison\n\n**Time Complexity:** O(log n) - halves search space each iteration\n**Space Complexity:** O(1) - constant extra space\n\n**Key Insights:**\n- Requires sorted input array\n- Avoids integer overflow with left + (right - left) // 2\n- Returns -1 if target not found",
      "solution_code": "function binarySearch(nums, target) {\n    let left = 0, right = nums.length - 1;\n    \n    while (left <= right) {\n        // Avoid integer overflow\n        const mid = left + Math.floor((right - left) / 2);\n        \n        if (nums[mid] === target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return -1;\n}"
    },
    "typescript": {
      "template": "function binarySearch(nums: number[], target: number): number {\n  \n}",
      "solution_text": "Classic Binary Search implementation:\n\n**Algorithm:**\n1. Initialize left and right pointers to array bounds\n2. While left <= right, calculate middle index\n3. Compare middle element with target\n4. Adjust search space based on comparison\n\n**Time Complexity:** O(log n) - halves search space each iteration\n**Space Complexity:** O(1) - constant extra space\n\n**Key Insights:**\n- Requires sorted input array\n- Avoids integer overflow with left + (right - left) // 2\n- Returns -1 if target not found",
      "solution_code": "function binarySearch(nums: number[], target: number): number {\n    let left = 0, right = nums.length - 1;\n    \n    while (left <= right) {\n        // Avoid integer overflow\n        const mid = left + Math.floor((right - left) / 2);\n        \n        if (nums[mid] === target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return -1;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int binarySearch(int[] nums, int target) {\n        \n    }\n}",
      "solution_text": "Classic Binary Search implementation:\n\n**Algorithm:**\n1. Initialize left and right pointers to array bounds\n2. While left <= right, calculate middle index\n3. Compare middle element with target\n4. Adjust search space based on comparison\n\n**Time Complexity:** O(log n) - halves search space each iteration\n**Space Complexity:** O(1) - constant extra space\n\n**Key Insights:**\n- Requires sorted input array\n- Avoids integer overflow with left + (right - left) // 2\n- Returns -1 if target not found",
      "solution_code": "class Solution {\n    public int binarySearch(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        \n        while (left <= right) {\n            // Avoid integer overflow\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return -1;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "nums": [
          -1,
          0,
          2,
          4,
          6,
          8
        ],
        "target": 4
      },
      "output": 3
    },
    {
      "id": 2,
      "input": {
        "nums": [
          -1,
          0,
          2,
          4,
          6,
          8
        ],
        "target": 3
      },
      "output": -1
    },
    {
      "id": 3,
      "input": {
        "nums": [5],
        "target": 5
      },
      "output": 0
    },
    {
      "id": 4,
      "input": {
        "nums": [5],
        "target": 3
      },
      "output": -1
    },
    {
      "id": 5,
      "input": {
        "nums": [1, 3, 5, 7, 9],
        "target": 1
      },
      "output": 0
    },
    {
      "id": 6,
      "input": {
        "nums": [1, 3, 5, 7, 9],
        "target": 9
      },
      "output": 4
    },
    {
      "id": 7,
      "input": {
        "nums": [1, 3, 5, 7, 9],
        "target": 5
      },
      "output": 2
    },
    {
      "id": 8,
      "input": {
        "nums": [2, 4, 6, 8, 10, 12, 14, 16],
        "target": 2
      },
      "output": 0
    },
    {
      "id": 9,
      "input": {
        "nums": [2, 4, 6, 8, 10, 12, 14, 16],
        "target": 16
      },
      "output": 7
    },
    {
      "id": 10,
      "input": {
        "nums": [2, 4, 6, 8, 10, 12, 14, 16],
        "target": 11
      },
      "output": -1
    },
    {
      "id": 11,
      "input": {
        "nums": [-10, -5, 0, 3, 7],
        "target": -5
      },
      "output": 1
    },
    {
      "id": 12,
      "input": {
        "nums": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
        "target": 0
      },
      "output": -1
    }
  ]
}