{
  "filename": "binary-tree-diameter",
  "title": "Diameter of Binary Tree",
  "keywords": [
    "diameter",
    "binary",
    "tree",
    "leetcode",
    "543",
    "defined",
    "length",
    "longest",
    "path",
    "between"
  ],
  "description": "<h2>Diameter of Binary Tree</h2><p>LeetCode 543. Diameter of Binary Tree</p><p>The <strong>diameter</strong> of a binary tree is defined as the <strong>length</strong> of the longest path between <em>any two nodes within the tree</em>. The path does not necessarily have to pass through the root.</p><p>The <strong>length</strong> of a path between two nodes in a binary tree is the number of edges between the nodes. Note that the path cannot include the same node twice.</p><p>Given the root of a binary tree <code>root</code>, return the <strong>diameter</strong> of the tree.</p><h3>Examples</h3><ul><li><strong>Example 1:</strong><br>Input: <code>root = [1,2,3]</code><br>Output: <code>2</code><br>Explanation: The longest path is [2,1,3] with length 2.</li><li><strong>Example 2:</strong><br>Input: <code>root = [1,2]</code><br>Output: <code>1</code><br>Explanation: The longest path is [2,1] with length 1.</li></ul><h3>Constraints</h3><ul><li><code>1 <= number of nodes in the tree <= 100</code></li><li><code>-100 <= Node.val <= 100</code></li></ul>",
  "languages": {
    "python": {
      "template": "def diameterOfBinaryTree(root):\n    ",
      "solution_text": "Find diameter of binary tree (longest path between any two nodes):\n\n**Algorithm:**\n1. Use DFS to calculate depth of each subtree\n2. For each node, diameter through it = left_depth + right_depth\n3. Track maximum diameter seen across all nodes\n4. Return depth + 1 for parent nodes\n\n**Time Complexity:** O(n) - visit each node once\n**Space Complexity:** O(h) - recursion stack depth\n\n**Key Insights:**\n- Diameter may or may not pass through root\n- Combine depth calculation with diameter tracking\n- Path length is number of edges, not nodes",
      "solution_code": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef diameterOfBinaryTree(root):\n    max_diameter = 0\n    \n    def depth(node):\n        nonlocal max_diameter\n        \n        if not node:\n            return 0\n        \n        # Get depth of left and right subtrees\n        left_depth = depth(node.left)\n        right_depth = depth(node.right)\n        \n        # Update maximum diameter (path through current node)\n        current_diameter = left_depth + right_depth\n        max_diameter = max(max_diameter, current_diameter)\n        \n        # Return depth of current subtree\n        return max(left_depth, right_depth) + 1\n    \n    depth(root)\n    return max_diameter"
    },
    "javascript": {
      "template": "function diameterOfBinaryTree(root) {\n  \n}",
      "solution_text": "Find diameter of binary tree (longest path between any two nodes):\n\n**Algorithm:**\n1. Use DFS to calculate depth of each subtree\n2. For each node, diameter through it = left_depth + right_depth\n3. Track maximum diameter seen across all nodes\n4. Return depth + 1 for parent nodes\n\n**Time Complexity:** O(n) - visit each node once\n**Space Complexity:** O(h) - recursion stack depth\n\n**Key Insights:**\n- Diameter may or may not pass through root\n- Combine depth calculation with diameter tracking\n- Path length is number of edges, not nodes",
      "solution_code": "// Definition for a binary tree node.\nfunction TreeNode(val, left, right) {\n    this.val = (val===undefined ? 0 : val);\n    this.left = (left===undefined ? null : left);\n    this.right = (right===undefined ? null : right);\n}\n\nfunction diameterOfBinaryTree(root) {\n    let maxDiameter = 0;\n    \n    function depth(node) {\n        if (!node) return 0;\n        \n        // Get depth of left and right subtrees\n        const leftDepth = depth(node.left);\n        const rightDepth = depth(node.right);\n        \n        // Update maximum diameter (path through current node)\n        const currentDiameter = leftDepth + rightDepth;\n        maxDiameter = Math.max(maxDiameter, currentDiameter);\n        \n        // Return depth of current subtree\n        return Math.max(leftDepth, rightDepth) + 1;\n    }\n    \n    depth(root);\n    return maxDiameter;\n}"
    },
    "typescript": {
      "template": "function diameterOfBinaryTree(root: TreeNode | null): number {\n  \n}",
      "solution_text": "Find diameter of binary tree (longest path between any two nodes):\n\n**Algorithm:**\n1. Use DFS to calculate depth of each subtree\n2. For each node, diameter through it = left_depth + right_depth\n3. Track maximum diameter seen across all nodes\n4. Return depth + 1 for parent nodes\n\n**Time Complexity:** O(n) - visit each node once\n**Space Complexity:** O(h) - recursion stack depth\n\n**Key Insights:**\n- Diameter may or may not pass through root\n- Combine depth calculation with diameter tracking\n- Path length is number of edges, not nodes",
      "solution_code": "// Definition for a binary tree node.\nclass TreeNode {\n    val: number;\n    left: TreeNode | null;\n    right: TreeNode | null;\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = (val===undefined ? 0 : val);\n        this.left = (left===undefined ? null : left);\n        this.right = (right===undefined ? null : right);\n    }\n}\n\nfunction diameterOfBinaryTree(root: TreeNode | null): number {\n    let maxDiameter = 0;\n    \n    function depth(node: TreeNode | null): number {\n        if (!node) return 0;\n        \n        // Get depth of left and right subtrees\n        const leftDepth = depth(node.left);\n        const rightDepth = depth(node.right);\n        \n        // Update maximum diameter (path through current node)\n        const currentDiameter = leftDepth + rightDepth;\n        maxDiameter = Math.max(maxDiameter, currentDiameter);\n        \n        // Return depth of current subtree\n        return Math.max(leftDepth, rightDepth) + 1;\n    }\n    \n    depth(root);\n    return maxDiameter;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int diameterOfBinaryTree(TreeNode root) {\n        \n    }\n}",
      "solution_text": "Find diameter of binary tree (longest path between any two nodes):\n\n**Algorithm:**\n1. Use DFS to calculate depth of each subtree\n2. For each node, diameter through it = left_depth + right_depth\n3. Track maximum diameter seen across all nodes\n4. Return depth + 1 for parent nodes\n\n**Time Complexity:** O(n) - visit each node once\n**Space Complexity:** O(h) - recursion stack depth\n\n**Key Insights:**\n- Diameter may or may not pass through root\n- Combine depth calculation with diameter tracking\n- Path length is number of edges, not nodes",
      "solution_code": "// Definition for a binary tree node.\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    private int maxDiameter = 0;\n    \n    public int diameterOfBinaryTree(TreeNode root) {\n        maxDiameter = 0;\n        depth(root);\n        return maxDiameter;\n    }\n    \n    private int depth(TreeNode node) {\n        if (node == null) return 0;\n        \n        // Get depth of left and right subtrees\n        int leftDepth = depth(node.left);\n        int rightDepth = depth(node.right);\n        \n        // Update maximum diameter (path through current node)\n        int currentDiameter = leftDepth + rightDepth;\n        maxDiameter = Math.max(maxDiameter, currentDiameter);\n        \n        // Return depth of current subtree\n        return Math.max(leftDepth, rightDepth) + 1;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "root": [1, 2, 3]
      },
      "output": 2
    },
    {
      "id": 2,
      "input": {
        "root": [1, 2]
      },
      "output": 1
    },
    {
      "id": 3,
      "input": {
        "root": [1]
      },
      "output": 0
    },
    {
      "id": 4,
      "input": {
        "root": [1, 2, 3, 4, 5]
      },
      "output": 3
    },
    {
      "id": 5,
      "input": {
        "root": [1, 2, null, 4, null, 5]
      },
      "output": 3
    },
    {
      "id": 6,
      "input": {
        "root": [1, null, 2, null, 3, null, 4]
      },
      "output": 3
    },
    {
      "id": 7,
      "input": {
        "root": [1, 2, 3, 4, 5, 6, 7]
      },
      "output": 4
    },
    {
      "id": 8,
      "input": {
        "root": [-10, 9, 20, null, null, 15, 7]
      },
      "output": 3
    },
    {
      "id": 9,
      "input": {
        "root": [1, 2, 3, 4, 5, null, null, 6, 7]
      },
      "output": 4
    },
    {
      "id": 10,
      "input": {
        "root": [4, -7, -3, null, null, -9, -3, 9, -7, -4, null, 6, null, -6, -6, null, null, 0, 6, 5, null, 9, null, null, -1, -4, null, null, null, -2]
      },
      "output": 8
    }
  ]
}