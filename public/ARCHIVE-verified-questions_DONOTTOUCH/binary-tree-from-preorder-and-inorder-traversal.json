{
  "filename": "binary-tree-from-preorder-and-inorder-traversal",
  "title": "Construct Binary Tree from Preorder and Inorder Traversal",
  "keywords": [
    "construct",
    "binary",
    "tree",
    "preorder",
    "inorder",
    "traversal",
    "leetcode",
    "105",
    "given",
    "two"
  ],
  "description": "<h2>Construct Binary Tree from Preorder and Inorder Traversal</h2><p>Leetcode 105. Construct Binary Tree From Preorder And Inorder Traversal</p><p></p><p>You are given two integer arrays `preorder` and `inorder`.</p><p>        </p><p>* `preorder` is the preorder traversal of a binary tree</p><p>* `inorder` is the inorder traversal of the same tree</p><p>* Both arrays are of the same size and consist of unique values.</p><p></p><p>Rebuild the binary tree from the preorder and inorder traversals and return its root.</p><h3>Examples:</h3><ul><li>Input: preorder = [1], inorder = [1]<br><br>Output: [1]</li></ul><h3>Constraints:</h3><ul><li> `1 <= inorder.length <= 1000`.</li><li> `inorder.length == preorder.length`</li><li> `-1000 <= preorder[i], inorder[i] <= 1000`</li></ul>",
  "languages": {
    "python": {
      "template": "def constructBinaryTreeFromPreorderAndInorderTraversal(preorder, inorder):\n    ",
      "solution_text": "Construct Binary Tree from Preorder and Inorder Traversal:\n\n**Algorithm:**\n1. The first element in preorder is always the root\n2. Find root position in inorder array to determine left/right subtrees\n3. Recursively build left subtree using left portion of both arrays\n4. Recursively build right subtree using right portion of both arrays\n\n**Time Complexity:** O(n) - process each node once\n**Space Complexity:** O(n) - for hashmap and recursion stack\n\n**Key Insights:**\n- Preorder: Root -> Left -> Right\n- Inorder: Left -> Root -> Right\n- Use hashmap for O(1) root lookups in inorder array",
      "solution_code": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef constructBinaryTreeFromPreorderAndInorderTraversal(preorder, inorder):\n    if not preorder or not inorder:\n        return None\n    \n    # Create hashmap for O(1) lookups in inorder array\n    inorder_map = {val: i for i, val in enumerate(inorder)}\n    \n    def build(pre_start, pre_end, in_start, in_end):\n        if pre_start > pre_end:\n            return None\n        \n        # Root is always first element in preorder range\n        root_val = preorder[pre_start]\n        root = TreeNode(root_val)\n        \n        # Find root position in inorder array\n        root_idx = inorder_map[root_val]\n        left_size = root_idx - in_start\n        \n        # Build left and right subtrees\n        root.left = build(pre_start + 1, pre_start + left_size, in_start, root_idx - 1)\n        root.right = build(pre_start + left_size + 1, pre_end, root_idx + 1, in_end)\n        \n        return root\n    \n    return build(0, len(preorder) - 1, 0, len(inorder) - 1)"
    },
    "javascript": {
      "template": "function constructBinaryTreeFromPreorderAndInorderTraversal(preorder, inorder) {\n  \n}",
      "solution_text": "Construct Binary Tree from Preorder and Inorder Traversal:\n\n**Algorithm:**\n1. The first element in preorder is always the root\n2. Find root position in inorder array to determine left/right subtrees\n3. Recursively build left subtree using left portion of both arrays\n4. Recursively build right subtree using right portion of both arrays\n\n**Time Complexity:** O(n) - process each node once\n**Space Complexity:** O(n) - for hashmap and recursion stack\n\n**Key Insights:**\n- Preorder: Root -> Left -> Right\n- Inorder: Left -> Root -> Right\n- Use hashmap for O(1) root lookups in inorder array",
      "solution_code": "function constructBinaryTreeFromPreorderAndInorderTraversal(preorder, inorder) {\n    if (!preorder.length || !inorder.length) {\n        return null;\n    }\n    \n    // Create hashmap for O(1) lookups in inorder array\n    const inorderMap = new Map();\n    for (let i = 0; i < inorder.length; i++) {\n        inorderMap.set(inorder[i], i);\n    }\n    \n    function build(preStart, preEnd, inStart, inEnd) {\n        if (preStart > preEnd) {\n            return null;\n        }\n        \n        // Root is always first element in preorder range\n        const rootVal = preorder[preStart];\n        const root = new TreeNode(rootVal);\n        \n        // Find root position in inorder array\n        const rootIdx = inorderMap.get(rootVal);\n        const leftSize = rootIdx - inStart;\n        \n        // Build left and right subtrees\n        root.left = build(preStart + 1, preStart + leftSize, inStart, rootIdx - 1);\n        root.right = build(preStart + leftSize + 1, preEnd, rootIdx + 1, inEnd);\n        \n        return root;\n    }\n    \n    return build(0, preorder.length - 1, 0, inorder.length - 1);\n}"
    },
    "typescript": {
      "template": "function constructBinaryTreeFromPreorderAndInorderTraversal(preorder: number[], inorder: number[]): TreeNode | null {\n  \n}",
      "solution_text": "Construct Binary Tree from Preorder and Inorder Traversal:\n\n**Algorithm:**\n1. The first element in preorder is always the root\n2. Find root position in inorder array to determine left/right subtrees\n3. Recursively build left subtree using left portion of both arrays\n4. Recursively build right subtree using right portion of both arrays\n\n**Time Complexity:** O(n) - process each node once\n**Space Complexity:** O(n) - for hashmap and recursion stack\n\n**Key Insights:**\n- Preorder: Root -> Left -> Right\n- Inorder: Left -> Root -> Right\n- Use hashmap for O(1) root lookups in inorder array",
      "solution_code": "function constructBinaryTreeFromPreorderAndInorderTraversal(preorder: number[], inorder: number[]): TreeNode | null {\n    if (!preorder.length || !inorder.length) {\n        return null;\n    }\n    \n    // Create hashmap for O(1) lookups in inorder array\n    const inorderMap = new Map<number, number>();\n    for (let i = 0; i < inorder.length; i++) {\n        inorderMap.set(inorder[i], i);\n    }\n    \n    function build(preStart: number, preEnd: number, inStart: number, inEnd: number): TreeNode | null {\n        if (preStart > preEnd) {\n            return null;\n        }\n        \n        // Root is always first element in preorder range\n        const rootVal = preorder[preStart];\n        const root = new TreeNode(rootVal);\n        \n        // Find root position in inorder array\n        const rootIdx = inorderMap.get(rootVal)!;\n        const leftSize = rootIdx - inStart;\n        \n        // Build left and right subtrees\n        root.left = build(preStart + 1, preStart + leftSize, inStart, rootIdx - 1);\n        root.right = build(preStart + leftSize + 1, preEnd, rootIdx + 1, inEnd);\n        \n        return root;\n    }\n    \n    return build(0, preorder.length - 1, 0, inorder.length - 1);\n}"
    },
    "java": {
      "template": "class Solution {\n    public TreeNode constructBinaryTreeFromPreorderAndInorderTraversal(int[] preorder, int[] inorder) {\n        \n    }\n}",
      "solution_text": "Construct Binary Tree from Preorder and Inorder Traversal:\n\n**Algorithm:**\n1. The first element in preorder is always the root\n2. Find root position in inorder array to determine left/right subtrees\n3. Recursively build left subtree using left portion of both arrays\n4. Recursively build right subtree using right portion of both arrays\n\n**Time Complexity:** O(n) - process each node once\n**Space Complexity:** O(n) - for hashmap and recursion stack\n\n**Key Insights:**\n- Preorder: Root -> Left -> Right\n- Inorder: Left -> Root -> Right\n- Use hashmap for O(1) root lookups in inorder array",
      "solution_code": "class Solution {\n    private Map<Integer, Integer> inorderMap;\n    \n    public TreeNode constructBinaryTreeFromPreorderAndInorderTraversal(int[] preorder, int[] inorder) {\n        if (preorder.length == 0 || inorder.length == 0) {\n            return null;\n        }\n        \n        // Create hashmap for O(1) lookups in inorder array\n        inorderMap = new HashMap<>();\n        for (int i = 0; i < inorder.length; i++) {\n            inorderMap.put(inorder[i], i);\n        }\n        \n        return build(preorder, 0, preorder.length - 1, 0, inorder.length - 1);\n    }\n    \n    private TreeNode build(int[] preorder, int preStart, int preEnd, int inStart, int inEnd) {\n        if (preStart > preEnd) {\n            return null;\n        }\n        \n        // Root is always first element in preorder range\n        int rootVal = preorder[preStart];\n        TreeNode root = new TreeNode(rootVal);\n        \n        // Find root position in inorder array\n        int rootIdx = inorderMap.get(rootVal);\n        int leftSize = rootIdx - inStart;\n        \n        // Build left and right subtrees\n        root.left = build(preorder, preStart + 1, preStart + leftSize, inStart, rootIdx - 1);\n        root.right = build(preorder, preStart + leftSize + 1, preEnd, rootIdx + 1, inEnd);\n        \n        return root;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "preorder": [1],
        "inorder": [1]
      },
      "output": [1]
    },
    {
      "id": 2,
      "input": {
        "preorder": [3, 9, 20, 15, 7],
        "inorder": [9, 3, 15, 20, 7]
      },
      "output": [3, 9, null, null, 20, 15, 7]
    },
    {
      "id": 3,
      "input": {
        "preorder": [1, 2],
        "inorder": [2, 1]
      },
      "output": [1, 2]
    },
    {
      "id": 4,
      "input": {
        "preorder": [1, 2, 3],
        "inorder": [2, 1, 3]
      },
      "output": [1, 2, null, null, 3]
    },
    {
      "id": 5,
      "input": {
        "preorder": [1, 2, 4, 5, 3, 6],
        "inorder": [4, 2, 5, 1, 6, 3]
      },
      "output": [1, 2, 3, 4, 5, 6]
    },
    {
      "id": 6,
      "input": {
        "preorder": [3, 9, 20, 15, 7],
        "inorder": [9, 3, 15, 20, 7]
      },
      "output": [3, 9, 20, null, null, 15, 7]
    },
    {
      "id": 7,
      "input": {
        "preorder": [1, 2, 4, 3, 5, 6],
        "inorder": [4, 2, 1, 5, 3, 6]
      },
      "output": [1, 2, 3, 4, null, 5, 6]
    },
    {
      "id": 8,
      "input": {
        "preorder": [5, 3, 2, 4, 7, 6, 8],
        "inorder": [2, 3, 4, 5, 6, 7, 8]
      },
      "output": [5, 3, 7, 2, 4, 6, 8]
    },
    {
      "id": 9,
      "input": {
        "preorder": [10, 5, 1, 7, 15, 12, 20],
        "inorder": [1, 5, 7, 10, 12, 15, 20]
      },
      "output": [10, 5, 15, 1, 7, 12, 20]
    },
    {
      "id": 10,
      "input": {
        "preorder": [8, 4, 2, 1, 3, 6, 5, 7],
        "inorder": [1, 2, 3, 4, 5, 6, 7, 8]
      },
      "output": [8, 4, null, 2, 6, 1, 3, 5, 7]
    }
  ]
}