{
  "filename": "binary-tree-maximum-path-sum",
  "title": "Binary Tree Maximum Path Sum",
  "keywords": [
    "binary",
    "tree",
    "maximum",
    "path",
    "sum",
    "leetcode",
    "124",
    "given",
    "root",
    "non"
  ],
  "description": "<h2>Binary Tree Maximum Path Sum</h2><p>Leetcode 124. Binary Tree Maximum Path Sum</p><p></p><p>Given the `root` of a *non-empty* binary tree, return the maximum **path sum** of any *non-empty* path.</p><p></p><p>A **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes has an edge connecting them. A node can *not* appear in the sequence more than once. The path does *not* necessarily need to include the root.</p><p></p><p>The **path sum** of a path is the sum of the node's values in the path.</p><h3>Constraints:</h3><ul><li> `1 <= The number of nodes in the tree <= 1000`.</li><li> `-1000 <= Node.val <= 1000`</li></ul>",
  "languages": {
    "python": {
      "template": "def binaryTreeMaximumPathSum(root):\n    ",
      "solution_text": "<h3>Binary Tree Maximum Path Sum</h3><p><strong>Algorithm:</strong></p><ol><li>Use DFS to traverse the tree and track maximum path sum</li><li>For each node, calculate maximum path sum including that node</li><li>Update global maximum with path passing through current node</li><li>Return maximum single path sum for parent's calculation</li></ol><p><strong>Time Complexity:</strong> O(n) - visit each node once</p><p><strong>Space Complexity:</strong> O(h) - recursion stack depth</p><p><strong>Key Insights:</strong></p><ul><li>Path can start and end at any nodes</li><li>At each node, consider paths: left-node-right, node-right, node-left, or just node</li><li>Track global maximum separately from returned value</li></ul>",
      "solution_code": "def binaryTreeMaximumPathSum(root):\n    if not root:\n        return 0\n    \n    max_sum = float('-inf')\n    \n    def max_gain(node):\n        nonlocal max_sum\n        if not node:\n            return 0\n        \n        # Get maximum sum from left and right subtrees (ignore negative gains)\n        left_gain = max(max_gain(node.left), 0)\n        right_gain = max(max_gain(node.right), 0)\n        \n        # Current path sum including this node as highest point\n        current_max = node.val + left_gain + right_gain\n        \n        # Update global maximum\n        max_sum = max(max_sum, current_max)\n        \n        # Return maximum gain for parent (can only use one side)\n        return node.val + max(left_gain, right_gain)\n    \n    max_gain(root)\n    return max_sum"
    },
    "javascript": {
      "template": "function binaryTreeMaximumPathSum(root) {\n  \n}",
      "solution_text": "<h3>Binary Tree Maximum Path Sum</h3><p><strong>Algorithm:</strong></p><ol><li>Use DFS to traverse the tree and track maximum path sum</li><li>For each node, calculate maximum path sum including that node</li><li>Update global maximum with path passing through current node</li><li>Return maximum single path sum for parent's calculation</li></ol><p><strong>Time Complexity:</strong> O(n) - visit each node once</p><p><strong>Space Complexity:</strong> O(h) - recursion stack depth</p><p><strong>Key Insights:</strong></p><ul><li>Path can start and end at any nodes</li><li>At each node, consider paths: left-node-right, node-right, node-left, or just node</li><li>Track global maximum separately from returned value</li></ul>",
      "solution_code": "function binaryTreeMaximumPathSum(root) {\n    if (!root) return 0;\n    \n    let maxSum = -Infinity;\n    \n    function maxGain(node) {\n        if (!node) return 0;\n        \n        // Get maximum sum from left and right subtrees (ignore negative gains)\n        const leftGain = Math.max(maxGain(node.left), 0);\n        const rightGain = Math.max(maxGain(node.right), 0);\n        \n        // Current path sum including this node as highest point\n        const currentMax = node.val + leftGain + rightGain;\n        \n        // Update global maximum\n        maxSum = Math.max(maxSum, currentMax);\n        \n        // Return maximum gain for parent (can only use one side)\n        return node.val + Math.max(leftGain, rightGain);\n    }\n    \n    maxGain(root);\n    return maxSum;\n}"
    },
    "typescript": {
      "template": "function binaryTreeMaximumPathSum(root: TreeNode | null): number {\n  \n}",
      "solution_text": "<h3>Binary Tree Maximum Path Sum</h3><p><strong>Algorithm:</strong></p><ol><li>Use DFS to traverse the tree and track maximum path sum</li><li>For each node, calculate maximum path sum including that node</li><li>Update global maximum with path passing through current node</li><li>Return maximum single path sum for parent's calculation</li></ol><p><strong>Time Complexity:</strong> O(n) - visit each node once</p><p><strong>Space Complexity:</strong> O(h) - recursion stack depth</p><p><strong>Key Insights:</strong></p><ul><li>Path can start and end at any nodes</li><li>At each node, consider paths: left-node-right, node-right, node-left, or just node</li><li>Track global maximum separately from returned value</li></ul>",
      "solution_code": "function binaryTreeMaximumPathSum(root: TreeNode | null): number {\n    if (!root) return 0;\n    \n    let maxSum = -Infinity;\n    \n    function maxGain(node: TreeNode | null): number {\n        if (!node) return 0;\n        \n        // Get maximum sum from left and right subtrees (ignore negative gains)\n        const leftGain = Math.max(maxGain(node.left), 0);\n        const rightGain = Math.max(maxGain(node.right), 0);\n        \n        // Current path sum including this node as highest point\n        const currentMax = node.val + leftGain + rightGain;\n        \n        // Update global maximum\n        maxSum = Math.max(maxSum, currentMax);\n        \n        // Return maximum gain for parent (can only use one side)\n        return node.val + Math.max(leftGain, rightGain);\n    }\n    \n    maxGain(root);\n    return maxSum;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int binaryTreeMaximumPathSum(TreeNode root) {\n        \n    }\n}",
      "solution_text": "<h3>Binary Tree Maximum Path Sum</h3><p><strong>Algorithm:</strong></p><ol><li>Use DFS to traverse the tree and track maximum path sum</li><li>For each node, calculate maximum path sum including that node</li><li>Update global maximum with path passing through current node</li><li>Return maximum single path sum for parent's calculation</li></ol><p><strong>Time Complexity:</strong> O(n) - visit each node once</p><p><strong>Space Complexity:</strong> O(h) - recursion stack depth</p><p><strong>Key Insights:</strong></p><ul><li>Path can start and end at any nodes</li><li>At each node, consider paths: left-node-right, node-right, node-left, or just node</li><li>Track global maximum separately from returned value</li></ul>",
      "solution_code": "class Solution {\n    private int maxSum = Integer.MIN_VALUE;\n    \n    public int binaryTreeMaximumPathSum(TreeNode root) {\n        if (root == null) return 0;\n        \n        maxGain(root);\n        return maxSum;\n    }\n    \n    private int maxGain(TreeNode node) {\n        if (node == null) return 0;\n        \n        // Get maximum sum from left and right subtrees (ignore negative gains)\n        int leftGain = Math.max(maxGain(node.left), 0);\n        int rightGain = Math.max(maxGain(node.right), 0);\n        \n        // Current path sum including this node as highest point\n        int currentMax = node.val + leftGain + rightGain;\n        \n        // Update global maximum\n        maxSum = Math.max(maxSum, currentMax);\n        \n        // Return maximum gain for parent (can only use one side)\n        return node.val + Math.max(leftGain, rightGain);\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "root": [1, 2, 3]
      },
      "output": 6
    },
    {
      "id": 2,
      "input": {
        "root": [-10, 9, 20, null, null, 15, 7]
      },
      "output": 42
    },
    {
      "id": 3,
      "input": {
        "root": [-3]
      },
      "output": -3
    },
    {
      "id": 4,
      "input": {
        "root": [2, -1]
      },
      "output": 2
    },
    {
      "id": 5,
      "input": {
        "root": [1]
      },
      "output": 1
    },
    {
      "id": 6,
      "input": {
        "root": [5, 4, 8, 11, null, 13, 4, 7, 2, null, null, null, 1]
      },
      "output": 48
    },
    {
      "id": 7,
      "input": {
        "root": [1, 2, null, 3, null, 4, null, 5]
      },
      "output": 15
    },
    {
      "id": 8,
      "input": {
        "root": [-1, -2, -3]
      },
      "output": -1
    },
    {
      "id": 9,
      "input": {
        "root": [6, 2, 3, null, null, null, 1]
      },
      "output": 10
    },
    {
      "id": 10,
      "input": {
        "root": [9, 6, -3, null, null, -6, 2, null, null, 2, null, -6, -6, -6]
      },
      "output": 16
    }
  ]
}