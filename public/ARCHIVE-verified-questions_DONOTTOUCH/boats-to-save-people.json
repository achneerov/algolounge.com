{
  "filename": "boats-to-save-people",
  "title": "Boats to Save People",
  "keywords": [
    "boats",
    "save",
    "people",
    "leetcode",
    "881",
    "given",
    "integer",
    "array",
    "where",
    "weight"
  ],
  "description": "<h2>Boats to Save People</h2><p>You are given an integer array <code>people</code> where <code>people[i]</code> is the weight of the <code>i-th</code> person, and an infinite number of boats where each boat can carry a maximum weight of <code>limit</code>. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most <code>limit</code>.</p><p>Return the minimum number of boats to carry every given person.</p><h3>Examples</h3><p><strong>Example 1:</strong></p><ul><li><strong>Input:</strong> people = [1,2], limit = 3</li><li><strong>Output:</strong> 1</li><li><strong>Explanation:</strong> 1 boat (1, 2)</li></ul><p><strong>Example 2:</strong></p><ul><li><strong>Input:</strong> people = [3,2,2,1], limit = 3</li><li><strong>Output:</strong> 3</li><li><strong>Explanation:</strong> 3 boats (1, 2), (2) and (3)</li></ul><p><strong>Example 3:</strong></p><ul><li><strong>Input:</strong> people = [3,5,3,4], limit = 5</li><li><strong>Output:</strong> 4</li><li><strong>Explanation:</strong> 4 boats (3), (3), (4), (5)</li></ul><h3>Constraints</h3><ul><li><code>1 <= people.length <= 5 * 10^4</code></li><li><code>1 <= people[i] <= limit <= 3 * 10^4</code></li></ul>",
  "languages": {
    "python": {
      "template": "def boatsToSavePeople(people, limit):\n    ",
      "solution_text": "<h3>Boats to Save People</h3><p><strong>Algorithm:</strong></p><ol><li>Sort the people array by weight</li><li>Use two pointers: lightest person (left) and heaviest person (right)</li><li>Try to pair the lightest with the heaviest in one boat</li><li>If they can't fit together, the heavier person goes alone</li><li>Move pointers accordingly and count boats</li></ol><p><strong>Time Complexity:</strong> O(n log n) - due to sorting</p><p><strong>Space Complexity:</strong> O(1) - only using two pointers</p><p><strong>Key Insights:</strong></p><ul><li>Greedy approach: always try to pair lightest with heaviest</li><li>If heaviest can't pair with lightest, it can't pair with anyone</li><li>Two pointers technique after sorting optimizes the pairing</li></ul>",
      "solution_code": "def boatsToSavePeople(people, limit):\n    people.sort()\n    left, right = 0, len(people) - 1\n    boats = 0\n    \n    while left <= right:\n        # If both lightest and heaviest can fit in one boat\n        if people[left] + people[right] <= limit:\n            left += 1  # Take the lightest person too\n        \n        # Always take the heaviest person (right pointer)\n        right -= 1\n        boats += 1\n    \n    return boats"
    },
    "javascript": {
      "template": "function boatsToSavePeople(people, limit) {\n  \n}",
      "solution_text": "<h3>Boats to Save People</h3><p><strong>Algorithm:</strong></p><ol><li>Sort the people array by weight</li><li>Use two pointers: lightest person (left) and heaviest person (right)</li><li>Try to pair the lightest with the heaviest in one boat</li><li>If they can't fit together, the heavier person goes alone</li><li>Move pointers accordingly and count boats</li></ol><p><strong>Time Complexity:</strong> O(n log n) - due to sorting</p><p><strong>Space Complexity:</strong> O(1) - only using two pointers</p><p><strong>Key Insights:</strong></p><ul><li>Greedy approach: always try to pair lightest with heaviest</li><li>If heaviest can't pair with lightest, it can't pair with anyone</li><li>Two pointers technique after sorting optimizes the pairing</li></ul>",
      "solution_code": "function boatsToSavePeople(people, limit) {\n    people.sort((a, b) => a - b);\n    let left = 0, right = people.length - 1;\n    let boats = 0;\n    \n    while (left <= right) {\n        // If both lightest and heaviest can fit in one boat\n        if (people[left] + people[right] <= limit) {\n            left++; // Take the lightest person too\n        }\n        \n        // Always take the heaviest person (right pointer)\n        right--;\n        boats++;\n    }\n    \n    return boats;\n}"
    },
    "typescript": {
      "template": "function boatsToSavePeople(people: number[], limit: number): number {\n  \n}",
      "solution_text": "<h3>Boats to Save People</h3><p><strong>Algorithm:</strong></p><ol><li>Sort the people array by weight</li><li>Use two pointers: lightest person (left) and heaviest person (right)</li><li>Try to pair the lightest with the heaviest in one boat</li><li>If they can't fit together, the heavier person goes alone</li><li>Move pointers accordingly and count boats</li></ol><p><strong>Time Complexity:</strong> O(n log n) - due to sorting</p><p><strong>Space Complexity:</strong> O(1) - only using two pointers</p><p><strong>Key Insights:</strong></p><ul><li>Greedy approach: always try to pair lightest with heaviest</li><li>If heaviest can't pair with lightest, it can't pair with anyone</li><li>Two pointers technique after sorting optimizes the pairing</li></ul>",
      "solution_code": "function boatsToSavePeople(people: number[], limit: number): number {\n    people.sort((a, b) => a - b);\n    let left = 0, right = people.length - 1;\n    let boats = 0;\n    \n    while (left <= right) {\n        // If both lightest and heaviest can fit in one boat\n        if (people[left] + people[right] <= limit) {\n            left++; // Take the lightest person too\n        }\n        \n        // Always take the heaviest person (right pointer)\n        right--;\n        boats++;\n    }\n    \n    return boats;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int boatsToSavePeople(int[] people, int limit) {\n        \n    }\n}",
      "solution_text": "<h3>Boats to Save People</h3><p><strong>Algorithm:</strong></p><ol><li>Sort the people array by weight</li><li>Use two pointers: lightest person (left) and heaviest person (right)</li><li>Try to pair the lightest with the heaviest in one boat</li><li>If they can't fit together, the heavier person goes alone</li><li>Move pointers accordingly and count boats</li></ol><p><strong>Time Complexity:</strong> O(n log n) - due to sorting</p><p><strong>Space Complexity:</strong> O(1) - only using two pointers</p><p><strong>Key Insights:</strong></p><ul><li>Greedy approach: always try to pair lightest with heaviest</li><li>If heaviest can't pair with lightest, it can't pair with anyone</li><li>Two pointers technique after sorting optimizes the pairing</li></ul>",
      "solution_code": "class Solution {\n    public int boatsToSavePeople(int[] people, int limit) {\n        Arrays.sort(people);\n        int left = 0, right = people.length - 1;\n        int boats = 0;\n        \n        while (left <= right) {\n            // If both lightest and heaviest can fit in one boat\n            if (people[left] + people[right] <= limit) {\n                left++; // Take the lightest person too\n            }\n            \n            // Always take the heaviest person (right pointer)\n            right--;\n            boats++;\n        }\n        \n        return boats;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "people": [1, 2],
        "limit": 3
      },
      "output": 1
    },
    {
      "id": 2,
      "input": {
        "people": [3, 2, 2, 1],
        "limit": 3
      },
      "output": 3
    },
    {
      "id": 3,
      "input": {
        "people": [3, 5, 3, 4],
        "limit": 5
      },
      "output": 4
    },
    {
      "id": 4,
      "input": {
        "people": [5, 1, 4, 2],
        "limit": 6
      },
      "output": 2
    },
    {
      "id": 5,
      "input": {
        "people": [1, 3, 2, 3, 2],
        "limit": 3
      },
      "output": 4
    },
    {
      "id": 6,
      "input": {
        "people": [1],
        "limit": 2
      },
      "output": 1
    },
    {
      "id": 7,
      "input": {
        "people": [5, 5, 5, 5],
        "limit": 5
      },
      "output": 4
    },
    {
      "id": 8,
      "input": {
        "people": [1, 2, 3, 4, 5],
        "limit": 5
      },
      "output": 3
    },
    {
      "id": 9,
      "input": {
        "people": [1, 1, 1, 1, 1, 1],
        "limit": 5
      },
      "output": 3
    },
    {
      "id": 10,
      "input": {
        "people": [10, 20, 30],
        "limit": 30
      },
      "output": 2
    },
    {
      "id": 11,
      "input": {
        "people": [44, 10, 29, 12, 49, 41, 23, 5],
        "limit": 50
      },
      "output": 5
    },
    {
      "id": 12,
      "input": {
        "people": [2, 49, 10, 7, 11, 41, 47, 2, 22, 6, 13, 12, 33, 18, 10, 26, 2, 6, 50, 10],
        "limit": 50
      },
      "output": 11
    }
  ]
}