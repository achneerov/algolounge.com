{
  "filename": "car-fleet",
  "title": "Car Fleet",
  "keywords": [
    "car",
    "fleet",
    "leetcode",
    "853",
    "there",
    "cars",
    "traveling",
    "same",
    "destination",
    "one"
  ],
  "description": "<h2>Car Fleet</h2><p>There are <code>n</code> cars traveling to the same destination on a one-lane highway.</p><p>You are given two arrays of integers <code>position</code> and <code>speed</code>, both of length <code>n</code>, where:</p><ul><li><code>position[i]</code> is the position of the <code>ith</code> car (in miles)</li><li><code>speed[i]</code> is the speed of the <code>ith</code> car (in miles per hour)</li></ul><p>The <strong>destination</strong> is at position <code>target</code> miles.</p><p>A car <strong>cannot</strong> pass another car ahead of it. It can only catch up to another car and then drive at the same speed as the car ahead of it.</p><p>A <strong>car fleet</strong> is a non-empty set of cars driving at the same position and same speed. A single car is also considered a car fleet.</p><p>If a car catches up to a car fleet the moment the fleet reaches the destination, then the car is considered to be part of the fleet.</p><p>Return the number of <strong>different car fleets</strong> that will arrive at the destination.</p><h3>Examples</h3><ul><li><strong>Input:</strong> <code>target = 10, position = [1,4], speed = [3,2]</code><br><strong>Output:</strong> <code>1</code><br><strong>Explanation:</strong> The cars starting at 1 (speed 3) and 4 (speed 2) become a fleet, meeting each other at 10, the destination.</li><li><strong>Input:</strong> <code>target = 10, position = [4,1,0,7], speed = [2,2,1,1]</code><br><strong>Output:</strong> <code>3</code><br><strong>Explanation:</strong> The cars starting at 4 and 7 become a fleet at position 10. The cars starting at 1 and 0 never catch up to the car ahead of them. Thus, there are 3 car fleets.</li></ul><h3>Constraints</h3><ul><li><code>n == position.length == speed.length</code></li><li><code>1 <= n <= 1000</code></li><li><code>0 < target <= 1000</code></li><li><code>0 < speed[i] <= 100</code></li><li><code>0 <= position[i] < target</code></li><li>All the values of <code>position</code> are <strong>unique</strong>.</li></ul>",
  "languages": {
    "python": {
      "template": "def carFleet(target, position, speed):\n    ",
      "solution_text": "<p><strong>Car Fleet Solution using Stack:</strong></p><p>Key insight: Cars starting closer to the target will reach first, unless caught up by faster cars from behind.</p><p><strong>Algorithm:</strong></p><ol><li>Pair each car's position with speed and sort by position (descending)</li><li>Calculate time to reach target for each car</li><li>Use stack to track fleet formation: if current car takes less time, it forms a fleet with the car ahead</li><li>Count remaining stacks as separate fleets</li></ol><p><strong>Time Complexity:</strong> O(n log n) - for sorting</p><p><strong>Space Complexity:</strong> O(n) - for car data and stack</p>",
      "solution_code": "def carFleet(target, position, speed):\n    if not position:\n        return 0\n    \n    # Pair position and speed, then sort by position (descending)\n    cars = sorted(zip(position, speed), reverse=True)\n    \n    stack = []\n    \n    for pos, spd in cars:\n        # Calculate time to reach target\n        time = (target - pos) / spd\n        \n        # If this car reaches destination faster than the car ahead,\n        # it will catch up and form a fleet\n        while stack and time <= stack[-1]:\n            stack.pop()\n        \n        stack.append(time)\n    \n    return len(stack)"
    },
    "javascript": {
      "template": "function carFleet(target, position, speed) {\n  \n}",
      "solution_text": "<p><strong>Car Fleet Solution using Stack:</strong></p><p>Key insight: Cars starting closer to the target will reach first, unless caught up by faster cars from behind.</p><p><strong>Algorithm:</strong></p><ol><li>Pair each car's position with speed and sort by position (descending)</li><li>Calculate time to reach target for each car</li><li>Use stack to track fleet formation: if current car takes less time, it forms a fleet with the car ahead</li><li>Count remaining stacks as separate fleets</li></ol><p><strong>Time Complexity:</strong> O(n log n) - for sorting</p><p><strong>Space Complexity:</strong> O(n) - for car data and stack</p>",
      "solution_code": "function carFleet(target, position, speed) {\n    if (position.length === 0) return 0;\n    \n    // Pair position and speed, then sort by position (descending)\n    const cars = position.map((pos, i) => [pos, speed[i]])\n                         .sort((a, b) => b[0] - a[0]);\n    \n    const stack = [];\n    \n    for (const [pos, spd] of cars) {\n        // Calculate time to reach target\n        const time = (target - pos) / spd;\n        \n        // If this car reaches destination faster than the car ahead,\n        // it will catch up and form a fleet\n        while (stack.length > 0 && time <= stack[stack.length - 1]) {\n            stack.pop();\n        }\n        \n        stack.push(time);\n    }\n    \n    return stack.length;\n}"
    },
    "typescript": {
      "template": "function carFleet(target: number, position: number[], speed: number[]): number {\n  \n}",
      "solution_text": "<p><strong>Car Fleet Solution using Stack:</strong></p><p>Key insight: Cars starting closer to the target will reach first, unless caught up by faster cars from behind.</p><p><strong>Algorithm:</strong></p><ol><li>Pair each car's position with speed and sort by position (descending)</li><li>Calculate time to reach target for each car</li><li>Use stack to track fleet formation: if current car takes less time, it forms a fleet with the car ahead</li><li>Count remaining stacks as separate fleets</li></ol><p><strong>Time Complexity:</strong> O(n log n) - for sorting</p><p><strong>Space Complexity:</strong> O(n) - for car data and stack</p>",
      "solution_code": "function carFleet(target: number, position: number[], speed: number[]): number {\n    if (position.length === 0) return 0;\n    \n    // Pair position and speed, then sort by position (descending)\n    const cars: [number, number][] = position.map((pos, i) => [pos, speed[i]])\n                                            .sort((a, b) => b[0] - a[0]);\n    \n    const stack: number[] = [];\n    \n    for (const [pos, spd] of cars) {\n        // Calculate time to reach target\n        const time: number = (target - pos) / spd;\n        \n        // If this car reaches destination faster than the car ahead,\n        // it will catch up and form a fleet\n        while (stack.length > 0 && time <= stack[stack.length - 1]) {\n            stack.pop();\n        }\n        \n        stack.push(time);\n    }\n    \n    return stack.length;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int carFleet(int target, int[] position, int[] speed) {\n        \n    }\n}",
      "solution_text": "<p><strong>Car Fleet Solution using Stack:</strong></p><p>Key insight: Cars starting closer to the target will reach first, unless caught up by faster cars from behind.</p><p><strong>Algorithm:</strong></p><ol><li>Pair each car's position with speed and sort by position (descending)</li><li>Calculate time to reach target for each car</li><li>Use stack to track fleet formation: if current car takes less time, it forms a fleet with the car ahead</li><li>Count remaining stacks as separate fleets</li></ol><p><strong>Time Complexity:</strong> O(n log n) - for sorting</p><p><strong>Space Complexity:</strong> O(n) - for car data and stack</p>",
      "solution_code": "import java.util.Arrays;\nimport java.util.Stack;\n\nclass Solution {\n    public int carFleet(int target, int[] position, int[] speed) {\n        if (position.length == 0) return 0;\n        \n        // Create array of cars with position and speed\n        int n = position.length;\n        Car[] cars = new Car[n];\n        for (int i = 0; i < n; i++) {\n            cars[i] = new Car(position[i], speed[i]);\n        }\n        \n        // Sort by position (descending)\n        Arrays.sort(cars, (a, b) -> Integer.compare(b.position, a.position));\n        \n        Stack<Double> stack = new Stack<>();\n        \n        for (Car car : cars) {\n            // Calculate time to reach target\n            double time = (double)(target - car.position) / car.speed;\n            \n            // If this car reaches destination faster than the car ahead,\n            // it will catch up and form a fleet\n            while (!stack.isEmpty() && time <= stack.peek()) {\n                stack.pop();\n            }\n            \n            stack.push(time);\n        }\n        \n        return stack.size();\n    }\n    \n    class Car {\n        int position;\n        int speed;\n        \n        Car(int position, int speed) {\n            this.position = position;\n            this.speed = speed;\n        }\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "target": 10,
        "position": [1, 4],
        "speed": [3, 2]
      },
      "output": 1
    },
    {
      "id": 2,
      "input": {
        "target": 10,
        "position": [4, 1, 0, 7],
        "speed": [2, 2, 1, 1]
      },
      "output": 3
    },
    {
      "id": 3,
      "input": {
        "target": 12,
        "position": [10, 8, 0, 5, 3],
        "speed": [2, 4, 1, 1, 3]
      },
      "output": 3
    },
    {
      "id": 4,
      "input": {
        "target": 100,
        "position": [0, 2, 4],
        "speed": [4, 2, 1]
      },
      "output": 1
    },
    {
      "id": 5,
      "input": {
        "target": 10,
        "position": [6, 8],
        "speed": [3, 2]
      },
      "output": 2
    },
    {
      "id": 6,
      "input": {
        "target": 10,
        "position": [0],
        "speed": [1]
      },
      "output": 1
    },
    {
      "id": 7,
      "input": {
        "target": 10,
        "position": [8, 3, 7, 4, 6, 5],
        "speed": [4, 4, 4, 4, 4, 4]
      },
      "output": 6
    },
    {
      "id": 8,
      "input": {
        "target": 20,
        "position": [6, 2, 17],
        "speed": [3, 9, 2]
      },
      "output": 2
    },
    {
      "id": 9,
      "input": {
        "target": 13,
        "position": [10, 4, 1, 8, 9],
        "speed": [3, 4, 5, 4, 3]
      },
      "output": 4
    },
    {
      "id": 10,
      "input": {
        "target": 15,
        "position": [0, 3, 6, 9, 12],
        "speed": [5, 4, 3, 2, 1]
      },
      "output": 1
    }
  ]
}