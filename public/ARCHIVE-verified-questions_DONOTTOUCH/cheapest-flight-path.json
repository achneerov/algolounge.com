{
  "filename": "cheapest-flight-path",
  "title": "Cheapest Flights Within K Stops",
  "keywords": [
    "cheapest",
    "flights",
    "within",
    "stops",
    "leetcode",
    "787",
    "there",
    "airports",
    "labeled",
    "which"
  ],
  "description": "<h2>Cheapest Flights Within K Stops</h2><p>There are <code>n</code> airports, labeled from <code>0</code> to <code>n - 1</code>, which are connected by some flights. You are given an array <code>flights</code> where <code>flights[i] = [from_i, to_i, price_i]</code> represents a one-way flight from airport <code>from_i</code> to airport <code>to_i</code> with cost <code>price_i</code>. You may assume there are no duplicate flights and no flights from an airport to itself.</p><p>You are also given three integers <code>src</code>, <code>dst</code>, and <code>k</code> where:</p><ul><li><code>src</code> is the starting airport</li><li><code>dst</code> is the destination airport</li><li><code>src != dst</code></li><li><code>k</code> is the maximum number of stops you can make (not including <code>src</code> and <code>dst</code>)</li></ul><p>Return <strong>the cheapest price</strong> from <code>src</code> to <code>dst</code> with at most <code>k</code> stops, or return <code>-1</code> if it is impossible.</p><h3>Examples</h3><ul><li><strong>Input:</strong> <code>n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1</code><br><strong>Output:</strong> <code>200</code><br><strong>Explanation:</strong> The cheapest price from city 0 to city 2 with at most 1 stop costs 200, as shown: 0 → 1 → 2.</li><li><strong>Input:</strong> <code>n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0</code><br><strong>Output:</strong> <code>500</code><br><strong>Explanation:</strong> The cheapest price from city 0 to city 2 with no stops costs 500.</li></ul><h3>Constraints</h3><ul><li><code>1 <= n <= 100</code></li><li><code>0 <= flights.length <= (n * (n - 1) / 2)</code></li><li><code>flights[i].length == 3</code></li><li><code>0 <= from_i, to_i < n</code></li><li><code>from_i != to_i</code></li><li><code>1 <= price_i <= 10000</code></li><li><code>0 <= src, dst, k < n</code></li><li><code>src != dst</code></li></ul>",
  "languages": {
    "python": {
      "template": "def cheapestFlightsWithinKStops(n, flights, src, dst, k):\n    ",
      "solution_text": "<p><strong>Cheapest Flights using Bellman-Ford Algorithm:</strong></p><p>Find shortest path with at most k+1 edges (k stops plus final destination).</p><p><strong>Algorithm:</strong></p><ol><li>Use modified Bellman-Ford algorithm with limited iterations</li><li>Initialize distances: src = 0, all others = infinity</li><li>For each iteration (up to k+1), relax all edges</li><li>Track previous distances to avoid using updated values in same iteration</li></ol><p><strong>Key Insight:</strong> We need at most k+1 edges to reach destination with k stops</p><p><strong>Time Complexity:</strong> O(k * E) where E is number of flights</p><p><strong>Space Complexity:</strong> O(n) for distance arrays</p>",
      "solution_code": "def cheapestFlightsWithinKStops(n, flights, src, dst, k):\n    # Initialize distances with infinity, except source\n    dist = [float('inf')] * n\n    dist[src] = 0\n    \n    # Bellman-Ford with at most k+1 iterations (k stops + destination)\n    for _ in range(k + 1):\n        # Use previous distances to avoid using updated values\n        prev_dist = dist[:]\n        \n        for u, v, price in flights:\n            if prev_dist[u] != float('inf'):\n                dist[v] = min(dist[v], prev_dist[u] + price)\n    \n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    "javascript": {
      "template": "function cheapestFlightsWithinKStops(n, flights, src, dst, k) {\n  \n}",
      "solution_text": "<p><strong>Cheapest Flights using Bellman-Ford Algorithm:</strong></p><p>Find shortest path with at most k+1 edges (k stops plus final destination).</p><p><strong>Algorithm:</strong></p><ol><li>Use modified Bellman-Ford algorithm with limited iterations</li><li>Initialize distances: src = 0, all others = infinity</li><li>For each iteration (up to k+1), relax all edges</li><li>Track previous distances to avoid using updated values in same iteration</li></ol><p><strong>Key Insight:</strong> We need at most k+1 edges to reach destination with k stops</p><p><strong>Time Complexity:</strong> O(k * E) where E is number of flights</p><p><strong>Space Complexity:</strong> O(n) for distance arrays</p>",
      "solution_code": "function cheapestFlightsWithinKStops(n, flights, src, dst, k) {\n    // Initialize distances with infinity, except source\n    const dist = new Array(n).fill(Infinity);\n    dist[src] = 0;\n    \n    // Bellman-Ford with at most k+1 iterations (k stops + destination)\n    for (let i = 0; i <= k; i++) {\n        // Use previous distances to avoid using updated values\n        const prevDist = [...dist];\n        \n        for (const [u, v, price] of flights) {\n            if (prevDist[u] !== Infinity) {\n                dist[v] = Math.min(dist[v], prevDist[u] + price);\n            }\n        }\n    }\n    \n    return dist[dst] === Infinity ? -1 : dist[dst];\n}"
    },
    "typescript": {
      "template": "function cheapestFlightsWithinKStops(n: number, flights: number[][], src: number, dst: number, k: number): number {\n  \n}",
      "solution_text": "<p><strong>Cheapest Flights using Bellman-Ford Algorithm:</strong></p><p>Find shortest path with at most k+1 edges (k stops plus final destination).</p><p><strong>Algorithm:</strong></p><ol><li>Use modified Bellman-Ford algorithm with limited iterations</li><li>Initialize distances: src = 0, all others = infinity</li><li>For each iteration (up to k+1), relax all edges</li><li>Track previous distances to avoid using updated values in same iteration</li></ol><p><strong>Key Insight:</strong> We need at most k+1 edges to reach destination with k stops</p><p><strong>Time Complexity:</strong> O(k * E) where E is number of flights</p><p><strong>Space Complexity:</strong> O(n) for distance arrays</p>",
      "solution_code": "function cheapestFlightsWithinKStops(n: number, flights: number[][], src: number, dst: number, k: number): number {\n    // Initialize distances with infinity, except source\n    const dist: number[] = new Array(n).fill(Infinity);\n    dist[src] = 0;\n    \n    // Bellman-Ford with at most k+1 iterations (k stops + destination)\n    for (let i = 0; i <= k; i++) {\n        // Use previous distances to avoid using updated values\n        const prevDist: number[] = [...dist];\n        \n        for (const [u, v, price] of flights) {\n            if (prevDist[u] !== Infinity) {\n                dist[v] = Math.min(dist[v], prevDist[u] + price);\n            }\n        }\n    }\n    \n    return dist[dst] === Infinity ? -1 : dist[dst];\n}"
    },
    "java": {
      "template": "class Solution {\n    public int cheapestFlightsWithinKStops(int n, int[][] flights, int src, int dst, int k) {\n        \n    }\n}",
      "solution_text": "<p><strong>Cheapest Flights using Bellman-Ford Algorithm:</strong></p><p>Find shortest path with at most k+1 edges (k stops plus final destination).</p><p><strong>Algorithm:</strong></p><ol><li>Use modified Bellman-Ford algorithm with limited iterations</li><li>Initialize distances: src = 0, all others = infinity</li><li>For each iteration (up to k+1), relax all edges</li><li>Track previous distances to avoid using updated values in same iteration</li></ol><p><strong>Key Insight:</strong> We need at most k+1 edges to reach destination with k stops</p><p><strong>Time Complexity:</strong> O(k * E) where E is number of flights</p><p><strong>Space Complexity:</strong> O(n) for distance arrays</p>",
      "solution_code": "import java.util.Arrays;\n\nclass Solution {\n    public int cheapestFlightsWithinKStops(int n, int[][] flights, int src, int dst, int k) {\n        // Initialize distances with infinity, except source\n        int[] dist = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[src] = 0;\n        \n        // Bellman-Ford with at most k+1 iterations (k stops + destination)\n        for (int i = 0; i <= k; i++) {\n            // Use previous distances to avoid using updated values\n            int[] prevDist = dist.clone();\n            \n            for (int[] flight : flights) {\n                int u = flight[0], v = flight[1], price = flight[2];\n                if (prevDist[u] != Integer.MAX_VALUE) {\n                    dist[v] = Math.min(dist[v], prevDist[u] + price);\n                }\n            }\n        }\n        \n        return dist[dst] == Integer.MAX_VALUE ? -1 : dist[dst];\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "n": 3,
        "flights": [[0,1,100],[1,2,100],[0,2,500]],
        "src": 0,
        "dst": 2,
        "k": 1
      },
      "output": 200
    },
    {
      "id": 2,
      "input": {
        "n": 3,
        "flights": [[0,1,100],[1,2,100],[0,2,500]],
        "src": 0,
        "dst": 2,
        "k": 0
      },
      "output": 500
    },
    {
      "id": 3,
      "input": {
        "n": 4,
        "flights": [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]],
        "src": 0,
        "dst": 3,
        "k": 1
      },
      "output": 700
    },
    {
      "id": 4,
      "input": {
        "n": 5,
        "flights": [[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]],
        "src": 0,
        "dst": 2,
        "k": 2
      },
      "output": 7
    },
    {
      "id": 5,
      "input": {
        "n": 2,
        "flights": [[1,0,5]],
        "src": 0,
        "dst": 1,
        "k": 1
      },
      "output": -1
    },
    {
      "id": 6,
      "input": {
        "n": 1,
        "flights": [],
        "src": 0,
        "dst": 0,
        "k": 0
      },
      "output": 0
    },
    {
      "id": 7,
      "input": {
        "n": 4,
        "flights": [[0,1,1],[0,2,5],[1,2,1],[2,3,1]],
        "src": 0,
        "dst": 3,
        "k": 1
      },
      "output": 6
    },
    {
      "id": 8,
      "input": {
        "n": 6,
        "flights": [[0,1,1],[1,2,1],[2,3,1],[3,4,1],[4,5,1],[0,5,10]],
        "src": 0,
        "dst": 5,
        "k": 4
      },
      "output": 5
    },
    {
      "id": 9,
      "input": {
        "n": 4,
        "flights": [[0,1,20],[1,2,20],[2,3,30],[0,2,100],[0,3,200]],
        "src": 0,
        "dst": 3,
        "k": 1
      },
      "output": 200
    },
    {
      "id": 10,
      "input": {
        "n": 5,
        "flights": [[1,2,10],[2,0,7],[1,3,8],[4,0,10],[3,4,2],[4,2,10],[0,3,3],[3,1,6],[2,4,5]],
        "src": 0,
        "dst": 4,
        "k": 1
      },
      "output": 5
    },
    {
      "id": 11,
      "input": {
        "n": 3,
        "flights": [[0,1,100],[1,2,100]],
        "src": 0,
        "dst": 2,
        "k": 0
      },
      "output": -1
    },
    {
      "id": 12,
      "input": {
        "n": 3,
        "flights": [[0,1,2],[1,2,1],[2,0,10]],
        "src": 1,
        "dst": 2,
        "k": 1
      },
      "output": 1
    }
  ]
}