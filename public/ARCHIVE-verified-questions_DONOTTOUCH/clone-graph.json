{
  "filename": "clone-graph",
  "title": "Clone Graph",
  "keywords": [
    "clone",
    "graph",
    "leetcode",
    "133",
    "given",
    "node",
    "connected",
    "undirected",
    "return",
    "deep"
  ],
  "description": "<h2>Clone Graph</h2><p>Leetcode 133. Clone Graph</p><p></p><p>Given a reference of a node in a <strong>connected</strong> undirected graph, return a <strong>deep copy</strong> (clone) of the graph.</p><p></p><p>Each node in the graph contains a value (<code>int</code>) and a list (<code>List[Node]</code>) of its neighbors.</p><p></p><p><code>class Node {<br>&nbsp;&nbsp;&nbsp;&nbsp;public int val;<br>&nbsp;&nbsp;&nbsp;&nbsp;public List&lt;Node&gt; neighbors;<br>}</code></p><p></p><p><strong>Test case format:</strong></p><p></p><p>For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with <code>val == 1</code>, the second node with <code>val == 2</code>, and so on. The graph is represented in the test case using an adjacency list.</p><p></p><p><strong>An adjacency list</strong> is a collection of unordered <strong>lists</strong> used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.</p><p></p><p>The given node will always be the first node with <code>val = 1</code>. You must return the <strong>copy of the given node</strong> as a reference to the cloned graph.</p><h3>Examples:</h3><ul><li>Input: adjList = [[2,4],[1,3],[2,4],[1,3]]<br><br>Output: [[2,4],[1,3],[2,4],[1,3]]<br><br>Explanation: There are 4 nodes in the graph.<br>1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).<br>2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).<br>3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).<br>4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).</li><li>Input: adjList = [[]]<br><br>Output: [[]]<br><br>Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.</li><li>Input: adjList = []<br><br>Output: []<br><br>Explanation: This an empty graph, it does not have any nodes.</li></ul><h3>Constraints:</h3><ul><li>The number of nodes in the graph is in the range <code>[0, 100]</code>.</li><li><code>1 &lt;= Node.val &lt;= 100</code></li><li><code>Node.val</code> is unique for each node.</li><li>There are no repeated edges and no self-loops in the graph.</li><li>The Graph is connected and all nodes can be visited starting from the given node.</li></ul>",
  "entry_function": "__init__",
  "template": "class Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\ndef cloneGraph(node):\n    ",
  "solution_text": "<h3>Clone Graph</h3><p><strong>Algorithm:</strong></p><ol><li>Use DFS with a hash map to track original node â†’ cloned node mapping</li><li>For each node, create a clone if not already created</li><li>Recursively clone all neighbors and add them to current clone's neighbors</li><li>Return the cloned node corresponding to the input node</li></ol><p><strong>Time Complexity:</strong> O(V + E) - visit each vertex and edge once</p><p><strong>Space Complexity:</strong> O(V) - hash map to store cloned nodes and recursion stack</p><p><strong>Key Insights:</strong></p><ul><li>Use hash map to avoid creating duplicate clones</li><li>DFS naturally handles the recursive cloning of neighbors</li><li>Handle cycles by checking if node is already cloned</li></ul>",
  "solution_code": "class Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\ndef cloneGraph(node):\n    if not node:\n        return None\n    \n    # Hash map to store original node -> cloned node mapping\n    clones = {}\n    \n    def dfs(original):\n        # If we've already cloned this node, return the clone\n        if original in clones:\n            return clones[original]\n        \n        # Create a new clone for this node\n        clone = Node(original.val)\n        clones[original] = clone\n        \n        # Clone all neighbors recursively\n        for neighbor in original.neighbors:\n            clone.neighbors.append(dfs(neighbor))\n        \n        return clone\n    \n    return dfs(node)",
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "adjList": [
          [
            2,
            4
          ],
          [
            1,
            3
          ],
          [
            2,
            4
          ],
          [
            1,
            3
          ]
        ]
      },
      "output": [
        [
          2,
          4
        ],
        [
          1,
          3
        ],
        [
          2,
          4
        ],
        [
          1,
          3
        ]
      ]
    },
    {
      "id": 2,
      "input": {
        "adjList": [
          []
        ]
      },
      "output": [
        []
      ]
    },
    {
      "id": 3,
      "input": {
        "adjList": []
      },
      "output": []
    },
    {
      "id": 4,
      "input": {
        "adjList": [
          [
            2
          ],
          [
            1
          ]
        ]
      },
      "output": [
        [
          2
        ],
        [
          1
        ]
      ]
    },
    {
      "id": 5,
      "input": {
        "adjList": [
          [
            2,
            3
          ],
          [
            1,
            4
          ],
          [
            1,
            4
          ],
          [
            2,
            3
          ]
        ]
      },
      "output": [
        [
          2,
          3
        ],
        [
          1,
          4
        ],
        [
          1,
          4
        ],
        [
          2,
          3
        ]
      ]
    },
    {
      "id": 6,
      "input": {
        "adjList": [
          [
            2,
            3,
            4
          ],
          [
            1
          ],
          [
            1
          ],
          [
            1
          ]
        ]
      },
      "output": [
        [
          2,
          3,
          4
        ],
        [
          1
        ],
        [
          1
        ],
        [
          1
        ]
      ]
    },
    {
      "id": 7,
      "input": {
        "adjList": [
          [
            2
          ],
          [
            1,
            3
          ],
          [
            2,
            4,
            5
          ],
          [
            3,
            6
          ],
          [
            3,
            7
          ],
          [
            4
          ],
          [
            5
          ]
        ]
      },
      "output": [
        [
          2
        ],
        [
          1,
          3
        ],
        [
          2,
          4,
          5
        ],
        [
          3,
          6
        ],
        [
          3,
          7
        ],
        [
          4
        ],
        [
          5
        ]
      ]
    },
    {
      "id": 8,
      "input": {
        "adjList": [
          [
            2,
            3
          ],
          [
            1,
            3
          ],
          [
            1,
            2
          ]
        ]
      },
      "output": [
        [
          2,
          3
        ],
        [
          1,
          3
        ],
        [
          1,
          2
        ]
      ]
    },
    {
      "id": 9,
      "input": {
        "adjList": [
          [
            2,
            5
          ],
          [
            1,
            3
          ],
          [
            2,
            4
          ],
          [
            3,
            5
          ],
          [
            1,
            4
          ]
        ]
      },
      "output": [
        [
          2,
          5
        ],
        [
          1,
          3
        ],
        [
          2,
          4
        ],
        [
          3,
          5
        ],
        [
          1,
          4
        ]
      ]
    },
    {
      "id": 10,
      "input": {
        "adjList": [
          [
            2,
            3,
            4,
            5,
            6
          ],
          [
            1
          ],
          [
            1
          ],
          [
            1
          ],
          [
            1
          ],
          [
            1
          ]
        ]
      },
      "output": [
        [
          2,
          3,
          4,
          5,
          6
        ],
        [
          1
        ],
        [
          1
        ],
        [
          1
        ],
        [
          1
        ],
        [
          1
        ]
      ]
    },
    {
      "id": 11,
      "input": {
        "adjList": [
          [
            2
          ],
          [
            3
          ],
          [
            1
          ]
        ]
      },
      "output": [
        [
          2
        ],
        [
          3
        ],
        [
          1
        ]
      ]
    },
    {
      "id": 12,
      "input": {
        "adjList": [
          [
            2,
            3,
            4
          ],
          [
            1,
            4,
            5
          ],
          [
            1,
            5,
            6
          ],
          [
            1,
            2,
            6
          ],
          [
            2,
            3,
            6
          ],
          [
            3,
            4,
            5
          ]
        ]
      },
      "output": [
        [
          2,
          3,
          4
        ],
        [
          1,
          4,
          5
        ],
        [
          1,
          5,
          6
        ],
        [
          1,
          2,
          6
        ],
        [
          2,
          3,
          6
        ],
        [
          3,
          4,
          5
        ]
      ]
    }
  ]
}