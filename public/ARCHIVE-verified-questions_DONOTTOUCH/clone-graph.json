{
  "filename": "clone-graph",
  "title": "Clone Graph",
  "keywords": [
    "clone",
    "graph",
    "leetcode",
    "133",
    "given",
    "node",
    "connected",
    "undirected",
    "return",
    "deep"
  ],
  "description": "<h2>Clone Graph</h2><p>Leetcode 133. Clone Graph</p><p></p><p>Given a reference of a node in a <strong>connected</strong> undirected graph, return a <strong>deep copy</strong> (clone) of the graph.</p><p></p><p>Each node in the graph contains a value (<code>int</code>) and a list (<code>List[Node]</code>) of its neighbors.</p><p></p><p><code>class Node {<br>&nbsp;&nbsp;&nbsp;&nbsp;public int val;<br>&nbsp;&nbsp;&nbsp;&nbsp;public List&lt;Node&gt; neighbors;<br>}</code></p><p></p><p><strong>Test case format:</strong></p><p></p><p>For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with <code>val == 1</code>, the second node with <code>val == 2</code>, and so on. The graph is represented in the test case using an adjacency list.</p><p></p><p><strong>An adjacency list</strong> is a collection of unordered <strong>lists</strong> used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.</p><p></p><p>The given node will always be the first node with <code>val = 1</code>. You must return the <strong>copy of the given node</strong> as a reference to the cloned graph.</p><h3>Examples:</h3><ul><li>Input: adjList = [[2,4],[1,3],[2,4],[1,3]]<br><br>Output: [[2,4],[1,3],[2,4],[1,3]]<br><br>Explanation: There are 4 nodes in the graph.<br>1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).<br>2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).<br>3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).<br>4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).</li><li>Input: adjList = [[]]<br><br>Output: [[]]<br><br>Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.</li><li>Input: adjList = []<br><br>Output: []<br><br>Explanation: This an empty graph, it does not have any nodes.</li></ul><h3>Constraints:</h3><ul><li>The number of nodes in the graph is in the range <code>[0, 100]</code>.</li><li><code>1 &lt;= Node.val &lt;= 100</code></li><li><code>Node.val</code> is unique for each node.</li><li>There are no repeated edges and no self-loops in the graph.</li><li>The Graph is connected and all nodes can be visited starting from the given node.</li></ul>",
  "languages": {
    "python": {
      "template": "class Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\ndef cloneGraph(node):\n    ",
      "solution_text": "<h3>Clone Graph</h3><p><strong>Algorithm:</strong></p><ol><li>Use DFS with a hash map to track original node → cloned node mapping</li><li>For each node, create a clone if not already created</li><li>Recursively clone all neighbors and add them to current clone's neighbors</li><li>Return the cloned node corresponding to the input node</li></ol><p><strong>Time Complexity:</strong> O(V + E) - visit each vertex and edge once</p><p><strong>Space Complexity:</strong> O(V) - hash map to store cloned nodes and recursion stack</p><p><strong>Key Insights:</strong></p><ul><li>Use hash map to avoid creating duplicate clones</li><li>DFS naturally handles the recursive cloning of neighbors</li><li>Handle cycles by checking if node is already cloned</li></ul>",
      "solution_code": "class Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\ndef cloneGraph(node):\n    if not node:\n        return None\n    \n    # Hash map to store original node -> cloned node mapping\n    clones = {}\n    \n    def dfs(original):\n        # If we've already cloned this node, return the clone\n        if original in clones:\n            return clones[original]\n        \n        # Create a new clone for this node\n        clone = Node(original.val)\n        clones[original] = clone\n        \n        # Clone all neighbors recursively\n        for neighbor in original.neighbors:\n            clone.neighbors.append(dfs(neighbor))\n        \n        return clone\n    \n    return dfs(node)"
    },
    "javascript": {
      "template": "function cloneGraph(node) {\n  \n}",
      "solution_text": "<h3>Clone Graph</h3><p><strong>Algorithm:</strong></p><ol><li>Use DFS with a hash map to track original node → cloned node mapping</li><li>For each node, create a clone if not already created</li><li>Recursively clone all neighbors and add them to current clone's neighbors</li><li>Return the cloned node corresponding to the input node</li></ol><p><strong>Time Complexity:</strong> O(V + E) - visit each vertex and edge once</p><p><strong>Space Complexity:</strong> O(V) - hash map to store cloned nodes and recursion stack</p><p><strong>Key Insights:</strong></p><ul><li>Use hash map to avoid creating duplicate clones</li><li>DFS naturally handles the recursive cloning of neighbors</li><li>Handle cycles by checking if node is already cloned</li></ul>",
      "solution_code": "function cloneGraph(node) {\n    if (!node) return null;\n    \n    // Hash map to store original node -> cloned node mapping\n    const clones = new Map();\n    \n    function dfs(original) {\n        // If we've already cloned this node, return the clone\n        if (clones.has(original)) {\n            return clones.get(original);\n        }\n        \n        // Create a new clone for this node\n        const clone = { val: original.val, neighbors: [] };\n        clones.set(original, clone);\n        \n        // Clone all neighbors recursively\n        for (const neighbor of original.neighbors) {\n            clone.neighbors.push(dfs(neighbor));\n        }\n        \n        return clone;\n    }\n    \n    return dfs(node);\n}"
    },
    "typescript": {
      "template": "class Node {\n    val: number;\n    neighbors: Node[];\n    constructor(val?: number, neighbors?: Node[]) {\n        this.val = (val===undefined ? 0 : val);\n        this.neighbors = (neighbors===undefined ? [] : neighbors);\n    }\n}\n\nfunction cloneGraph(node: Node | null): Node | null {\n  \n}",
      "solution_text": "<h3>Clone Graph</h3><p><strong>Algorithm:</strong></p><ol><li>Use DFS with a hash map to track original node → cloned node mapping</li><li>For each node, create a clone if not already created</li><li>Recursively clone all neighbors and add them to current clone's neighbors</li><li>Return the cloned node corresponding to the input node</li></ol><p><strong>Time Complexity:</strong> O(V + E) - visit each vertex and edge once</p><p><strong>Space Complexity:</strong> O(V) - hash map to store cloned nodes and recursion stack</p><p><strong>Key Insights:</strong></p><ul><li>Use hash map to avoid creating duplicate clones</li><li>DFS naturally handles the recursive cloning of neighbors</li><li>Handle cycles by checking if node is already cloned</li></ul>",
      "solution_code": "class Node {\n    val: number;\n    neighbors: Node[];\n    constructor(val?: number, neighbors?: Node[]) {\n        this.val = (val===undefined ? 0 : val);\n        this.neighbors = (neighbors===undefined ? [] : neighbors);\n    }\n}\n\nfunction cloneGraph(node: Node | null): Node | null {\n    if (!node) return null;\n    \n    // Hash map to store original node -> cloned node mapping\n    const clones = new Map<Node, Node>();\n    \n    function dfs(original: Node): Node {\n        // If we've already cloned this node, return the clone\n        if (clones.has(original)) {\n            return clones.get(original)!;\n        }\n        \n        // Create a new clone for this node\n        const clone = new Node(original.val);\n        clones.set(original, clone);\n        \n        // Clone all neighbors recursively\n        for (const neighbor of original.neighbors) {\n            clone.neighbors.push(dfs(neighbor));\n        }\n        \n        return clone;\n    }\n    \n    return dfs(node);\n}"
    },
    "java": {
      "template": "import java.util.*;\n\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    \n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    \n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    \n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n\nclass Solution {\n    public Node cloneGraph(Node node) {\n        \n    }\n}",
      "solution_text": "<h3>Clone Graph</h3><p><strong>Algorithm:</strong></p><ol><li>Use DFS with a hash map to track original node → cloned node mapping</li><li>For each node, create a clone if not already created</li><li>Recursively clone all neighbors and add them to current clone's neighbors</li><li>Return the cloned node corresponding to the input node</li></ol><p><strong>Time Complexity:</strong> O(V + E) - visit each vertex and edge once</p><p><strong>Space Complexity:</strong> O(V) - hash map to store cloned nodes and recursion stack</p><p><strong>Key Insights:</strong></p><ul><li>Use hash map to avoid creating duplicate clones</li><li>DFS naturally handles the recursive cloning of neighbors</li><li>Handle cycles by checking if node is already cloned</li></ul>",
      "solution_code": "import java.util.*;\n\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    \n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    \n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    \n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n\nclass Solution {\n    public Node cloneGraph(Node node) {\n        if (node == null) return null;\n        \n        // Hash map to store original node -> cloned node mapping\n        Map<Node, Node> clones = new HashMap<>();\n        \n        return dfs(node, clones);\n    }\n    \n    private Node dfs(Node original, Map<Node, Node> clones) {\n        // If we've already cloned this node, return the clone\n        if (clones.containsKey(original)) {\n            return clones.get(original);\n        }\n        \n        // Create a new clone for this node\n        Node clone = new Node(original.val, new ArrayList<>());\n        clones.put(original, clone);\n        \n        // Clone all neighbors recursively\n        for (Node neighbor : original.neighbors) {\n            clone.neighbors.add(dfs(neighbor, clones));\n        }\n        \n        return clone;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "adjList": [[2,4],[1,3],[2,4],[1,3]]
      },
      "output": [[2,4],[1,3],[2,4],[1,3]]
    },
    {
      "id": 2,
      "input": {
        "adjList": [[]]
      },
      "output": [[]]
    },
    {
      "id": 3,
      "input": {
        "adjList": []
      },
      "output": []
    },
    {
      "id": 4,
      "input": {
        "adjList": [[2],[1]]
      },
      "output": [[2],[1]]
    },
    {
      "id": 5,
      "input": {
        "adjList": [[2,3],[1,4],[1,4],[2,3]]
      },
      "output": [[2,3],[1,4],[1,4],[2,3]]
    },
    {
      "id": 6,
      "input": {
        "adjList": [[2,3,4],[1],[1],[1]]
      },
      "output": [[2,3,4],[1],[1],[1]]
    },
    {
      "id": 7,
      "input": {
        "adjList": [[2],[1,3],[2,4,5],[3,6],[3,7],[4],[5]]
      },
      "output": [[2],[1,3],[2,4,5],[3,6],[3,7],[4],[5]]
    },
    {
      "id": 8,
      "input": {
        "adjList": [[2,3],[1,3],[1,2]]
      },
      "output": [[2,3],[1,3],[1,2]]
    },
    {
      "id": 9,
      "input": {
        "adjList": [[2,5],[1,3],[2,4],[3,5],[1,4]]
      },
      "output": [[2,5],[1,3],[2,4],[3,5],[1,4]]
    },
    {
      "id": 10,
      "input": {
        "adjList": [[2,3,4,5,6],[1],[1],[1],[1],[1]]
      },
      "output": [[2,3,4,5,6],[1],[1],[1],[1],[1]]
    },
    {
      "id": 11,
      "input": {
        "adjList": [[2],[3],[1]]
      },
      "output": [[2],[3],[1]]
    },
    {
      "id": 12,
      "input": {
        "adjList": [[2,3,4],[1,4,5],[1,5,6],[1,2,6],[2,3,6],[3,4,5]]
      },
      "output": [[2,3,4],[1,4,5],[1,5,6],[1,2,6],[2,3,6],[3,4,5]]
    }
  ]
}