{
  "filename": "coin-change-ii",
  "title": "Coin Change II",
  "keywords": [
    "coin",
    "change",
    "leetcode",
    "518",
    "given",
    "integer",
    "array",
    "coins",
    "representing",
    "different"
  ],
  "description": "<h2>Coin Change II</h2><p>Leetcode 518. Coin Change II</p><p>You are given an integer array <code>coins</code> representing coins of different denominations (e.g. 1 dollar, 5 dollars, etc) and an integer <code>amount</code> representing a target amount of money.</p><p>Return the <strong>number of distinct combinations</strong> that total up to <code>amount</code>. If it's impossible to make up the amount, return <code>0</code>.</p><p>You may assume that you have an <strong>unlimited number of each coin</strong> and that each value in <code>coins</code> is unique.</p><h3>Examples:</h3><ul><li><strong>Input:</strong> amount = 4, coins = [1,2,3]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong><br>• 1+1+1+1 = 4<br>• 1+1+2 = 4<br>• 2+2 = 4<br>• 1+3 = 4</li><li><strong>Input:</strong> amount = 7, coins = [2,4]<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> No combination of coins can sum to 7</li></ul><h3>Constraints:</h3><ul><li><code>1 <= coins.length <= 100</code></li><li><code>1 <= coins[i] <= 5000</code></li><li><code>0 <= amount <= 5000</code></li></ul>",
  "languages": {
    "python": {
      "template": "def change(amount, coins):\n    ",
      "solution_text": "<h3>Coin Change II</h3><p><strong>Algorithm:</strong></p><ol><li>Use 2D DP where dp[i][j] = ways to make amount j using first i coins</li><li>For each coin, we can either include it or exclude it</li><li>If we include coin, subtract its value and add ways from previous amount</li><li>If we exclude coin, take ways from previous coin index</li><li>Optimize to 1D DP by processing coins in order</li></ol><p><strong>Time Complexity:</strong> O(amount × coins.length) - fill DP table</p><p><strong>Space Complexity:</strong> O(amount) - 1D DP array optimization</p><p><strong>Key Insights:</strong></p><ul><li>This is a combination problem, not permutation (order doesn't matter)</li><li>Process coins in order to avoid duplicate combinations</li><li>Base case: dp[0] = 1 (one way to make amount 0 - use no coins)</li></ul>",
      "solution_code": "def change(amount, coins):\n    # dp[i] = number of ways to make amount i\n    dp = [0] * (amount + 1)\n    dp[0] = 1  # One way to make amount 0: use no coins\n    \n    # Process each coin\n    for coin in coins:\n        # Update dp array for this coin\n        for i in range(coin, amount + 1):\n            dp[i] += dp[i - coin]\n    \n    return dp[amount]"
    },
    "javascript": {
      "template": "function change(amount, coins) {\n  \n}",
      "solution_text": "<h3>Coin Change II</h3><p><strong>Algorithm:</strong></p><ol><li>Use 2D DP where dp[i][j] = ways to make amount j using first i coins</li><li>For each coin, we can either include it or exclude it</li><li>If we include coin, subtract its value and add ways from previous amount</li><li>If we exclude coin, take ways from previous coin index</li><li>Optimize to 1D DP by processing coins in order</li></ol><p><strong>Time Complexity:</strong> O(amount × coins.length) - fill DP table</p><p><strong>Space Complexity:</strong> O(amount) - 1D DP array optimization</p><p><strong>Key Insights:</strong></p><ul><li>This is a combination problem, not permutation (order doesn't matter)</li><li>Process coins in order to avoid duplicate combinations</li><li>Base case: dp[0] = 1 (one way to make amount 0 - use no coins)</li></ul>",
      "solution_code": "function change(amount, coins) {\n    // dp[i] = number of ways to make amount i\n    const dp = new Array(amount + 1).fill(0);\n    dp[0] = 1; // One way to make amount 0: use no coins\n    \n    // Process each coin\n    for (const coin of coins) {\n        // Update dp array for this coin\n        for (let i = coin; i <= amount; i++) {\n            dp[i] += dp[i - coin];\n        }\n    }\n    \n    return dp[amount];\n}"
    },
    "typescript": {
      "template": "function change(amount: number, coins: number[]): number {\n  \n}",
      "solution_text": "<h3>Coin Change II</h3><p><strong>Algorithm:</strong></p><ol><li>Use 2D DP where dp[i][j] = ways to make amount j using first i coins</li><li>For each coin, we can either include it or exclude it</li><li>If we include coin, subtract its value and add ways from previous amount</li><li>If we exclude coin, take ways from previous coin index</li><li>Optimize to 1D DP by processing coins in order</li></ol><p><strong>Time Complexity:</strong> O(amount × coins.length) - fill DP table</p><p><strong>Space Complexity:</strong> O(amount) - 1D DP array optimization</p><p><strong>Key Insights:</strong></p><ul><li>This is a combination problem, not permutation (order doesn't matter)</li><li>Process coins in order to avoid duplicate combinations</li><li>Base case: dp[0] = 1 (one way to make amount 0 - use no coins)</li></ul>",
      "solution_code": "function change(amount: number, coins: number[]): number {\n    // dp[i] = number of ways to make amount i\n    const dp: number[] = new Array(amount + 1).fill(0);\n    dp[0] = 1; // One way to make amount 0: use no coins\n    \n    // Process each coin\n    for (const coin of coins) {\n        // Update dp array for this coin\n        for (let i = coin; i <= amount; i++) {\n            dp[i] += dp[i - coin];\n        }\n    }\n    \n    return dp[amount];\n}"
    },
    "java": {
      "template": "class Solution {\n    public int change(int amount, int[] coins) {\n        \n    }\n}",
      "solution_text": "<h3>Coin Change II</h3><p><strong>Algorithm:</strong></p><ol><li>Use 2D DP where dp[i][j] = ways to make amount j using first i coins</li><li>For each coin, we can either include it or exclude it</li><li>If we include coin, subtract its value and add ways from previous amount</li><li>If we exclude coin, take ways from previous coin index</li><li>Optimize to 1D DP by processing coins in order</li></ol><p><strong>Time Complexity:</strong> O(amount × coins.length) - fill DP table</p><p><strong>Space Complexity:</strong> O(amount) - 1D DP array optimization</p><p><strong>Key Insights:</strong></p><ul><li>This is a combination problem, not permutation (order doesn't matter)</li><li>Process coins in order to avoid duplicate combinations</li><li>Base case: dp[0] = 1 (one way to make amount 0 - use no coins)</li></ul>",
      "solution_code": "class Solution {\n    public int change(int amount, int[] coins) {\n        // dp[i] = number of ways to make amount i\n        int[] dp = new int[amount + 1];\n        dp[0] = 1; // One way to make amount 0: use no coins\n        \n        // Process each coin\n        for (int coin : coins) {\n            // Update dp array for this coin\n            for (int i = coin; i <= amount; i++) {\n                dp[i] += dp[i - coin];\n            }\n        }\n        \n        return dp[amount];\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "amount": 4,
        "coins": [1, 2, 3]
      },
      "output": 4
    },
    {
      "id": 2,
      "input": {
        "amount": 7,
        "coins": [2, 4]
      },
      "output": 0
    },
    {
      "id": 3,
      "input": {
        "amount": 0,
        "coins": [1, 2, 5]
      },
      "output": 1
    },
    {
      "id": 4,
      "input": {
        "amount": 5,
        "coins": [1, 2, 5]
      },
      "output": 4
    },
    {
      "id": 5,
      "input": {
        "amount": 3,
        "coins": [2]
      },
      "output": 0
    },
    {
      "id": 6,
      "input": {
        "amount": 10,
        "coins": [10]
      },
      "output": 1
    },
    {
      "id": 7,
      "input": {
        "amount": 6,
        "coins": [1, 2, 3]
      },
      "output": 7
    },
    {
      "id": 8,
      "input": {
        "amount": 11,
        "coins": [1, 5, 10]
      },
      "output": 3
    },
    {
      "id": 9,
      "input": {
        "amount": 8,
        "coins": [2, 3, 5]
      },
      "output": 3
    },
    {
      "id": 10,
      "input": {
        "amount": 15,
        "coins": [1, 3, 4]
      },
      "output": 22
    },
    {
      "id": 11,
      "input": {
        "amount": 1,
        "coins": [1]
      },
      "output": 1
    },
    {
      "id": 12,
      "input": {
        "amount": 500,
        "coins": [3, 5, 7, 8, 9, 10, 11]
      },
      "output": 35502874
    }
  ]
}