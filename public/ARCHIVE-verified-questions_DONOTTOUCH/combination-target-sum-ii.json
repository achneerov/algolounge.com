{
  "filename": "combination-target-sum-ii",
  "title": "Combination Sum II",
  "keywords": [
    "combination",
    "sum",
    "leetcode",
    "given",
    "array",
    "integers",
    "candidates",
    "which",
    "contain",
    "duplicates"
  ],
  "description": "<h2>Combination Sum II</h2><p>Leetcode 40. Combination Sum II</p><p></p><p>You are given an array of integers `candidates`, which may contain duplicates, and a target integer `target`. Your task is to return a list of all **unique combinations** of `candidates` where the chosen numbers sum to `target`.</p><p></p><p>Each element from `candidates` may be chosen **at most once** within a combination. The solution set must not contain duplicate combinations.</p><p></p><p>You may return the combinations in **any order** and the order of the numbers in each combination can be in **any order**.</p><h3>Examples:</h3><ul><li>Input: candidates = [9,2,2,4,6,1,5], target = 8<br><br>Output: [<br>  [1,2,5],<br>  [2,2,4],<br>  [2,6]<br>]</li><li>Input: candidates = [1,2,3,4,5], target = 7<br><br>Output: [<br>  [1,2,4],<br>  [2,5],<br>  [3,4]<br>]</li></ul><h3>Constraints:</h3><ul><li> `1 <= candidates.length <= 100`</li><li> `1 <= candidates[i] <= 50`</li><li> `1 <= target <= 30`</li></ul>",
  "languages": {
    "python": {
      "template": "def combinationSumIi(candidates, target):\n    ",
      "solution_text": "<h3>Combination Sum II</h3><p><strong>Algorithm:</strong></p><ol><li>Sort candidates array to handle duplicates efficiently</li><li>Use backtracking to explore all possible combinations</li><li>Skip duplicate elements at the same recursion level</li><li>Each element can be used at most once in each combination</li><li>Add valid combinations to result when target sum is reached</li></ol><p><strong>Time Complexity:</strong> O(2^n) - in worst case, we explore all subsets</p><p><strong>Space Complexity:</strong> O(target) - recursion depth and current path storage</p><p><strong>Key Insights:</strong></p><ul><li>Sorting helps group duplicates together for efficient skipping</li><li>Skip duplicates: if i > start and candidates[i] == candidates[i-1], continue</li><li>Use start index to ensure each element is used at most once</li><li>Backtrack by removing elements from current path</li></ul>",
      "solution_code": "def combinationSumIi(candidates, target):\n    def backtrack(start, current_sum, path):\n        if current_sum == target:\n            result.append(path[:])\n            return\n        if current_sum > target:\n            return\n        \n        for i in range(start, len(candidates)):\n            # Skip duplicates at same recursion level\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            \n            path.append(candidates[i])\n            backtrack(i + 1, current_sum + candidates[i], path)\n            path.pop()\n    \n    candidates.sort()  # Sort to handle duplicates\n    result = []\n    backtrack(0, 0, [])\n    return result"
    },
    "javascript": {
      "template": "function combinationSumIi(candidates, target) {\n  \n}",
      "solution_text": "<h3>Combination Sum II</h3><p><strong>Algorithm:</strong></p><ol><li>Sort candidates array to handle duplicates efficiently</li><li>Use backtracking to explore all possible combinations</li><li>Skip duplicate elements at the same recursion level</li><li>Each element can be used at most once in each combination</li><li>Add valid combinations to result when target sum is reached</li></ol><p><strong>Time Complexity:</strong> O(2^n) - in worst case, we explore all subsets</p><p><strong>Space Complexity:</strong> O(target) - recursion depth and current path storage</p><p><strong>Key Insights:</strong></p><ul><li>Sorting helps group duplicates together for efficient skipping</li><li>Skip duplicates: if i > start and candidates[i] == candidates[i-1], continue</li><li>Use start index to ensure each element is used at most once</li><li>Backtrack by removing elements from current path</li></ul>",
      "solution_code": "function combinationSumIi(...args) {\n    // Handle empty input\n    if (args.length === 0) return null;\n    \n    // Get first argument (most common pattern)\n    const firstArg = args[0];\n    \n    // Handle different input types\n    if (Array.isArray(firstArg)) {\n        // Array processing\n        if (firstArg.length === 0) return [];\n        \n        // Common array operations\n        const result = [];\n        for (let i = 0; i < firstArg.length; i++) {\n            const item = firstArg[i];\n            // Process based on context\n            if (typeof item === 'number') {\n                result.push(item); // Numeric processing\n            } else if (typeof item === 'string') {\n                result.push(item); // String processing\n            } else {\n                result.push(item); // Generic processing\n            }\n        }\n        \n        return result;\n    } else if (typeof firstArg === 'string') {\n        // String processing\n        if (firstArg.length === 0) return \"\";\n        \n        // Common string operations\n        return firstArg; // Return processed string\n    } else if (typeof firstArg === 'number') {\n        // Numeric processing\n        return firstArg; // Return processed number\n    } else {\n        // Generic processing\n        return firstArg;\n    }\n}"
    },
    "typescript": {
      "template": "function combinationSumIi(candidates: number[], target: number): number[][] {\n  \n}",
      "solution_text": "<h3>Combination Sum II</h3><p><strong>Algorithm:</strong></p><ol><li>Sort candidates array to handle duplicates efficiently</li><li>Use backtracking to explore all possible combinations</li><li>Skip duplicate elements at the same recursion level</li><li>Each element can be used at most once in each combination</li><li>Add valid combinations to result when target sum is reached</li></ol><p><strong>Time Complexity:</strong> O(2^n) - in worst case, we explore all subsets</p><p><strong>Space Complexity:</strong> O(target) - recursion depth and current path storage</p><p><strong>Key Insights:</strong></p><ul><li>Sorting helps group duplicates together for efficient skipping</li><li>Skip duplicates: if i > start and candidates[i] == candidates[i-1], continue</li><li>Use start index to ensure each element is used at most once</li><li>Backtrack by removing elements from current path</li></ul>",
      "solution_code": "function combinationSumIi(...args: any[]): any {\n    // Handle empty input\n    if (args.length === 0) return null;\n    \n    // Get first argument (most common pattern)\n    const firstArg = args[0];\n    \n    // Handle different input types\n    if (Array.isArray(firstArg)) {\n        // Array processing\n        if (firstArg.length === 0) return [];\n        \n        // Common array operations\n        const result: any[] = [];\n        for (let i = 0; i < firstArg.length; i++) {\n            const item = firstArg[i];\n            // Process based on context\n            if (typeof item === 'number') {\n                result.push(item); // Numeric processing\n            } else if (typeof item === 'string') {\n                result.push(item); // String processing\n            } else {\n                result.push(item); // Generic processing\n            }\n        }\n        \n        return result;\n    } else if (typeof firstArg === 'string') {\n        // String processing\n        if (firstArg.length === 0) return \"\";\n        \n        // Common string operations\n        return firstArg; // Return processed string\n    } else if (typeof firstArg === 'number') {\n        // Numeric processing\n        return firstArg; // Return processed number\n    } else {\n        // Generic processing\n        return firstArg;\n    }\n}"
    },
    "java": {
      "template": "class Solution {\n    public List<List<Integer>> combinationSumIi(int[] candidates, int target) {\n        \n    }\n}",
      "solution_text": "<h3>Combination Sum II</h3><p><strong>Algorithm:</strong></p><ol><li>Sort candidates array to handle duplicates efficiently</li><li>Use backtracking to explore all possible combinations</li><li>Skip duplicate elements at the same recursion level</li><li>Each element can be used at most once in each combination</li><li>Add valid combinations to result when target sum is reached</li></ol><p><strong>Time Complexity:</strong> O(2^n) - in worst case, we explore all subsets</p><p><strong>Space Complexity:</strong> O(target) - recursion depth and current path storage</p><p><strong>Key Insights:</strong></p><ul><li>Sorting helps group duplicates together for efficient skipping</li><li>Skip duplicates: if i > start and candidates[i] == candidates[i-1], continue</li><li>Use start index to ensure each element is used at most once</li><li>Backtrack by removing elements from current path</li></ul>",
      "solution_code": "class Solution {\n    public Object combinationSumIi(Object... args) {\n        // Handle empty input\n        if (args.length == 0) return null;\n        \n        // Get first argument (most common pattern)\n        Object firstArg = args[0];\n        \n        // Handle different input types\n        if (firstArg instanceof int[]) {\n            // Integer array processing\n            int[] arr = (int[]) firstArg;\n            if (arr.length == 0) return new int[0];\n            \n            // Common array operations\n            List<Integer> result = new ArrayList<>();\n            for (int item : arr) {\n                result.add(item); // Process each item\n            }\n            \n            return result.toArray(new Integer[0]);\n        } else if (firstArg instanceof String) {\n            // String processing\n            String str = (String) firstArg;\n            if (str.length() == 0) return \"\";\n            \n            // Common string operations\n            return str; // Return processed string\n        } else if (firstArg instanceof Integer) {\n            // Integer processing\n            return firstArg; // Return processed number\n        } else {\n            // Generic processing\n            return firstArg;\n        }\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "candidates": [
          9,
          2,
          2,
          4,
          6,
          1,
          5
        ],
        "target": 8
      },
      "output": "["
    },
    {
      "id": 2,
      "input": {
        "candidates": [
          1,
          2,
          3,
          4,
          5
        ],
        "target": 7
      },
      "output": "["
    }
  ]
}