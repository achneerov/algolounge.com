{
  "filename": "combination-target-sum-ii",
  "title": "Combination Sum II",
  "keywords": [
    "combination",
    "sum",
    "leetcode",
    "given",
    "array",
    "integers",
    "candidates",
    "which",
    "contain",
    "duplicates"
  ],
  "description": "<h2>Combination Sum II</h2><p>Leetcode 40. Combination Sum II</p><p></p><p>You are given an array of integers `candidates`, which may contain duplicates, and a target integer `target`. Your task is to return a list of all **unique combinations** of `candidates` where the chosen numbers sum to `target`.</p><p></p><p>Each element from `candidates` may be chosen **at most once** within a combination. The solution set must not contain duplicate combinations.</p><p></p><p>You may return the combinations in **any order** and the order of the numbers in each combination can be in **any order**.</p><h3>Examples:</h3><ul><li>Input: candidates = [9,2,2,4,6,1,5], target = 8<br><br>Output: [<br>  [1,2,5],<br>  [2,2,4],<br>  [2,6]<br>]</li><li>Input: candidates = [1,2,3,4,5], target = 7<br><br>Output: [<br>  [1,2,4],<br>  [2,5],<br>  [3,4]<br>]</li></ul><h3>Constraints:</h3><ul><li> `1 <= candidates.length <= 100`</li><li> `1 <= candidates[i] <= 50`</li><li> `1 <= target <= 30`</li></ul>",
  "entry_function": "combinationSumIi",
  "template": "def combinationSumIi(candidates, target):\n    ",
  "solution_text": "<h3>Combination Sum II</h3><p><strong>Algorithm:</strong></p><ol><li>Sort candidates array to handle duplicates efficiently</li><li>Use backtracking to explore all possible combinations</li><li>Skip duplicate elements at the same recursion level</li><li>Each element can be used at most once in each combination</li><li>Add valid combinations to result when target sum is reached</li></ol><p><strong>Time Complexity:</strong> O(2^n) - in worst case, we explore all subsets</p><p><strong>Space Complexity:</strong> O(target) - recursion depth and current path storage</p><p><strong>Key Insights:</strong></p><ul><li>Sorting helps group duplicates together for efficient skipping</li><li>Skip duplicates: if i > start and candidates[i] == candidates[i-1], continue</li><li>Use start index to ensure each element is used at most once</li><li>Backtrack by removing elements from current path</li></ul>",
  "solution_code": "def combinationSumIi(candidates, target):\n    def backtrack(start, current_sum, path):\n        if current_sum == target:\n            result.append(path[:])\n            return\n        if current_sum > target:\n            return\n        \n        for i in range(start, len(candidates)):\n            # Skip duplicates at same recursion level\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            \n            path.append(candidates[i])\n            backtrack(i + 1, current_sum + candidates[i], path)\n            path.pop()\n    \n    candidates.sort()  # Sort to handle duplicates\n    result = []\n    backtrack(0, 0, [])\n    return result",
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "candidates": [
          9,
          2,
          2,
          4,
          6,
          1,
          5
        ],
        "target": 8
      },
      "output": "["
    },
    {
      "id": 2,
      "input": {
        "candidates": [
          1,
          2,
          3,
          4,
          5
        ],
        "target": 7
      },
      "output": "["
    }
  ]
}