{
  "filename": "k-closest-points-to-origin",
  "title": "K Closest Points to Origin",
  "keywords": [
    "closest",
    "points",
    "origin",
    "leetcode",
    "973",
    "given",
    "array",
    "where",
    "represents",
    "coordinates"
  ],
  "description": "<h2>K Closest Points to Origin</h2><p>Leetcode 973. K Closest Points to Origin</p><p></p><p>You are given an 2-D array `points` where `points[i] = [xi, yi]` represents the coordinates of a point on an X-Y axis plane. You are also given an integer `k`.</p><p>    </p><p>Return the `k` closest points to the origin `(0, 0)`. </p><p></p><p>The distance between two points is defined as the Euclidean distance (`sqrt((x1 - x2)^2 + (y1 - y2)^2))`.</p><p></p><p>You may return the answer in **any order**.</p><h3>Examples:</h3><ul><li>Input: points = [[0,2],[2,0],[2,2]], k = 2<br><br>Output: [[0,2],[2,0]]<br>The output `[2,0],[0,2]` would also be accepted.</li></ul><h3>Constraints:</h3><ul><li> `1 <= k <= points.length <= 1000`</li><li> `-100 <= points[i][0], points[i][1] <= 100`</li></ul>",
  "languages": {
    "python": {
      "template": "def kClosestPointsToOrigin(points, k):\n    ",
      "solution_text": "<p><strong>K Closest Points to Origin - Min Heap:</strong></p><p>Find k closest points using efficient heap-based approach.</p><p><strong>Algorithm:</strong></p><ol><li>Calculate squared distance for each point (avoid sqrt for efficiency)</li><li>Use min heap to store points with their distances</li><li>Extract k smallest elements from heap</li><li>Return the k closest points</li></ol><p><strong>Time Complexity:</strong> O(n log n) - heap operations</p><p><strong>Space Complexity:</strong> O(n) - heap storage</p>",
      "solution_code": "def kClosestPointsToOrigin(points, k):\n    import heapq\n    \n    # Calculate squared distance to avoid sqrt\n    def distance_squared(point):\n        return point[0] ** 2 + point[1] ** 2\n    \n    # Create heap of (distance, point) tuples\n    heap = []\n    for point in points:\n        dist = distance_squared(point)\n        heapq.heappush(heap, (dist, point))\n    \n    # Extract k closest points\n    result = []\n    for _ in range(k):\n        _, point = heapq.heappop(heap)\n        result.append(point)\n    \n    return result"
    },
    "javascript": {
      "template": "function kClosestPointsToOrigin(points, k) {\n  \n}",
      "solution_text": "<p><strong>K Closest Points to Origin - Min Heap:</strong></p><p>Find k closest points using efficient heap-based approach.</p><p><strong>Algorithm:</strong></p><ol><li>Calculate squared distance for each point (avoid sqrt for efficiency)</li><li>Use min heap to store points with their distances</li><li>Extract k smallest elements from heap</li><li>Return the k closest points</li></ol><p><strong>Time Complexity:</strong> O(n log n) - heap operations</p><p><strong>Space Complexity:</strong> O(n) - heap storage</p>",
      "solution_code": "function kClosestPointsToOrigin(points, k) {\n    // Calculate squared distance to avoid sqrt\n    const distanceSquared = (point) => {\n        return point[0] * point[0] + point[1] * point[1];\n    };\n    \n    // Create array of [distance, point] pairs and sort\n    const pointsWithDistance = points.map(point => [distanceSquared(point), point]);\n    pointsWithDistance.sort((a, b) => a[0] - b[0]);\n    \n    // Extract k closest points\n    const result = [];\n    for (let i = 0; i < k; i++) {\n        result.push(pointsWithDistance[i][1]);\n    }\n    \n    return result;\n}"
    },
    "typescript": {
      "template": "function kClosestPointsToOrigin(points: number[][], k: number): number[][] {\n  \n}",
      "solution_text": "<p><strong>K Closest Points to Origin - Min Heap:</strong></p><p>Find k closest points using efficient heap-based approach.</p><p><strong>Algorithm:</strong></p><ol><li>Calculate squared distance for each point (avoid sqrt for efficiency)</li><li>Use min heap to store points with their distances</li><li>Extract k smallest elements from heap</li><li>Return the k closest points</li></ol><p><strong>Time Complexity:</strong> O(n log n) - heap operations</p><p><strong>Space Complexity:</strong> O(n) - heap storage</p>",
      "solution_code": "function kClosestPointsToOrigin(points: number[][], k: number): number[][] {\n    // Calculate squared distance to avoid sqrt\n    const distanceSquared = (point: number[]): number => {\n        return point[0] * point[0] + point[1] * point[1];\n    };\n    \n    // Create array of [distance, point] pairs and sort\n    const pointsWithDistance: [number, number[]][] = points.map(point => [distanceSquared(point), point]);\n    pointsWithDistance.sort((a, b) => a[0] - b[0]);\n    \n    // Extract k closest points\n    const result: number[][] = [];\n    for (let i = 0; i < k; i++) {\n        result.push(pointsWithDistance[i][1]);\n    }\n    \n    return result;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int[][] kClosestPointsToOrigin(int[][] points, int k) {\n        \n    }\n}",
      "solution_text": "<p><strong>K Closest Points to Origin - Min Heap:</strong></p><p>Find k closest points using efficient heap-based approach.</p><p><strong>Algorithm:</strong></p><ol><li>Calculate squared distance for each point (avoid sqrt for efficiency)</li><li>Use min heap to store points with their distances</li><li>Extract k smallest elements from heap</li><li>Return the k closest points</li></ol><p><strong>Time Complexity:</strong> O(n log n) - heap operations</p><p><strong>Space Complexity:</strong> O(n) - heap storage</p>",
      "solution_code": "class Solution {\n    public int[][] kClosestPointsToOrigin(int[][] points, int k) {\n        // Calculate squared distance to avoid sqrt\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> \n            Integer.compare(a[0] * a[0] + a[1] * a[1], b[0] * b[0] + b[1] * b[1])\n        );\n        \n        // Add all points to min heap\n        for (int[] point : points) {\n            heap.offer(point);\n        }\n        \n        // Extract k closest points\n        int[][] result = new int[k][];\n        for (int i = 0; i < k; i++) {\n            result[i] = heap.poll();\n        }\n        \n        return result;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "points": [[0, 2], [2, 0], [2, 2]],
        "k": 2
      },
      "output": [[0, 2], [2, 0]]
    },
    {
      "id": 2,
      "input": {
        "points": [[1, 1], [3, 3], [2, 2]],
        "k": 2
      },
      "output": [[1, 1], [2, 2]]
    },
    {
      "id": 3,
      "input": {
        "points": [[0, 0]],
        "k": 1
      },
      "output": [[0, 0]]
    },
    {
      "id": 4,
      "input": {
        "points": [[1, 0], [2, 0], [0, 1], [0, 2]],
        "k": 2
      },
      "output": [[1, 0], [0, 1]]
    },
    {
      "id": 5,
      "input": {
        "points": [[3, 4], [5, 0], [0, 0]],
        "k": 1
      },
      "output": [[0, 0]]
    },
    {
      "id": 6,
      "input": {
        "points": [[1, 1], [1, -1], [-1, 1], [-1, -1]],
        "k": 2
      },
      "output": [[1, 1], [1, -1]]
    },
    {
      "id": 7,
      "input": {
        "points": [[10, 10], [1, 1], [5, 5], [2, 2]],
        "k": 3
      },
      "output": [[1, 1], [2, 2], [5, 5]]
    },
    {
      "id": 8,
      "input": {
        "points": [[-5, 4], [4, 6], [-1, -1], [1, -1]],
        "k": 2
      },
      "output": [[-1, -1], [1, -1]]
    },
    {
      "id": 9,
      "input": {
        "points": [[6, 10], [-3, 2], [0, 0], [2, 2]],
        "k": 3
      },
      "output": [[0, 0], [2, 2], [-3, 2]]
    },
    {
      "id": 10,
      "input": {
        "points": [[1, 3], [-2, 2], [5, 8], [0, 1]],
        "k": 4
      },
      "output": [[0, 1], [-2, 2], [1, 3], [5, 8]]
    }
  ]
}