{
  "filename": "matchsticks-to-square",
  "title": "Matchsticks to Square",
  "keywords": [
    "matchsticks",
    "square",
    "leetcode",
    "473",
    "backtracking",
    "dfs",
    "recursion",
    "partition"
  ],
  "description": "<h2>Matchsticks to Square</h2><p>Leetcode 473. Matchsticks to Square</p><p>You are given an integer array <code>matchsticks</code> where <code>matchsticks[i]</code> is the length of the <code>ith</code> matchstick. You need to use all the matchsticks to make one square. You should <strong>not break</strong> any stick, but you can link them up, and each matchstick must be used exactly one time.</p><p>Return <code>true</code> if you can make this square and <code>false</code> otherwise.</p><h3>Examples:</h3><ul><li><strong>Input:</strong> matchsticks = [1,3,4,2,2,4]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> You can form a square with side length 4.</li><li><strong>Input:</strong> matchsticks = [1,5,6,3]<br><strong>Output:</strong> false<br><strong>Explanation:</strong> You cannot form a square with these matchsticks.</li></ul><h3>Constraints:</h3><ul><li><code>1 <= matchsticks.length <= 15</code></li><li><code>1 <= matchsticks[i] <= 100,000,000</code></li></ul>",
  "languages": {
    "python": {
      "template": "def matchsticksToSquare(matchsticks):\n    ",
      "solution_text": "<h3>Backtracking Solution for Matchsticks to Square</h3><p>Use backtracking to try placing each matchstick into one of four sides of the square.</p><h4>Algorithm:</h4><ol><li>Calculate required side length (sum / 4)</li><li>Sort matchsticks in descending order for pruning</li><li>Use backtracking to assign each matchstick to a side</li><li>Prune when any side exceeds target length</li></ol><h4>Time Complexity:</h4><p>O(4^n) in worst case, but pruning significantly reduces search space</p><h4>Space Complexity:</h4><p>O(n) for recursion stack</p><h4>Key Insights:</h4><ul><li>Early termination when sum is not divisible by 4</li><li>Sorting helps with pruning larger matchsticks first</li><li>Track current length of each of the 4 sides</li></ul>",
      "solution_code": "def matchsticksToSquare(matchsticks):\n    if not matchsticks:\n        return False\n    \n    total = sum(matchsticks)\n    if total % 4 != 0:\n        return False\n    \n    side_length = total // 4\n    # Sort in descending order for better pruning\n    matchsticks.sort(reverse=True)\n    \n    # If any matchstick is longer than side, impossible\n    if matchsticks[0] > side_length:\n        return False\n    \n    # Track current length of each side\n    sides = [0, 0, 0, 0]\n    \n    def backtrack(index):\n        if index == len(matchsticks):\n            return all(side == side_length for side in sides)\n        \n        for i in range(4):\n            if sides[i] + matchsticks[index] <= side_length:\n                sides[i] += matchsticks[index]\n                if backtrack(index + 1):\n                    return True\n                sides[i] -= matchsticks[index]\n                \n                # Optimization: if current side is empty, no point trying other empty sides\n                if sides[i] == 0:\n                    break\n        \n        return False\n    \n    return backtrack(0)"
    },
    "javascript": {
      "template": "function matchsticksToSquare(matchsticks) {\n  \n}",
      "solution_text": "<h3>Backtracking Solution for Matchsticks to Square</h3><p>Use backtracking to try placing each matchstick into one of four sides of the square.</p><h4>Algorithm:</h4><ol><li>Calculate required side length (sum / 4)</li><li>Sort matchsticks in descending order for pruning</li><li>Use backtracking to assign each matchstick to a side</li><li>Prune when any side exceeds target length</li></ol><h4>Time Complexity:</h4><p>O(4^n) in worst case, but pruning significantly reduces search space</p><h4>Space Complexity:</h4><p>O(n) for recursion stack</p><h4>Key Insights:</h4><ul><li>Early termination when sum is not divisible by 4</li><li>Sorting helps with pruning larger matchsticks first</li><li>Track current length of each of the 4 sides</li></ul>",
      "solution_code": "function matchsticksToSquare(matchsticks) {\n    if (!matchsticks || matchsticks.length === 0) {\n        return false;\n    }\n    \n    const total = matchsticks.reduce((sum, stick) => sum + stick, 0);\n    if (total % 4 !== 0) {\n        return false;\n    }\n    \n    const sideLength = total / 4;\n    // Sort in descending order for better pruning\n    matchsticks.sort((a, b) => b - a);\n    \n    // If any matchstick is longer than side, impossible\n    if (matchsticks[0] > sideLength) {\n        return false;\n    }\n    \n    // Track current length of each side\n    const sides = [0, 0, 0, 0];\n    \n    function backtrack(index) {\n        if (index === matchsticks.length) {\n            return sides.every(side => side === sideLength);\n        }\n        \n        for (let i = 0; i < 4; i++) {\n            if (sides[i] + matchsticks[index] <= sideLength) {\n                sides[i] += matchsticks[index];\n                if (backtrack(index + 1)) {\n                    return true;\n                }\n                sides[i] -= matchsticks[index];\n                \n                // Optimization: if current side is empty, no point trying other empty sides\n                if (sides[i] === 0) {\n                    break;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    return backtrack(0);\n}"
    },
    "typescript": {
      "template": "function matchsticksToSquare(matchsticks: number[]): boolean {\n  \n}",
      "solution_text": "<h3>Backtracking Solution for Matchsticks to Square</h3><p>Use backtracking to try placing each matchstick into one of four sides of the square.</p><h4>Algorithm:</h4><ol><li>Calculate required side length (sum / 4)</li><li>Sort matchsticks in descending order for pruning</li><li>Use backtracking to assign each matchstick to a side</li><li>Prune when any side exceeds target length</li></ol><h4>Time Complexity:</h4><p>O(4^n) in worst case, but pruning significantly reduces search space</p><h4>Space Complexity:</h4><p>O(n) for recursion stack</p><h4>Key Insights:</h4><ul><li>Early termination when sum is not divisible by 4</li><li>Sorting helps with pruning larger matchsticks first</li><li>Track current length of each of the 4 sides</li></ul>",
      "solution_code": "function matchsticksToSquare(matchsticks: number[]): boolean {\n    if (!matchsticks || matchsticks.length === 0) {\n        return false;\n    }\n    \n    const total = matchsticks.reduce((sum, stick) => sum + stick, 0);\n    if (total % 4 !== 0) {\n        return false;\n    }\n    \n    const sideLength = total / 4;\n    // Sort in descending order for better pruning\n    matchsticks.sort((a, b) => b - a);\n    \n    // If any matchstick is longer than side, impossible\n    if (matchsticks[0] > sideLength) {\n        return false;\n    }\n    \n    // Track current length of each side\n    const sides = [0, 0, 0, 0];\n    \n    function backtrack(index: number): boolean {\n        if (index === matchsticks.length) {\n            return sides.every(side => side === sideLength);\n        }\n        \n        for (let i = 0; i < 4; i++) {\n            if (sides[i] + matchsticks[index] <= sideLength) {\n                sides[i] += matchsticks[index];\n                if (backtrack(index + 1)) {\n                    return true;\n                }\n                sides[i] -= matchsticks[index];\n                \n                // Optimization: if current side is empty, no point trying other empty sides\n                if (sides[i] === 0) {\n                    break;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    return backtrack(0);\n}"
    },
    "java": {
      "template": "class Solution {\n    public boolean matchsticksToSquare(int[] matchsticks) {\n        \n    }\n}",
      "solution_text": "<h3>Backtracking Solution for Matchsticks to Square</h3><p>Use backtracking to try placing each matchstick into one of four sides of the square.</p><h4>Algorithm:</h4><ol><li>Calculate required side length (sum / 4)</li><li>Sort matchsticks in descending order for pruning</li><li>Use backtracking to assign each matchstick to a side</li><li>Prune when any side exceeds target length</li></ol><h4>Time Complexity:</h4><p>O(4^n) in worst case, but pruning significantly reduces search space</p><h4>Space Complexity:</h4><p>O(n) for recursion stack</p><h4>Key Insights:</h4><ul><li>Early termination when sum is not divisible by 4</li><li>Sorting helps with pruning larger matchsticks first</li><li>Track current length of each of the 4 sides</li></ul>",
      "solution_code": "import java.util.Arrays;\n\nclass Solution {\n    public boolean matchsticksToSquare(int[] matchsticks) {\n        if (matchsticks == null || matchsticks.length == 0) {\n            return false;\n        }\n        \n        int total = 0;\n        for (int stick : matchsticks) {\n            total += stick;\n        }\n        \n        if (total % 4 != 0) {\n            return false;\n        }\n        \n        int sideLength = total / 4;\n        \n        // Sort in descending order for better pruning\n        Arrays.sort(matchsticks);\n        for (int i = 0; i < matchsticks.length / 2; i++) {\n            int temp = matchsticks[i];\n            matchsticks[i] = matchsticks[matchsticks.length - 1 - i];\n            matchsticks[matchsticks.length - 1 - i] = temp;\n        }\n        \n        // If any matchstick is longer than side, impossible\n        if (matchsticks[0] > sideLength) {\n            return false;\n        }\n        \n        // Track current length of each side\n        int[] sides = new int[4];\n        \n        return backtrack(matchsticks, sides, 0, sideLength);\n    }\n    \n    private boolean backtrack(int[] matchsticks, int[] sides, int index, int sideLength) {\n        if (index == matchsticks.length) {\n            return sides[0] == sideLength && sides[1] == sideLength && \n                   sides[2] == sideLength && sides[3] == sideLength;\n        }\n        \n        for (int i = 0; i < 4; i++) {\n            if (sides[i] + matchsticks[index] <= sideLength) {\n                sides[i] += matchsticks[index];\n                if (backtrack(matchsticks, sides, index + 1, sideLength)) {\n                    return true;\n                }\n                sides[i] -= matchsticks[index];\n                \n                // Optimization: if current side is empty, no point trying other empty sides\n                if (sides[i] == 0) {\n                    break;\n                }\n            }\n        }\n        \n        return false;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "matchsticks": [1,3,4,2,2,4]
      },
      "output": true
    },
    {
      "id": 2,
      "input": {
        "matchsticks": [1,5,6,3]
      },
      "output": false
    },
    {
      "id": 3,
      "input": {
        "matchsticks": [1,1,1,1]
      },
      "output": true
    },
    {
      "id": 4,
      "input": {
        "matchsticks": [3,3,3,3,4]
      },
      "output": false
    },
    {
      "id": 5,
      "input": {
        "matchsticks": [1]
      },
      "output": false
    },
    {
      "id": 6,
      "input": {
        "matchsticks": [5,5,5,5,4,4,4,4,3,3,3,3]
      },
      "output": true
    },
    {
      "id": 7,
      "input": {
        "matchsticks": [2,2,2,2,2,6]
      },
      "output": false
    },
    {
      "id": 8,
      "input": {
        "matchsticks": [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
      },
      "output": false
    },
    {
      "id": 9,
      "input": {
        "matchsticks": [4,4,4,4]
      },
      "output": true
    },
    {
      "id": 10,
      "input": {
        "matchsticks": [1,2,3,6]
      },
      "output": true
    }
  ]
}