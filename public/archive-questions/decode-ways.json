{
  "filename": "decode-ways",
  "title": "Decode Ways",
  "keywords": [
    "decode",
    "ways",
    "leetcode",
    "string",
    "consisting",
    "uppercase",
    "english",
    "characters",
    "encoded",
    "number"
  ],
  "description": "<h2>Decode Ways</h2><p>Leetcode 91. Decode Ways</p><p></p><p>A string consisting of uppercase english characters can be encoded to a number using the following mapping:</p><p></p><p>```java</p><p>'A' -> \"1\"</p><p>'B' -> \"2\"</p><p>...</p><p>'Z' -> \"26\"</p><p>```</p><p></p><p>To **decode** a message, digits must be grouped and then mapped back into letters using the reverse of the mapping above. There may be multiple ways to decode a message. For example, `\"1012\"` can be mapped into:</p><p></p><p>* `\"JAB\"` with the grouping `(10 1 2)`</p><p>* `\"JL\"` with the grouping `(10 12)`</p><p></p><p>The grouping `(1 01 2)` is invalid because `01` cannot be mapped into a letter since it contains a leading zero.</p><p></p><p>Given a string `s` containing only digits, return the number of ways to **decode** it. You can assume that the answer fits in a **32-bit** integer.</p><h3>Examples:</h3><ul><li>Input: s = \"12\"<br><br>Output: 2<br><br>Explanation: \"12\" could be decoded as \"AB\" (1 2) or \"L\" (12).</li><li>Input: s = \"01\"<br><br>Output: 0<br>\"01\" cannot be decoded because \"01\" cannot be mapped into a letter.</li></ul><h3>Constraints:</h3><ul><li> `1 <= s.length <= 100`</li><li> `s` consists of digits</li></ul>",
  "languages": {
    "python": {
      "template": "def decodeWays(s):\n    ",
      "solution_text": "<p><strong>Dynamic Programming Solution for Decode Ways:</strong></p><p>Count number of ways to decode a string using bottom-up DP.</p><p><strong>Algorithm:</strong></p><ol><li>Use DP array where dp[i] = ways to decode s[0:i]</li><li>For single digit: if s[i-1] != '0', add dp[i-1]</li><li>For two digits: if 10 ≤ s[i-2:i] ≤ 26, add dp[i-2]</li><li>Handle edge cases: leading zeros, invalid combinations</li></ol><p><strong>Time Complexity:</strong> O(n) - single pass through string</p><p><strong>Space Complexity:</strong> O(n) or O(1) with space optimization</p>",
      "solution_code": "def decodeWays(s):\n    if not s or s[0] == '0':\n        return 0\n    \n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = dp[1] = 1\n    \n    for i in range(2, n + 1):\n        # Single digit\n        if s[i-1] != '0':\n            dp[i] += dp[i-1]\n        \n        # Two digits\n        two_digit = int(s[i-2:i])\n        if 10 <= two_digit <= 26:\n            dp[i] += dp[i-2]\n    \n    return dp[n]"
    },
    "javascript": {
      "template": "function decodeWays(s) {\n  \n}",
      "solution_text": "<p><strong>Dynamic Programming Solution for Decode Ways:</strong></p><p>Count number of ways to decode a string using bottom-up DP.</p><p><strong>Algorithm:</strong></p><ol><li>Use DP array where dp[i] = ways to decode s[0:i]</li><li>For single digit: if s[i-1] != '0', add dp[i-1]</li><li>For two digits: if 10 ≤ s[i-2:i] ≤ 26, add dp[i-2]</li><li>Handle edge cases: leading zeros, invalid combinations</li></ol><p><strong>Time Complexity:</strong> O(n) - single pass through string</p><p><strong>Space Complexity:</strong> O(n) or O(1) with space optimization</p>",
      "solution_code": "function decodeWays(s) {\n    if (!s || s[0] === '0') return 0;\n    \n    const n = s.length;\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = dp[1] = 1;\n    \n    for (let i = 2; i <= n; i++) {\n        // Single digit\n        if (s[i-1] !== '0') {\n            dp[i] += dp[i-1];\n        }\n        \n        // Two digits\n        const twoDigit = parseInt(s.substring(i-2, i));\n        if (twoDigit >= 10 && twoDigit <= 26) {\n            dp[i] += dp[i-2];\n        }\n    }\n    \n    return dp[n];\n}"
    },
    "typescript": {
      "template": "function decodeWays(s: string): number {\n  \n}",
      "solution_text": "<p><strong>Dynamic Programming Solution for Decode Ways:</strong></p><p>Count number of ways to decode a string using bottom-up DP.</p><p><strong>Algorithm:</strong></p><ol><li>Use DP array where dp[i] = ways to decode s[0:i]</li><li>For single digit: if s[i-1] != '0', add dp[i-1]</li><li>For two digits: if 10 ≤ s[i-2:i] ≤ 26, add dp[i-2]</li><li>Handle edge cases: leading zeros, invalid combinations</li></ol><p><strong>Time Complexity:</strong> O(n) - single pass through string</p><p><strong>Space Complexity:</strong> O(n) or O(1) with space optimization</p>",
      "solution_code": "function decodeWays(s: string): number {\n    if (!s || s[0] === '0') return 0;\n    \n    const n = s.length;\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = dp[1] = 1;\n    \n    for (let i = 2; i <= n; i++) {\n        // Single digit\n        if (s[i-1] !== '0') {\n            dp[i] += dp[i-1];\n        }\n        \n        // Two digits\n        const twoDigit = parseInt(s.substring(i-2, i));\n        if (twoDigit >= 10 && twoDigit <= 26) {\n            dp[i] += dp[i-2];\n        }\n    }\n    \n    return dp[n];\n}"
    },
    "java": {
      "template": "class Solution {\n    public int decodeWays(String s) {\n        \n    }\n}",
      "solution_text": "<p><strong>Dynamic Programming Solution for Decode Ways:</strong></p><p>Count number of ways to decode a string using bottom-up DP.</p><p><strong>Algorithm:</strong></p><ol><li>Use DP array where dp[i] = ways to decode s[0:i]</li><li>For single digit: if s[i-1] != '0', add dp[i-1]</li><li>For two digits: if 10 ≤ s[i-2:i] ≤ 26, add dp[i-2]</li><li>Handle edge cases: leading zeros, invalid combinations</li></ol><p><strong>Time Complexity:</strong> O(n) - single pass through string</p><p><strong>Space Complexity:</strong> O(n) or O(1) with space optimization</p>",
      "solution_code": "class Solution {\n    public int decodeWays(String s) {\n        if (s == null || s.length() == 0 || s.charAt(0) == '0') return 0;\n        \n        int n = s.length();\n        int[] dp = new int[n + 1];\n        dp[0] = dp[1] = 1;\n        \n        for (int i = 2; i <= n; i++) {\n            // Single digit\n            if (s.charAt(i-1) != '0') {\n                dp[i] += dp[i-1];\n            }\n            \n            // Two digits\n            int twoDigit = Integer.parseInt(s.substring(i-2, i));\n            if (twoDigit >= 10 && twoDigit <= 26) {\n                dp[i] += dp[i-2];\n            }\n        }\n        \n        return dp[n];\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "s": "12"
      },
      "output": 2
    },
    {
      "id": 2,
      "input": {
        "s": "01"
      },
      "output": 0
    },
    {
      "id": 3,
      "input": {
        "s": "226"
      },
      "output": 3
    },
    {
      "id": 4,
      "input": {
        "s": "0"
      },
      "output": 0
    },
    {
      "id": 5,
      "input": {
        "s": "1"
      },
      "output": 1
    },
    {
      "id": 6,
      "input": {
        "s": "11106"
      },
      "output": 2
    },
    {
      "id": 7,
      "input": {
        "s": "2101"
      },
      "output": 1
    },
    {
      "id": 8,
      "input": {
        "s": "1201234"
      },
      "output": 3
    },
    {
      "id": 9,
      "input": {
        "s": "27"
      },
      "output": 1
    },
    {
      "id": 10,
      "input": {
        "s": "10"
      },
      "output": 1
    }
  ]
}