{
  "filename": "edit-distance",
  "title": "Edit Distance",
  "keywords": [
    "edit",
    "distance",
    "leetcode",
    "given",
    "two",
    "strings",
    "word1",
    "word2",
    "each",
    "consisting"
  ],
  "description": "<h2>Edit Distance</h2><p>Leetcode 72. Edit Distance</p><p></p><p>You are given two strings `word1` and `word2`, each consisting of lowercase English letters.</p><p></p><p>You are allowed to perform three operations on `word1` an unlimited number of times:</p><p></p><p>* Insert a character at any position</p><p>* Delete a character at any position</p><p>* Replace a character at any position</p><p></p><p>Return the minimum number of operations to make `word1` equal `word2`.</p><h3>Examples:</h3><ul><li>Input: word1 = \"monkeys\", word2 = \"money\"<br><br>Output: 2<br>`monkeys` -> `monkey` (remove `s`)\n`monkey` -> `monkey`  (remove `k`)</li><li>Input: word1 = \"neatcdee\", word2 = \"neetcode\"<br><br>Output: 3<br>`neatcdee` -> `neetcdee`  (replace `a` with `e`)\n`neetcdee` -> `neetcde`   (remove last `e`)\n`neetcde`  -> `neetcode`  (insert `o`)</li></ul><h3>Constraints:</h3><ul><li> `0 <= word1.length, word2.length <= 100`</li><li> `word1` and `word2` consist of lowercase English letters.</li></ul>",
  "languages": {
    "python": {
      "template": "def editDistance(word1, word2):\n    ",
      "solution_text": "<p><strong>Dynamic Programming Solution for Edit Distance (Levenshtein Distance):</strong></p><p>Find minimum operations to transform one string to another using DP.</p><p><strong>Algorithm:</strong></p><ol><li>Create 2D DP table where dp[i][j] = min operations to convert word1[0:i] to word2[0:j]</li><li>Initialize base cases: dp[i][0] = i (delete all), dp[0][j] = j (insert all)</li><li>For each cell: if chars match, take diagonal; else take min of 3 operations + 1</li><li>Three operations: insert (left), delete (up), replace (diagonal)</li></ol><p><strong>Time Complexity:</strong> O(m × n) where m, n are string lengths</p><p><strong>Space Complexity:</strong> O(m × n) for DP table</p>",
      "solution_code": "def editDistance(word1, word2):\n    m, n = len(word1), len(word2)\n    \n    # Create DP table\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Initialize base cases\n    for i in range(m + 1):\n        dp[i][0] = i  # Delete all characters from word1\n    for j in range(n + 1):\n        dp[0][j] = j  # Insert all characters to make word2\n    \n    # Fill DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                # Characters match, no operation needed\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                # Take minimum of three operations\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],      # Delete\n                    dp[i][j - 1],      # Insert\n                    dp[i - 1][j - 1]   # Replace\n                )\n    \n    return dp[m][n]"
    },
    "javascript": {
      "template": "function editDistance(word1, word2) {\n  \n}",
      "solution_text": "<p><strong>Dynamic Programming Solution for Edit Distance (Levenshtein Distance):</strong></p><p>Find minimum operations to transform one string to another using DP.</p><p><strong>Algorithm:</strong></p><ol><li>Create 2D DP table where dp[i][j] = min operations to convert word1[0:i] to word2[0:j]</li><li>Initialize base cases: dp[i][0] = i (delete all), dp[0][j] = j (insert all)</li><li>For each cell: if chars match, take diagonal; else take min of 3 operations + 1</li><li>Three operations: insert (left), delete (up), replace (diagonal)</li></ol><p><strong>Time Complexity:</strong> O(m × n) where m, n are string lengths</p><p><strong>Space Complexity:</strong> O(m × n) for DP table</p>",
      "solution_code": "function editDistance(word1, word2) {\n    const m = word1.length, n = word2.length;\n    \n    // Create DP table\n    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));\n    \n    // Initialize base cases\n    for (let i = 0; i <= m; i++) {\n        dp[i][0] = i; // Delete all characters from word1\n    }\n    for (let j = 0; j <= n; j++) {\n        dp[0][j] = j; // Insert all characters to make word2\n    }\n    \n    // Fill DP table\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (word1[i - 1] === word2[j - 1]) {\n                // Characters match, no operation needed\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                // Take minimum of three operations\n                dp[i][j] = 1 + Math.min(\n                    dp[i - 1][j],      // Delete\n                    dp[i][j - 1],      // Insert\n                    dp[i - 1][j - 1]   // Replace\n                );\n            }\n        }\n    }\n    \n    return dp[m][n];\n}"
    },
    "typescript": {
      "template": "function editDistance(word1: string, word2: string): number {\n  \n}",
      "solution_text": "<p><strong>Dynamic Programming Solution for Edit Distance (Levenshtein Distance):</strong></p><p>Find minimum operations to transform one string to another using DP.</p><p><strong>Algorithm:</strong></p><ol><li>Create 2D DP table where dp[i][j] = min operations to convert word1[0:i] to word2[0:j]</li><li>Initialize base cases: dp[i][0] = i (delete all), dp[0][j] = j (insert all)</li><li>For each cell: if chars match, take diagonal; else take min of 3 operations + 1</li><li>Three operations: insert (left), delete (up), replace (diagonal)</li></ol><p><strong>Time Complexity:</strong> O(m × n) where m, n are string lengths</p><p><strong>Space Complexity:</strong> O(m × n) for DP table</p>",
      "solution_code": "function editDistance(word1: string, word2: string): number {\n    const m = word1.length, n = word2.length;\n    \n    // Create DP table\n    const dp: number[][] = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n    \n    // Initialize base cases\n    for (let i = 0; i <= m; i++) {\n        dp[i][0] = i; // Delete all characters from word1\n    }\n    for (let j = 0; j <= n; j++) {\n        dp[0][j] = j; // Insert all characters to make word2\n    }\n    \n    // Fill DP table\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (word1[i - 1] === word2[j - 1]) {\n                // Characters match, no operation needed\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                // Take minimum of three operations\n                dp[i][j] = 1 + Math.min(\n                    dp[i - 1][j],      // Delete\n                    dp[i][j - 1],      // Insert\n                    dp[i - 1][j - 1]   // Replace\n                );\n            }\n        }\n    }\n    \n    return dp[m][n];\n}"
    },
    "java": {
      "template": "class Solution {\n    public int editDistance(String word1, String word2) {\n        \n    }\n}",
      "solution_text": "<p><strong>Dynamic Programming Solution for Edit Distance (Levenshtein Distance):</strong></p><p>Find minimum operations to transform one string to another using DP.</p><p><strong>Algorithm:</strong></p><ol><li>Create 2D DP table where dp[i][j] = min operations to convert word1[0:i] to word2[0:j]</li><li>Initialize base cases: dp[i][0] = i (delete all), dp[0][j] = j (insert all)</li><li>For each cell: if chars match, take diagonal; else take min of 3 operations + 1</li><li>Three operations: insert (left), delete (up), replace (diagonal)</li></ol><p><strong>Time Complexity:</strong> O(m × n) where m, n are string lengths</p><p><strong>Space Complexity:</strong> O(m × n) for DP table</p>",
      "solution_code": "class Solution {\n    public int editDistance(String word1, String word2) {\n        int m = word1.length(), n = word2.length();\n        \n        // Create DP table\n        int[][] dp = new int[m + 1][n + 1];\n        \n        // Initialize base cases\n        for (int i = 0; i <= m; i++) {\n            dp[i][0] = i; // Delete all characters from word1\n        }\n        for (int j = 0; j <= n; j++) {\n            dp[0][j] = j; // Insert all characters to make word2\n        }\n        \n        // Fill DP table\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                    // Characters match, no operation needed\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    // Take minimum of three operations\n                    dp[i][j] = 1 + Math.min(\n                        Math.min(dp[i - 1][j], dp[i][j - 1]), // Delete or Insert\n                        dp[i - 1][j - 1] // Replace\n                    );\n                }\n            }\n        }\n        \n        return dp[m][n];\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "word1": "monkeys",
        "word2": "money"
      },
      "output": 2
    },
    {
      "id": 2,
      "input": {
        "word1": "neatcdee",
        "word2": "neetcode"
      },
      "output": 3
    },
    {
      "id": 3,
      "input": {
        "word1": "horse",
        "word2": "ros"
      },
      "output": 3
    },
    {
      "id": 4,
      "input": {
        "word1": "intention",
        "word2": "execution"
      },
      "output": 5
    },
    {
      "id": 5,
      "input": {
        "word1": "",
        "word2": "abc"
      },
      "output": 3
    },
    {
      "id": 6,
      "input": {
        "word1": "abc",
        "word2": ""
      },
      "output": 3
    },
    {
      "id": 7,
      "input": {
        "word1": "same",
        "word2": "same"
      },
      "output": 0
    },
    {
      "id": 8,
      "input": {
        "word1": "kitten",
        "word2": "sitting"
      },
      "output": 3
    },
    {
      "id": 9,
      "input": {
        "word1": "saturday",
        "word2": "sunday"
      },
      "output": 3
    },
    {
      "id": 10,
      "input": {
        "word1": "ab",
        "word2": "ba"
      },
      "output": 2
    }
  ]
}