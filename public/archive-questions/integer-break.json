{
  "filename": "integer-break",
  "title": "Integer Break",
  "keywords": [
    "integer",
    "break",
    "leetcode",
    "343",
    "given",
    "into",
    "sum",
    "positive",
    "integers",
    "where"
  ],
  "description": "<h2>Integer Break</h2><p>Leetcode 343. Integer Break</p><p></p><p>You are given an integer `n`, break it into the sum of `k` **positive integers**, where `k >= 2`, and maximize the product of those integers.</p><p></p><p>Return the maximum product you can get.</p><h3>Examples:</h3><ul><li>Input: n = 4<br><br>Output: 4<br>4 = 2 + 2, 2 x 2 = 4.</li><li>Input: n = 12<br><br>Output: 81<br>12 = 3 + 3 + 3 + 3, 3 x 3 x 3 x 3 = 81.</li></ul><h3>Constraints:</h3><ul><li> `2 <= n <= 58`</li></ul>",
  "languages": {
    "python": {
      "template": "def integerBreak(n):\n    ",
      "solution_text": "<h3>Solution Approach</h3><p><strong>Algorithm:</strong><br/>We use mathematical insight that breaking into 3s gives the maximum product. The key observation is that for any number n ≥ 5, breaking it into parts of 3 yields better results than keeping it whole or breaking into 2s.</p><p><strong>Strategy:</strong><br/>1. Base cases: n=2 returns 1, n=3 returns 2, n=4 returns 4<br/>2. For n ≥ 5: break into as many 3s as possible<br/>3. Handle remainders: if remainder is 1, use one less 3 and add 4 (3+1=4, 3×1=3 but 2×2=4)<br/>4. If remainder is 2, just multiply by 2</p><p><strong>Time Complexity:</strong> O(1) - constant time mathematical solution</p><p><strong>Space Complexity:</strong> O(1) - constant space</p><p><strong>Key Insights:</strong><br/>- 3 is the optimal split size for maximizing product<br/>- For remainder 1: replace (3,1) with (2,2) since 2×2 > 3×1<br/>- Mathematical proof shows 3^(n//3) gives optimal results for most cases</p>",
      "solution_code": "def integerBreak(n):\n    if n == 2:\n        return 1\n    if n == 3:\n        return 2\n    if n == 4:\n        return 4\n    \n    # For n >= 5, break into 3s as much as possible\n    quotient = n // 3\n    remainder = n % 3\n    \n    if remainder == 0:\n        # Perfect division by 3\n        return 3 ** quotient\n    elif remainder == 1:\n        # Replace one 3 with two 2s (since 2*2 = 4 > 3*1 = 3)\n        return 3 ** (quotient - 1) * 4\n    else:  # remainder == 2\n        # Just multiply by the remaining 2\n        return 3 ** quotient * 2"
    },
    "javascript": {
      "template": "function integerBreak(n) {\n  \n}",
      "solution_text": "<h3>Solution Approach</h3><p><strong>Algorithm:</strong><br/>We use mathematical insight that breaking into 3s gives the maximum product. The key observation is that for any number n ≥ 5, breaking it into parts of 3 yields better results than keeping it whole or breaking into 2s.</p><p><strong>Strategy:</strong><br/>1. Base cases: n=2 returns 1, n=3 returns 2, n=4 returns 4<br/>2. For n ≥ 5: break into as many 3s as possible<br/>3. Handle remainders: if remainder is 1, use one less 3 and add 4 (3+1=4, 3×1=3 but 2×2=4)<br/>4. If remainder is 2, just multiply by 2</p><p><strong>Time Complexity:</strong> O(1) - constant time mathematical solution</p><p><strong>Space Complexity:</strong> O(1) - constant space</p><p><strong>Key Insights:</strong><br/>- 3 is the optimal split size for maximizing product<br/>- For remainder 1: replace (3,1) with (2,2) since 2×2 > 3×1<br/>- Mathematical proof shows 3^(n//3) gives optimal results for most cases</p>",
      "solution_code": "function integerBreak(n) {\n    if (n === 2) return 1;\n    if (n === 3) return 2;\n    if (n === 4) return 4;\n    \n    // For n >= 5, break into 3s as much as possible\n    const quotient = Math.floor(n / 3);\n    const remainder = n % 3;\n    \n    if (remainder === 0) {\n        // Perfect division by 3\n        return Math.pow(3, quotient);\n    } else if (remainder === 1) {\n        // Replace one 3 with two 2s (since 2*2 = 4 > 3*1 = 3)\n        return Math.pow(3, quotient - 1) * 4;\n    } else { // remainder === 2\n        // Just multiply by the remaining 2\n        return Math.pow(3, quotient) * 2;\n    }\n}"
    },
    "typescript": {
      "template": "function integerBreak(n: number): number {\n  \n}",
      "solution_text": "<h3>Solution Approach</h3><p><strong>Algorithm:</strong><br/>We use mathematical insight that breaking into 3s gives the maximum product. The key observation is that for any number n ≥ 5, breaking it into parts of 3 yields better results than keeping it whole or breaking into 2s.</p><p><strong>Strategy:</strong><br/>1. Base cases: n=2 returns 1, n=3 returns 2, n=4 returns 4<br/>2. For n ≥ 5: break into as many 3s as possible<br/>3. Handle remainders: if remainder is 1, use one less 3 and add 4 (3+1=4, 3×1=3 but 2×2=4)<br/>4. If remainder is 2, just multiply by 2</p><p><strong>Time Complexity:</strong> O(1) - constant time mathematical solution</p><p><strong>Space Complexity:</strong> O(1) - constant space</p><p><strong>Key Insights:</strong><br/>- 3 is the optimal split size for maximizing product<br/>- For remainder 1: replace (3,1) with (2,2) since 2×2 > 3×1<br/>- Mathematical proof shows 3^(n//3) gives optimal results for most cases</p>",
      "solution_code": "function integerBreak(n: number): number {\n    if (n === 2) return 1;\n    if (n === 3) return 2;\n    if (n === 4) return 4;\n    \n    // For n >= 5, break into 3s as much as possible\n    const quotient = Math.floor(n / 3);\n    const remainder = n % 3;\n    \n    if (remainder === 0) {\n        // Perfect division by 3\n        return Math.pow(3, quotient);\n    } else if (remainder === 1) {\n        // Replace one 3 with two 2s (since 2*2 = 4 > 3*1 = 3)\n        return Math.pow(3, quotient - 1) * 4;\n    } else { // remainder === 2\n        // Just multiply by the remaining 2\n        return Math.pow(3, quotient) * 2;\n    }\n}"
    },
    "java": {
      "template": "class Solution {\n    public int integerBreak(int n) {\n        \n    }\n}",
      "solution_text": "<h3>Solution Approach</h3><p><strong>Algorithm:</strong><br/>We use mathematical insight that breaking into 3s gives the maximum product. The key observation is that for any number n ≥ 5, breaking it into parts of 3 yields better results than keeping it whole or breaking into 2s.</p><p><strong>Strategy:</strong><br/>1. Base cases: n=2 returns 1, n=3 returns 2, n=4 returns 4<br/>2. For n ≥ 5: break into as many 3s as possible<br/>3. Handle remainders: if remainder is 1, use one less 3 and add 4 (3+1=4, 3×1=3 but 2×2=4)<br/>4. If remainder is 2, just multiply by 2</p><p><strong>Time Complexity:</strong> O(1) - constant time mathematical solution</p><p><strong>Space Complexity:</strong> O(1) - constant space</p><p><strong>Key Insights:</strong><br/>- 3 is the optimal split size for maximizing product<br/>- For remainder 1: replace (3,1) with (2,2) since 2×2 > 3×1<br/>- Mathematical proof shows 3^(n//3) gives optimal results for most cases</p>",
      "solution_code": "class Solution {\n    public int integerBreak(int n) {\n        if (n == 2) return 1;\n        if (n == 3) return 2;\n        if (n == 4) return 4;\n        \n        // For n >= 5, break into 3s as much as possible\n        int quotient = n / 3;\n        int remainder = n % 3;\n        \n        if (remainder == 0) {\n            // Perfect division by 3\n            return (int) Math.pow(3, quotient);\n        } else if (remainder == 1) {\n            // Replace one 3 with two 2s (since 2*2 = 4 > 3*1 = 3)\n            return (int) Math.pow(3, quotient - 1) * 4;\n        } else { // remainder == 2\n            // Just multiply by the remaining 2\n            return (int) Math.pow(3, quotient) * 2;\n        }\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": 2,
      "output": 1
    },
    {
      "id": 2,
      "input": 3,
      "output": 2
    },
    {
      "id": 3,
      "input": 4,
      "output": 4
    },
    {
      "id": 4,
      "input": 5,
      "output": 6
    },
    {
      "id": 5,
      "input": 6,
      "output": 9
    },
    {
      "id": 6,
      "input": 7,
      "output": 12
    },
    {
      "id": 7,
      "input": 8,
      "output": 18
    },
    {
      "id": 8,
      "input": 9,
      "output": 27
    },
    {
      "id": 9,
      "input": 10,
      "output": 36
    },
    {
      "id": 10,
      "input": 15,
      "output": 243
    }
  ]
}