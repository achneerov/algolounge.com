{
  "filename": "longest-common-subsequence",
  "title": "Longest Common Subsequence",
  "keywords": [
    "longest",
    "common",
    "subsequence",
    "leetcode",
    "1143",
    "given",
    "two",
    "strings",
    "text1",
    "text2"
  ],
  "description": "<h2>Longest Common Subsequence</h2><p>Leetcode 1143. Longest Common Subsequence</p><p>Given two strings <code>text1</code> and <code>text2</code>, return the length of the <em>longest common subsequence</em> between the two strings if one exists, otherwise return <code>0</code>.</p><p>A <strong>subsequence</strong> is a sequence that can be derived from the given sequence by deleting some or no elements without changing the relative order of the remaining characters.</p><p>For example, <code>\"cat\"</code> is a subsequence of <code>\"crabt\"</code>.</p><p>A <strong>common subsequence</strong> of two strings is a subsequence that exists in both strings.</p><h3>Examples</h3><ul><li>Input: text1 = \"cat\", text2 = \"crabt\"<br>Output: 3<br>The longest common subsequence is \"cat\" which has a length of 3.</li><li>Input: text1 = \"abcd\", text2 = \"abcd\"<br>Output: 4</li><li>Input: text1 = \"abcd\", text2 = \"efgh\"<br>Output: 0</li></ul><h3>Constraints</h3><ul><li><code>1 <= text1.length, text2.length <= 1000</code></li><li><code>text1</code> and <code>text2</code> consist of only lowercase English characters.</li></ul>",
  "languages": {
    "python": {
      "template": "def longestCommonSubsequence(text1, text2):\n    ",
      "solution_text": "Dynamic Programming solution for Longest Common Subsequence:\n\n**Algorithm:**\nUse a 2D DP table where dp[i][j] represents the length of LCS for the first i characters of text1 and first j characters of text2.\n\n**Recurrence Relation:**\n- If text1[i-1] == text2[j-1]: dp[i][j] = dp[i-1][j-1] + 1\n- Otherwise: dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\n**Time Complexity:** O(m * n) where m and n are lengths of the two strings\n**Space Complexity:** O(m * n) for the DP table\n\n**Key Insights:**\n- Bottom-up DP approach builds solution incrementally\n- Each cell represents optimal solution for subproblem\n- Final answer is in dp[m][n]",
      "solution_code": "def longestCommonSubsequence(text1, text2):\n    m, n = len(text1), len(text2)\n    \n    # Create a 2D DP table\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                # Characters match, extend previous LCS\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                # Characters don't match, take maximum from left or top\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    return dp[m][n]"
    },
    "javascript": {
      "template": "function longestCommonSubsequence(text1, text2) {\n  \n}",
      "solution_text": "Dynamic Programming solution for Longest Common Subsequence:\n\n**Algorithm:**\nUse a 2D DP table where dp[i][j] represents the length of LCS for the first i characters of text1 and first j characters of text2.\n\n**Recurrence Relation:**\n- If text1[i-1] == text2[j-1]: dp[i][j] = dp[i-1][j-1] + 1\n- Otherwise: dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\n**Time Complexity:** O(m * n) where m and n are lengths of the two strings\n**Space Complexity:** O(m * n) for the DP table\n\n**Key Insights:**\n- Bottom-up DP approach builds solution incrementally\n- Each cell represents optimal solution for subproblem\n- Final answer is in dp[m][n]",
      "solution_code": "function longestCommonSubsequence(text1, text2) {\n    const m = text1.length;\n    const n = text2.length;\n    \n    // Create a 2D DP table\n    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n    \n    // Fill the DP table\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (text1[i - 1] === text2[j - 1]) {\n                // Characters match, extend previous LCS\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                // Characters don't match, take maximum from left or top\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    \n    return dp[m][n];\n}"
    },
    "typescript": {
      "template": "function longestCommonSubsequence(text1: string, text2: string): number {\n  \n}",
      "solution_text": "Dynamic Programming solution for Longest Common Subsequence:\n\n**Algorithm:**\nUse a 2D DP table where dp[i][j] represents the length of LCS for the first i characters of text1 and first j characters of text2.\n\n**Recurrence Relation:**\n- If text1[i-1] == text2[j-1]: dp[i][j] = dp[i-1][j-1] + 1\n- Otherwise: dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\n**Time Complexity:** O(m * n) where m and n are lengths of the two strings\n**Space Complexity:** O(m * n) for the DP table\n\n**Key Insights:**\n- Bottom-up DP approach builds solution incrementally\n- Each cell represents optimal solution for subproblem\n- Final answer is in dp[m][n]",
      "solution_code": "function longestCommonSubsequence(text1: string, text2: string): number {\n    const m: number = text1.length;\n    const n: number = text2.length;\n    \n    // Create a 2D DP table\n    const dp: number[][] = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n    \n    // Fill the DP table\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (text1[i - 1] === text2[j - 1]) {\n                // Characters match, extend previous LCS\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                // Characters don't match, take maximum from left or top\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    \n    return dp[m][n];\n}"
    },
    "java": {
      "template": "class Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        \n    }\n}",
      "solution_text": "Dynamic Programming solution for Longest Common Subsequence:\n\n**Algorithm:**\nUse a 2D DP table where dp[i][j] represents the length of LCS for the first i characters of text1 and first j characters of text2.\n\n**Recurrence Relation:**\n- If text1[i-1] == text2[j-1]: dp[i][j] = dp[i-1][j-1] + 1\n- Otherwise: dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\n**Time Complexity:** O(m * n) where m and n are lengths of the two strings\n**Space Complexity:** O(m * n) for the DP table\n\n**Key Insights:**\n- Bottom-up DP approach builds solution incrementally\n- Each cell represents optimal solution for subproblem\n- Final answer is in dp[m][n]",
      "solution_code": "class Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        int m = text1.length();\n        int n = text2.length();\n        \n        // Create a 2D DP table\n        int[][] dp = new int[m + 1][n + 1];\n        \n        // Fill the DP table\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                    // Characters match, extend previous LCS\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    // Characters don't match, take maximum from left or top\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        \n        return dp[m][n];\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "text1": "cat",
        "text2": "crabt"
      },
      "output": 3
    },
    {
      "id": 2,
      "input": {
        "text1": "abcd",
        "text2": "abcd"
      },
      "output": 4
    },
    {
      "id": 3,
      "input": {
        "text1": "abcd",
        "text2": "efgh"
      },
      "output": 0
    },
    {
      "id": 4,
      "input": {
        "text1": "",
        "text2": "abc"
      },
      "output": 0
    },
    {
      "id": 5,
      "input": {
        "text1": "abc",
        "text2": ""
      },
      "output": 0
    },
    {
      "id": 6,
      "input": {
        "text1": "a",
        "text2": "a"
      },
      "output": 1
    },
    {
      "id": 7,
      "input": {
        "text1": "ace",
        "text2": "aec"
      },
      "output": 2
    },
    {
      "id": 8,
      "input": {
        "text1": "abcdef",
        "text2": "ace"
      },
      "output": 3
    },
    {
      "id": 9,
      "input": {
        "text1": "programming",
        "text2": "algorithm"
      },
      "output": 4
    },
    {
      "id": 10,
      "input": {
        "text1": "longestcommonsubsequence",
        "text2": "dynamicprogramming"
      },
      "output": 8
    },
    {
      "id": 11,
      "input": {
        "text1": "abcdefghijklmnop",
        "text2": "acegikmoqsuwy"
      },
      "output": 8
    },
    {
      "id": 12,
      "input": {
        "text1": "xyz",
        "text2": "abc"
      },
      "output": 0
    }
  ]
}