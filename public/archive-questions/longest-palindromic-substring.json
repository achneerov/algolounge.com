{
  "filename": "longest-palindromic-substring",
  "title": "Longest Palindromic Substring",
  "keywords": [
    "longest",
    "palindromic",
    "substring",
    "leetcode",
    "given",
    "string",
    "return",
    "palindrome",
    "reads",
    "same"
  ],
  "description": "<h2>Longest Palindromic Substring</h2><p>Given a string <code>s</code>, return the longest substring of <code>s</code> that is a palindrome.</p><p>A <strong>palindrome</strong> is a string that reads the same forward and backward.</p><p>If there are multiple palindromic substrings that have the same length, return any one of them.</p><h3>Examples</h3><ul><li><strong>Example 1:</strong><br>Input: s = \"ababd\"<br>Output: \"bab\"<br>Explanation: Both \"aba\" and \"bab\" are valid answers.</li><li><strong>Example 2:</strong><br>Input: s = \"abbc\"<br>Output: \"bb\"</li><li><strong>Example 3:</strong><br>Input: s = \"a\"<br>Output: \"a\"</li></ul><h3>Constraints</h3><ul><li><code>1 <= s.length <= 1000</code></li><li><code>s</code> consists of only digits and English letters.</li></ul>",
  "languages": {
    "python": {
      "template": "def longestPalindromicSubstring(s):\n    ",
      "solution_text": "**Algorithm: Expand Around Centers**\n\nThis solution uses the expand around centers approach to find the longest palindromic substring.\n\n**Key Idea:**\n- For each possible center (single character or between characters), expand outward\n- Check if characters on both sides are equal\n- Track the longest palindrome found so far\n\n**Time Complexity:** O(n²) - for each center, we potentially expand n characters\n**Space Complexity:** O(1) - only using a few variables to track indices\n\n**Steps:**\n1. Handle edge cases (empty or single character strings)\n2. For each possible center, expand around it\n3. Check both odd-length (centered on character) and even-length palindromes\n4. Keep track of the longest palindrome found",
      "solution_code": "def longestPalindromicSubstring(s):\n    if not s:\n        return \"\"\n    \n    if len(s) == 1:\n        return s\n    \n    def expand_around_center(left, right):\n        # Expand around center while characters match\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        # Return the valid palindrome (exclude the mismatched characters)\n        return s[left + 1:right]\n    \n    longest = \"\"\n    \n    for i in range(len(s)):\n        # Check for odd-length palindromes (center is a character)\n        odd_palindrome = expand_around_center(i, i)\n        if len(odd_palindrome) > len(longest):\n            longest = odd_palindrome\n        \n        # Check for even-length palindromes (center is between characters)\n        if i < len(s) - 1:\n            even_palindrome = expand_around_center(i, i + 1)\n            if len(even_palindrome) > len(longest):\n                longest = even_palindrome\n    \n    return longest"
    },
    "javascript": {
      "template": "function longestPalindromicSubstring(s) {\n  \n}",
      "solution_text": "**Algorithm: Expand Around Centers**\n\nThis solution uses the expand around centers approach to find the longest palindromic substring.\n\n**Key Idea:**\n- For each possible center (single character or between characters), expand outward\n- Check if characters on both sides are equal\n- Track the longest palindrome found so far\n\n**Time Complexity:** O(n²) - for each center, we potentially expand n characters\n**Space Complexity:** O(1) - only using a few variables to track indices\n\n**Steps:**\n1. Handle edge cases (empty or single character strings)\n2. For each possible center, expand around it\n3. Check both odd-length (centered on character) and even-length palindromes\n4. Keep track of the longest palindrome found",
      "solution_code": "function longestPalindromicSubstring(s) {\n    if (!s) return \"\";\n    \n    if (s.length === 1) return s;\n    \n    function expandAroundCenter(left, right) {\n        // Expand around center while characters match\n        while (left >= 0 && right < s.length && s[left] === s[right]) {\n            left--;\n            right++;\n        }\n        // Return the valid palindrome (exclude the mismatched characters)\n        return s.substring(left + 1, right);\n    }\n    \n    let longest = \"\";\n    \n    for (let i = 0; i < s.length; i++) {\n        // Check for odd-length palindromes (center is a character)\n        const oddPalindrome = expandAroundCenter(i, i);\n        if (oddPalindrome.length > longest.length) {\n            longest = oddPalindrome;\n        }\n        \n        // Check for even-length palindromes (center is between characters)\n        if (i < s.length - 1) {\n            const evenPalindrome = expandAroundCenter(i, i + 1);\n            if (evenPalindrome.length > longest.length) {\n                longest = evenPalindrome;\n            }\n        }\n    }\n    \n    return longest;\n}"
    },
    "typescript": {
      "template": "function longestPalindromicSubstring(s: string): string {\n  \n}",
      "solution_text": "**Algorithm: Expand Around Centers**\n\nThis solution uses the expand around centers approach to find the longest palindromic substring.\n\n**Key Idea:**\n- For each possible center (single character or between characters), expand outward\n- Check if characters on both sides are equal\n- Track the longest palindrome found so far\n\n**Time Complexity:** O(n²) - for each center, we potentially expand n characters\n**Space Complexity:** O(1) - only using a few variables to track indices\n\n**Steps:**\n1. Handle edge cases (empty or single character strings)\n2. For each possible center, expand around it\n3. Check both odd-length (centered on character) and even-length palindromes\n4. Keep track of the longest palindrome found",
      "solution_code": "function longestPalindromicSubstring(s: string): string {\n    if (!s) return \"\";\n    \n    if (s.length === 1) return s;\n    \n    function expandAroundCenter(left: number, right: number): string {\n        // Expand around center while characters match\n        while (left >= 0 && right < s.length && s[left] === s[right]) {\n            left--;\n            right++;\n        }\n        // Return the valid palindrome (exclude the mismatched characters)\n        return s.substring(left + 1, right);\n    }\n    \n    let longest: string = \"\";\n    \n    for (let i = 0; i < s.length; i++) {\n        // Check for odd-length palindromes (center is a character)\n        const oddPalindrome: string = expandAroundCenter(i, i);\n        if (oddPalindrome.length > longest.length) {\n            longest = oddPalindrome;\n        }\n        \n        // Check for even-length palindromes (center is between characters)\n        if (i < s.length - 1) {\n            const evenPalindrome: string = expandAroundCenter(i, i + 1);\n            if (evenPalindrome.length > longest.length) {\n                longest = evenPalindrome;\n            }\n        }\n    }\n    \n    return longest;\n}"
    },
    "java": {
      "template": "class Solution {\n    public String longestPalindromicSubstring(String s) {\n        \n    }\n}",
      "solution_text": "**Algorithm: Expand Around Centers**\n\nThis solution uses the expand around centers approach to find the longest palindromic substring.\n\n**Key Idea:**\n- For each possible center (single character or between characters), expand outward\n- Check if characters on both sides are equal\n- Track the longest palindrome found so far\n\n**Time Complexity:** O(n²) - for each center, we potentially expand n characters\n**Space Complexity:** O(1) - only using a few variables to track indices\n\n**Steps:**\n1. Handle edge cases (empty or single character strings)\n2. For each possible center, expand around it\n3. Check both odd-length (centered on character) and even-length palindromes\n4. Keep track of the longest palindrome found",
      "solution_code": "class Solution {\n    public String longestPalindromicSubstring(String s) {\n        if (s == null || s.length() == 0) return \"\";\n        \n        if (s.length() == 1) return s;\n        \n        String longest = \"\";\n        \n        for (int i = 0; i < s.length(); i++) {\n            // Check for odd-length palindromes (center is a character)\n            String oddPalindrome = expandAroundCenter(s, i, i);\n            if (oddPalindrome.length() > longest.length()) {\n                longest = oddPalindrome;\n            }\n            \n            // Check for even-length palindromes (center is between characters)\n            if (i < s.length() - 1) {\n                String evenPalindrome = expandAroundCenter(s, i, i + 1);\n                if (evenPalindrome.length() > longest.length()) {\n                    longest = evenPalindrome;\n                }\n            }\n        }\n        \n        return longest;\n    }\n    \n    private String expandAroundCenter(String s, int left, int right) {\n        // Expand around center while characters match\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n        // Return the valid palindrome (exclude the mismatched characters)\n        return s.substring(left + 1, right);\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "s": "ababd"
      },
      "output": "bab"
    },
    {
      "id": 2,
      "input": {
        "s": "abbc"
      },
      "output": "bb"
    },
    {
      "id": 3,
      "input": {
        "s": "a"
      },
      "output": "a"
    },
    {
      "id": 4,
      "input": {
        "s": "aa"
      },
      "output": "aa"
    },
    {
      "id": 5,
      "input": {
        "s": "abc"
      },
      "output": "a"
    },
    {
      "id": 6,
      "input": {
        "s": "racecar"
      },
      "output": "racecar"
    },
    {
      "id": 7,
      "input": {
        "s": "abcdef"
      },
      "output": "a"
    },
    {
      "id": 8,
      "input": {
        "s": "noon"
      },
      "output": "noon"
    },
    {
      "id": 9,
      "input": {
        "s": "abacabad"
      },
      "output": "abacaba"
    },
    {
      "id": 10,
      "input": {
        "s": "cbbd"
      },
      "output": "bb"
    },
    {
      "id": 11,
      "input": {
        "s": "babad"
      },
      "output": "bab"
    },
    {
      "id": 12,
      "input": {
        "s": "ac"
      },
      "output": "a"
    }
  ]
}