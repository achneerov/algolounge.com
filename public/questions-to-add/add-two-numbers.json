{
  "filename": "add-two-numbers",
  "title": "Add Two Numbers",
  "keywords": [
    "add",
    "two",
    "numbers",
    "leetcode",
    "given",
    "non",
    "empty",
    "linked",
    "lists",
    "where"
  ],
  "description": "<h2>Add Two Numbers</h2><p>Leetcode 2. Add Two Numbers</p><p>You are given two <strong>non-empty</strong> linked lists, <code>l1</code> and <code>l2</code>, where each represents a non-negative integer.</p><p>The digits are stored in <strong>reverse order</strong>, e.g. the number 123 is represented as <code>3 -> 2 -> 1 -></code> in the linked list.</p><p>Each of the nodes contains a single digit. You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p>Return the sum of the two numbers as a linked list.</p><h3>Examples:</h3><ul><li>Input: l1 = [2,4,3], l2 = [5,6,4]<br>Output: [7,0,8]<br>Explanation: 342 + 465 = 807</li><li>Input: l1 = [0], l2 = [0]<br>Output: [0]</li><li>Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br>Output: [8,9,9,9,0,0,0,1]</li></ul><h3>Constraints:</h3><ul><li>The number of nodes in each linked list is in the range <code>[1, 100]</code></li><li><code>0 <= Node.val <= 9</code></li><li>It is guaranteed that the list represents a number that does not have leading zeros</li></ul>",
  "languages": {
    "python": {
      "template": "def addTwoNumbers(l1, l2):\n    ",
      "solution_text": "Add two numbers represented as linked lists in reverse order:\n\n**Algorithm:**\n1. Initialize dummy head and carry variable\n2. Traverse both linked lists simultaneously\n3. Add values with carry at each position\n4. Create new nodes for the result\n5. Handle remaining carry\n\n**Time Complexity:** O(max(m, n)) where m, n are lengths of input lists\n**Space Complexity:** O(max(m, n)) for the result list\n\n**Key Insights:**\n- Process digits from least to most significant (reverse order)\n- Handle carry propagation carefully\n- Create new linked list for result",
      "solution_code": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef addTwoNumbers(l1, l2):\n    dummy = ListNode(0)\n    current = dummy\n    carry = 0\n    \n    while l1 or l2 or carry:\n        val1 = l1.val if l1 else 0\n        val2 = l2.val if l2 else 0\n        \n        total = val1 + val2 + carry\n        carry = total // 10\n        digit = total % 10\n        \n        current.next = ListNode(digit)\n        current = current.next\n        \n        l1 = l1.next if l1 else None\n        l2 = l2.next if l2 else None\n    \n    return dummy.next"
    },
    "javascript": {
      "template": "function addTwoNumbers(l1, l2) {\n  \n}",
      "solution_text": "Add two numbers represented as linked lists in reverse order:\n\n**Algorithm:**\n1. Initialize dummy head and carry variable\n2. Traverse both linked lists simultaneously\n3. Add values with carry at each position\n4. Create new nodes for the result\n5. Handle remaining carry\n\n**Time Complexity:** O(max(m, n)) where m, n are lengths of input lists\n**Space Complexity:** O(max(m, n)) for the result list\n\n**Key Insights:**\n- Process digits from least to most significant (reverse order)\n- Handle carry propagation carefully\n- Create new linked list for result",
      "solution_code": "// Definition for singly-linked list.\nfunction ListNode(val, next) {\n    this.val = (val===undefined ? 0 : val);\n    this.next = (next===undefined ? null : next);\n}\n\nfunction addTwoNumbers(l1, l2) {\n    const dummy = new ListNode(0);\n    let current = dummy;\n    let carry = 0;\n    \n    while (l1 || l2 || carry) {\n        const val1 = l1 ? l1.val : 0;\n        const val2 = l2 ? l2.val : 0;\n        \n        const total = val1 + val2 + carry;\n        carry = Math.floor(total / 10);\n        const digit = total % 10;\n        \n        current.next = new ListNode(digit);\n        current = current.next;\n        \n        l1 = l1 ? l1.next : null;\n        l2 = l2 ? l2.next : null;\n    }\n    \n    return dummy.next;\n}"
    },
    "typescript": {
      "template": "function addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n  \n}",
      "solution_text": "Add two numbers represented as linked lists in reverse order:\n\n**Algorithm:**\n1. Initialize dummy head and carry variable\n2. Traverse both linked lists simultaneously\n3. Add values with carry at each position\n4. Create new nodes for the result\n5. Handle remaining carry\n\n**Time Complexity:** O(max(m, n)) where m, n are lengths of input lists\n**Space Complexity:** O(max(m, n)) for the result list\n\n**Key Insights:**\n- Process digits from least to most significant (reverse order)\n- Handle carry propagation carefully\n- Create new linked list for result",
      "solution_code": "// Definition for singly-linked list.\nclass ListNode {\n    val: number;\n    next: ListNode | null;\n    constructor(val?: number, next?: ListNode | null) {\n        this.val = (val===undefined ? 0 : val);\n        this.next = (next===undefined ? null : next);\n    }\n}\n\nfunction addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n    const dummy = new ListNode(0);\n    let current = dummy;\n    let carry = 0;\n    \n    while (l1 || l2 || carry) {\n        const val1 = l1 ? l1.val : 0;\n        const val2 = l2 ? l2.val : 0;\n        \n        const total = val1 + val2 + carry;\n        carry = Math.floor(total / 10);\n        const digit = total % 10;\n        \n        current.next = new ListNode(digit);\n        current = current.next;\n        \n        l1 = l1 ? l1.next : null;\n        l2 = l2 ? l2.next : null;\n    }\n    \n    return dummy.next;\n}"
    },
    "java": {
      "template": "class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        \n    }\n}",
      "solution_text": "Add two numbers represented as linked lists in reverse order:\n\n**Algorithm:**\n1. Initialize dummy head and carry variable\n2. Traverse both linked lists simultaneously\n3. Add values with carry at each position\n4. Create new nodes for the result\n5. Handle remaining carry\n\n**Time Complexity:** O(max(m, n)) where m, n are lengths of input lists\n**Space Complexity:** O(max(m, n)) for the result list\n\n**Key Insights:**\n- Process digits from least to most significant (reverse order)\n- Handle carry propagation carefully\n- Create new linked list for result",
      "solution_code": "// Definition for singly-linked list.\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        int carry = 0;\n        \n        while (l1 != null || l2 != null || carry != 0) {\n            int val1 = (l1 != null) ? l1.val : 0;\n            int val2 = (l2 != null) ? l2.val : 0;\n            \n            int total = val1 + val2 + carry;\n            carry = total / 10;\n            int digit = total % 10;\n            \n            current.next = new ListNode(digit);\n            current = current.next;\n            \n            l1 = (l1 != null) ? l1.next : null;\n            l2 = (l2 != null) ? l2.next : null;\n        }\n        \n        return dummy.next;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "l1": [2, 4, 3],
        "l2": [5, 6, 4]
      },
      "output": [7, 0, 8]
    },
    {
      "id": 2,
      "input": {
        "l1": [0],
        "l2": [0]
      },
      "output": [0]
    },
    {
      "id": 3,
      "input": {
        "l1": [9, 9, 9, 9, 9, 9, 9],
        "l2": [9, 9, 9, 9]
      },
      "output": [8, 9, 9, 9, 0, 0, 0, 1]
    },
    {
      "id": 4,
      "input": {
        "l1": [9],
        "l2": [9]
      },
      "output": [8, 1]
    },
    {
      "id": 5,
      "input": {
        "l1": [1, 8],
        "l2": [0]
      },
      "output": [1, 8]
    },
    {
      "id": 6,
      "input": {
        "l1": [2, 4, 9],
        "l2": [5, 6, 4, 9]
      },
      "output": [7, 0, 4, 0, 1]
    },
    {
      "id": 7,
      "input": {
        "l1": [1],
        "l2": [9, 9, 9]
      },
      "output": [0, 0, 0, 1]
    },
    {
      "id": 8,
      "input": {
        "l1": [5],
        "l2": [5]
      },
      "output": [0, 1]
    },
    {
      "id": 9,
      "input": {
        "l1": [9, 9],
        "l2": [1]
      },
      "output": [0, 0, 1]
    },
    {
      "id": 10,
      "input": {
        "l1": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        "l2": [5, 6, 4]
      },
      "output": [6, 6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]
    },
    {
      "id": 11,
      "input": {
        "l1": [2, 4, 3, 2, 4, 3, 2, 4, 3, 2, 4, 3, 2, 4, 3, 2, 4, 3, 2, 4, 3, 2, 4, 3, 2, 4, 3, 2, 4, 3, 2, 4, 3, 2, 4, 3, 2, 4, 3, 2, 4, 3, 2, 4, 3, 2, 4, 3, 2, 4, 3, 2, 4, 3, 2, 4, 3, 2, 4, 3, 9],
        "l2": [5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 1]
      },
      "output": [7, 0, 8, 7, 0, 8, 7, 0, 8, 7, 0, 8, 7, 0, 8, 7, 0, 8, 7, 0, 8, 7, 0, 8, 7, 0, 8, 7, 0, 8, 7, 0, 8, 7, 0, 8, 7, 0, 8, 7, 0, 8, 7, 0, 8, 7, 0, 8, 7, 0, 8, 7, 0, 8, 7, 0, 8, 7, 0, 8, 0, 1]
    }
  ]
}