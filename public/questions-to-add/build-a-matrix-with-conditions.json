{
  "filename": "build-a-matrix-with-conditions",
  "title": "Build a Matrix With Conditions",
  "keywords": [
    "build",
    "matrix",
    "conditions",
    "leetcode",
    "2392",
    "given",
    "positive",
    "integer",
    "also",
    "array"
  ],
  "description": "<h2>Build a Matrix With Conditions</h2><p>Leetcode 2392. Build a Matrix With Conditions</p><p></p><p>You are given a positive integer `k`. You are also given:</p><p></p><p>- a `2D` integer array `rowConditions` of size `n` where `rowConditions[i] = [above[i], below[i]]`, and</p><p>- a `2D` integer array `colConditions` of size `m` where `colConditions[i] = [left[i], right[i]]`.</p><p></p><p>The two arrays contain integers from `1` to `k`.</p><p></p><p>You have to build a `k x k` matrix that contains each of the numbers from `1` to `k` **exactly once**. The remaining cells should have the value `0`.</p><p></p><p>The matrix should also satisfy the following conditions:</p><p></p><p>- The number `above[i]` should appear in a **row** that is strictly **above** the row at which the number `below[i]` appears for all `i` from `0` to `n - 1`.</p><p></p><p>- The number `left[i]` should appear in a **column** that is strictly **left** of the column at which the number `right[i]` appears for all `i` from `0` to `m - 1`.</p><p></p><p>Return **any** matrix that satisfies the conditions. If no answer exists, return an empty matrix.</p><h3>Examples:</h3><ul><li>Input: k = 3, rowConditions = [[2,1],[1,3]], colConditions = [[3,1],[2,3]]<br><br>Output: [[2,0,0],[0,0,1],[0,3,0]]</li><li>Input: k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]]<br><br>Output: []</li></ul><h3>Constraints:</h3><ul><li> `2 <= k <= 400`</li><li> `1 <= rowConditions.length, colConditions.length <= 10,000`</li><li> `rowConditions[i].length == colConditions[i].length == 2`</li><li> `1 <= above[i], below[i], left[i], right[i] <= k`</li><li> `above[i] != below[i]`</li><li> `left[i] != right[i]`</li></ul>",
  "languages": {
    "python": {
      "template": "def buildAMatrixWithConditions(k, rowConditions, colConditions):\n    ",
      "solution_text": "<h3>Build a Matrix With Conditions</h3><p><strong>Algorithm:</strong></p><ol><li>Use topological sorting to determine valid row and column orderings</li><li>Build graphs from row and column conditions</li><li>Check for cycles using DFS - if cycle exists, return empty matrix</li><li>Get topological order for both rows and columns</li><li>Place numbers 1 to k in the matrix based on their positions in sorted orders</li></ol><p><strong>Time Complexity:</strong> O(k + n + m) - where n and m are condition counts</p><p><strong>Space Complexity:</strong> O(k²) - for the result matrix and auxiliary data structures</p><p><strong>Key Insights:</strong></p><ul><li>Each condition creates a directed edge in the respective graph</li><li>Topological sort ensures all constraints are satisfied</li><li>Cycle detection prevents impossible cases</li></ul>",
      "solution_code": "def buildAMatrixWithConditions(k, rowConditions, colConditions):\n    def topological_sort(conditions, k):\n        # Build adjacency list and in-degree count\n        graph = {i: [] for i in range(1, k + 1)}\n        in_degree = {i: 0 for i in range(1, k + 1)}\n        \n        for before, after in conditions:\n            graph[before].append(after)\n            in_degree[after] += 1\n        \n        # Kahn's algorithm for topological sorting\n        queue = [node for node in range(1, k + 1) if in_degree[node] == 0]\n        result = []\n        \n        while queue:\n            node = queue.pop(0)\n            result.append(node)\n            \n            for neighbor in graph[node]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n        \n        # Check if all nodes are processed (no cycle)\n        if len(result) != k:\n            return None\n        return result\n    \n    # Get topological order for rows and columns\n    row_order = topological_sort(rowConditions, k)\n    col_order = topological_sort(colConditions, k)\n    \n    # If either has a cycle, return empty matrix\n    if row_order is None or col_order is None:\n        return []\n    \n    # Create position mappings\n    row_pos = {num: i for i, num in enumerate(row_order)}\n    col_pos = {num: i for i, num in enumerate(col_order)}\n    \n    # Build the result matrix\n    matrix = [[0] * k for _ in range(k)]\n    for num in range(1, k + 1):\n        matrix[row_pos[num]][col_pos[num]] = num\n    \n    return matrix"
    },
    "javascript": {
      "template": "function buildAMatrixWithConditions(k, rowConditions, colConditions) {\n  \n}",
      "solution_text": "<h3>Build a Matrix With Conditions</h3><p><strong>Algorithm:</strong></p><ol><li>Use topological sorting to determine valid row and column orderings</li><li>Build graphs from row and column conditions</li><li>Check for cycles using DFS - if cycle exists, return empty matrix</li><li>Get topological order for both rows and columns</li><li>Place numbers 1 to k in the matrix based on their positions in sorted orders</li></ol><p><strong>Time Complexity:</strong> O(k + n + m) - where n and m are condition counts</p><p><strong>Space Complexity:</strong> O(k²) - for the result matrix and auxiliary data structures</p><p><strong>Key Insights:</strong></p><ul><li>Each condition creates a directed edge in the respective graph</li><li>Topological sort ensures all constraints are satisfied</li><li>Cycle detection prevents impossible cases</li></ul>",
      "solution_code": "function buildAMatrixWithConditions(k, rowConditions, colConditions) {\n    function topologicalSort(conditions, k) {\n        // Build adjacency list and in-degree count\n        const graph = {};\n        const inDegree = {};\n        \n        for (let i = 1; i <= k; i++) {\n            graph[i] = [];\n            inDegree[i] = 0;\n        }\n        \n        for (const [before, after] of conditions) {\n            graph[before].push(after);\n            inDegree[after]++;\n        }\n        \n        // Kahn's algorithm for topological sorting\n        const queue = [];\n        for (let i = 1; i <= k; i++) {\n            if (inDegree[i] === 0) {\n                queue.push(i);\n            }\n        }\n        \n        const result = [];\n        while (queue.length > 0) {\n            const node = queue.shift();\n            result.push(node);\n            \n            for (const neighbor of graph[node]) {\n                inDegree[neighbor]--;\n                if (inDegree[neighbor] === 0) {\n                    queue.push(neighbor);\n                }\n            }\n        }\n        \n        // Check if all nodes are processed (no cycle)\n        return result.length === k ? result : null;\n    }\n    \n    // Get topological order for rows and columns\n    const rowOrder = topologicalSort(rowConditions, k);\n    const colOrder = topologicalSort(colConditions, k);\n    \n    // If either has a cycle, return empty matrix\n    if (rowOrder === null || colOrder === null) {\n        return [];\n    }\n    \n    // Create position mappings\n    const rowPos = {};\n    const colPos = {};\n    \n    for (let i = 0; i < k; i++) {\n        rowPos[rowOrder[i]] = i;\n        colPos[colOrder[i]] = i;\n    }\n    \n    // Build the result matrix\n    const matrix = Array(k).fill().map(() => Array(k).fill(0));\n    for (let num = 1; num <= k; num++) {\n        matrix[rowPos[num]][colPos[num]] = num;\n    }\n    \n    return matrix;\n}"
    },
    "typescript": {
      "template": "function buildAMatrixWithConditions(k: number, rowConditions: number[][], colConditions: number[][]): number[][] {\n  \n}",
      "solution_text": "<h3>Build a Matrix With Conditions</h3><p><strong>Algorithm:</strong></p><ol><li>Use topological sorting to determine valid row and column orderings</li><li>Build graphs from row and column conditions</li><li>Check for cycles using DFS - if cycle exists, return empty matrix</li><li>Get topological order for both rows and columns</li><li>Place numbers 1 to k in the matrix based on their positions in sorted orders</li></ol><p><strong>Time Complexity:</strong> O(k + n + m) - where n and m are condition counts</p><p><strong>Space Complexity:</strong> O(k²) - for the result matrix and auxiliary data structures</p><p><strong>Key Insights:</strong></p><ul><li>Each condition creates a directed edge in the respective graph</li><li>Topological sort ensures all constraints are satisfied</li><li>Cycle detection prevents impossible cases</li></ul>",
      "solution_code": "function buildAMatrixWithConditions(k: number, rowConditions: number[][], colConditions: number[][]): number[][] {\n    function topologicalSort(conditions: number[][], k: number): number[] | null {\n        // Build adjacency list and in-degree count\n        const graph: { [key: number]: number[] } = {};\n        const inDegree: { [key: number]: number } = {};\n        \n        for (let i = 1; i <= k; i++) {\n            graph[i] = [];\n            inDegree[i] = 0;\n        }\n        \n        for (const [before, after] of conditions) {\n            graph[before].push(after);\n            inDegree[after]++;\n        }\n        \n        // Kahn's algorithm for topological sorting\n        const queue: number[] = [];\n        for (let i = 1; i <= k; i++) {\n            if (inDegree[i] === 0) {\n                queue.push(i);\n            }\n        }\n        \n        const result: number[] = [];\n        while (queue.length > 0) {\n            const node = queue.shift()!;\n            result.push(node);\n            \n            for (const neighbor of graph[node]) {\n                inDegree[neighbor]--;\n                if (inDegree[neighbor] === 0) {\n                    queue.push(neighbor);\n                }\n            }\n        }\n        \n        // Check if all nodes are processed (no cycle)\n        return result.length === k ? result : null;\n    }\n    \n    // Get topological order for rows and columns\n    const rowOrder = topologicalSort(rowConditions, k);\n    const colOrder = topologicalSort(colConditions, k);\n    \n    // If either has a cycle, return empty matrix\n    if (rowOrder === null || colOrder === null) {\n        return [];\n    }\n    \n    // Create position mappings\n    const rowPos: { [key: number]: number } = {};\n    const colPos: { [key: number]: number } = {};\n    \n    for (let i = 0; i < k; i++) {\n        rowPos[rowOrder[i]] = i;\n        colPos[colOrder[i]] = i;\n    }\n    \n    // Build the result matrix\n    const matrix: number[][] = Array(k).fill(0).map(() => Array(k).fill(0));\n    for (let num = 1; num <= k; num++) {\n        matrix[rowPos[num]][colPos[num]] = num;\n    }\n    \n    return matrix;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int[][] buildAMatrixWithConditions(int k, int[][] rowConditions, int[][] colConditions) {\n        \n    }\n}",
      "solution_text": "<h3>Build a Matrix With Conditions</h3><p><strong>Algorithm:</strong></p><ol><li>Use topological sorting to determine valid row and column orderings</li><li>Build graphs from row and column conditions</li><li>Check for cycles using DFS - if cycle exists, return empty matrix</li><li>Get topological order for both rows and columns</li><li>Place numbers 1 to k in the matrix based on their positions in sorted orders</li></ol><p><strong>Time Complexity:</strong> O(k + n + m) - where n and m are condition counts</p><p><strong>Space Complexity:</strong> O(k²) - for the result matrix and auxiliary data structures</p><p><strong>Key Insights:</strong></p><ul><li>Each condition creates a directed edge in the respective graph</li><li>Topological sort ensures all constraints are satisfied</li><li>Cycle detection prevents impossible cases</li></ul>",
      "solution_code": "class Solution {\n    public int[][] buildAMatrixWithConditions(int k, int[][] rowConditions, int[][] colConditions) {\n        // Get topological order for rows and columns\n        List<Integer> rowOrder = topologicalSort(rowConditions, k);\n        List<Integer> colOrder = topologicalSort(colConditions, k);\n        \n        // If either has a cycle, return empty matrix\n        if (rowOrder == null || colOrder == null) {\n            return new int[0][];\n        }\n        \n        // Create position mappings\n        Map<Integer, Integer> rowPos = new HashMap<>();\n        Map<Integer, Integer> colPos = new HashMap<>();\n        \n        for (int i = 0; i < k; i++) {\n            rowPos.put(rowOrder.get(i), i);\n            colPos.put(colOrder.get(i), i);\n        }\n        \n        // Build the result matrix\n        int[][] matrix = new int[k][k];\n        for (int num = 1; num <= k; num++) {\n            matrix[rowPos.get(num)][colPos.get(num)] = num;\n        }\n        \n        return matrix;\n    }\n    \n    private List<Integer> topologicalSort(int[][] conditions, int k) {\n        // Build adjacency list and in-degree count\n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        Map<Integer, Integer> inDegree = new HashMap<>();\n        \n        for (int i = 1; i <= k; i++) {\n            graph.put(i, new ArrayList<>());\n            inDegree.put(i, 0);\n        }\n        \n        for (int[] condition : conditions) {\n            int before = condition[0];\n            int after = condition[1];\n            graph.get(before).add(after);\n            inDegree.put(after, inDegree.get(after) + 1);\n        }\n        \n        // Kahn's algorithm for topological sorting\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 1; i <= k; i++) {\n            if (inDegree.get(i) == 0) {\n                queue.offer(i);\n            }\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            result.add(node);\n            \n            for (int neighbor : graph.get(node)) {\n                inDegree.put(neighbor, inDegree.get(neighbor) - 1);\n                if (inDegree.get(neighbor) == 0) {\n                    queue.offer(neighbor);\n                }\n            }\n        }\n        \n        // Check if all nodes are processed (no cycle)\n        return result.size() == k ? result : null;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "k": 3,
        "rowConditions": [[2, 1], [1, 3]],
        "colConditions": [[3, 1], [2, 3]]
      },
      "output": [[2, 0, 0], [0, 0, 1], [0, 3, 0]]
    },
    {
      "id": 2,
      "input": {
        "k": 3,
        "rowConditions": [[1, 2], [2, 3], [3, 1], [2, 3]],
        "colConditions": [[2, 1]]
      },
      "output": []
    }
  ]
}