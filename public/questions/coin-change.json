{
  "filename": "coin-change",
  "title": "Coin Change",
  "keywords": [
    "coin",
    "change",
    "dynamic",
    "programming",
    "dp",
    "minimum",
    "optimization",
    "unbounded",
    "knapsack",
    "greedy",
    "hw20",
    "hello world 2025",
    "medium"
  ],
  "description": "<h2>Coin Change</h2><p>You are given an integer array <code>coins</code> representing coins of different denominations (e.g. 1 dollar, 5 dollars, etc) and an integer <code>amount</code> representing a target amount of money.</p><p>Return the fewest number of coins that you need to make up the exact target amount. If it is impossible to make up the amount, return <code>-1</code>.</p><p>You may assume that you have an unlimited number of each coin.</p><h3>Examples:</h3><ul><li><strong>Input:</strong> coins = [1,5,10], amount = 12<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> 12 = 10 + 1 + 1. Note that we do not have to use every kind of coin available.</li><li><strong>Input:</strong> coins = [2], amount = 3<br><strong>Output:</strong> -1<br><strong>Explanation:</strong> The amount of 3 cannot be made up with coins of 2.</li><li><strong>Input:</strong> coins = [1], amount = 0<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> Choosing 0 coins is a valid way to make up 0.</li></ul><h3>Constraints:</h3><ul><li><code>1 <= coins.length <= 12</code></li><li><code>1 <= coins[i] <= 2^31 - 1</code></li><li><code>0 <= amount <= 10000</code></li></ul>",
  "entry_function": "coinChange",
  "template": "def coinChange(coins, amount):\n    ",
  "solution_text": "<h3>Coin Change</h3><p><strong>Algorithm:</strong></p><ol><li>Use dynamic programming where dp[i] = minimum coins needed to make amount i</li><li>Initialize dp[0] = 0 (base case: 0 coins for amount 0)</li><li>Initialize all other values to infinity (impossible initially)</li><li>For each amount from 1 to target, try using each coin denomination</li><li>If coin value <= current amount, update: dp[amount] = min(dp[amount], dp[amount - coin] + 1)</li><li>Return dp[target] if reachable, otherwise -1</li></ol><p><strong>Time Complexity:</strong> O(amount Ã— coins.length) - fill entire DP table</p><p><strong>Space Complexity:</strong> O(amount) - DP array storage</p><p><strong>Key Insights:</strong></p><ul><li>This is an unbounded knapsack problem (coins can be reused)</li><li>Greedy approach doesn't work - must try all combinations</li><li>Use infinity as initial value to detect impossible amounts</li><li>Bottom-up DP builds solution from smaller subproblems</li></ul>",
  "solution_code": "def coinChange(coins, amount):\n    # dp[i] = minimum coins needed to make amount i\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0  # Base case: 0 coins needed for amount 0\n    \n    # Fill dp table for each amount from 1 to target\n    for i in range(1, amount + 1):\n        # Try each coin denomination\n        for coin in coins:\n            if coin <= i:  # Can use this coin\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    # Return result: -1 if impossible, else minimum coins\n    return dp[amount] if dp[amount] != float('inf') else -1",
  "prepare": "def prepare(test_case_input):\n    \"\"\"Prepare arguments for coinChange function\"\"\"\n    return (test_case_input['coins'], test_case_input['amount'])",
  "verify": "def verify(actual_output, expected_output):\n    \"\"\"Verify the coin change result\"\"\"\n    passed = actual_output == expected_output\n    output_str = str(actual_output)\n    \n    return [passed, output_str]",
  "test_cases": [
    {
      "id": 1,
      "input": {
        "coins": [
          1,
          5,
          10
        ],
        "amount": 12
      },
      "output": 3
    },
    {
      "id": 2,
      "input": {
        "coins": [
          2
        ],
        "amount": 3
      },
      "output": -1
    },
    {
      "id": 3,
      "input": {
        "coins": [
          1
        ],
        "amount": 0
      },
      "output": 0
    },
    {
      "id": 4,
      "input": {
        "coins": [
          1,
          3,
          4
        ],
        "amount": 6
      },
      "output": 2
    },
    {
      "id": 5,
      "input": {
        "coins": [
          2,
          5,
          10,
          1
        ],
        "amount": 27
      },
      "output": 4
    },
    {
      "id": 6,
      "input": {
        "coins": [
          5
        ],
        "amount": 3
      },
      "output": -1
    },
    {
      "id": 7,
      "input": {
        "coins": [
          1,
          2,
          5
        ],
        "amount": 11
      },
      "output": 3
    },
    {
      "id": 8,
      "input": {
        "coins": [
          2,
          3,
          5
        ],
        "amount": 9
      },
      "output": 3
    },
    {
      "id": 9,
      "input": {
        "coins": [
          1,
          4,
          5
        ],
        "amount": 8
      },
      "output": 2
    },
    {
      "id": 10,
      "input": {
        "coins": [
          1,
          2,
          3
        ],
        "amount": 7
      },
      "output": 3
    }
  ]
}
