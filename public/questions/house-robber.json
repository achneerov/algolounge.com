{
  "filename": "house-robber",
  "title": "House Robber",
  "keywords": [
    "house",
    "robber",
    "dynamic",
    "programming",
    "dp",
    "maximum",
    "adjacent",
    "optimization",
    "decision",
    "problem"
  ],
  "description": "<h2>House Robber</h2><p>You are given an integer array <code>nums</code> where <code>nums[i]</code> represents the amount of money the <code>i</code>-th house has. The houses are arranged in a straight line, i.e. the <code>i</code>-th house is the neighbor of the <code>(i-1)</code>-th and <code>(i+1)</code>-th house.</p><p>You are planning to rob money from the houses, but you <strong>cannot rob two adjacent houses</strong> because the security system will automatically alert the police if two adjacent houses were both broken into.</p><p>Return the <strong>maximum</strong> amount of money you can rob <strong>without</strong> alerting the police.</p><h3>Examples:</h3><ul><li><strong>Input:</strong> nums = [1,1,3,3]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> nums[0] + nums[2] = 1 + 3 = 4</li><li><strong>Input:</strong> nums = [2,9,8,3,6]<br><strong>Output:</strong> 16<br><strong>Explanation:</strong> nums[0] + nums[2] + nums[4] = 2 + 8 + 6 = 16</li></ul><h3>Constraints:</h3><ul><li><code>1 <= nums.length <= 100</code></li><li><code>0 <= nums[i] <= 100</code></li></ul>",
  "entry_function": "rob",
  "template": "def rob(nums):\n    ",
  "solution_text": "<h3>House Robber</h3><p><strong>Algorithm:</strong></p><ol><li>For each house, make a decision: rob it or skip it</li><li>If rob current house: can't rob previous, so take current + max from 2 houses back</li><li>If skip current house: take max from previous house</li><li>Formula: dp[i] = max(nums[i] + dp[i-2], dp[i-1])</li><li>Use space optimization with two variables</li></ol><p><strong>Time Complexity:</strong> O(n) - single pass through houses</p><p><strong>Space Complexity:</strong> O(1) - constant space with two variables</p><p><strong>Key Insights:</strong></p><ul><li>Classic dynamic programming problem with decision-making</li><li>Each position depends only on previous two positions</li><li>Space can be optimized from O(n) array to O(1) variables</li><li>Similar to Fibonacci but with max() instead of sum</li></ul>",
  "solution_code": "def rob(nums):\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    \n    # dp[i] represents max money we can rob up to house i\n    # We only need to track two previous values\n    prev2 = nums[0]  # dp[i-2]\n    prev1 = max(nums[0], nums[1])  # dp[i-1]\n    \n    for i in range(2, len(nums)):\n        current = max(nums[i] + prev2, prev1)\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1",
  "prepare": "def prepare(test_case_input):\n    \"\"\"Prepare arguments for rob function\"\"\"\n    return (test_case_input['nums'],)",
  "verify": "def verify(actual_output, expected_output):\n    \"\"\"Verify the house robber result\"\"\"\n    passed = actual_output == expected_output\n    output_str = str(actual_output)\n    \n    return [passed, output_str]",
  "test_cases": [
    {
      "id": 1,
      "input": {
        "nums": [1, 1, 3, 3]
      },
      "output": 4
    },
    {
      "id": 2,
      "input": {
        "nums": [2, 9, 8, 3, 6]
      },
      "output": 16
    },
    {
      "id": 3,
      "input": {
        "nums": [1]
      },
      "output": 1
    },
    {
      "id": 4,
      "input": {
        "nums": [2, 1]
      },
      "output": 2
    },
    {
      "id": 5,
      "input": {
        "nums": [5, 1, 3, 9]
      },
      "output": 14
    },
    {
      "id": 6,
      "input": {
        "nums": [2, 7, 9, 3, 1]
      },
      "output": 12
    },
    {
      "id": 7,
      "input": {
        "nums": [100, 1, 1, 100]
      },
      "output": 200
    },
    {
      "id": 8,
      "input": {
        "nums": [5, 5, 10, 100, 10, 5]
      },
      "output": 110
    },
    {
      "id": 9,
      "input": {
        "nums": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      },
      "output": 30
    },
    {
      "id": 10,
      "input": {
        "nums": [50, 1, 1, 50, 1, 1, 50]
      },
      "output": 150
    }
  ]
}
