{
  "filename": "icar-traffic-lights",
  "title": "HW24 - iCar Traffic Lights",
  "keywords": [
    "physics",
    "simulation",
    "veryhard",
    "math",
    "optimization",
    "timing"
  ],
  "description": "<h2>HW24 - iCar Traffic Lights</h2><p>Calculate minimum time for an iCar to travel through a series of traffic lights. The car accelerates at 1 m/s² and can stop instantly.</p><p><strong>Setup:</strong></p><ul><li>Lights are 1000m apart</li><li>Car starts from rest</li><li>Time to travel between lights = √(2 × 1000) ≈ 44.72 seconds</li><li>Each light has cycle: [initial_green, green_duration, red_duration]</li></ul><h3>Example:</h3><ul><li>Input: 1 light with [10, 20, 15] (green at t=10 for 20s, then red for 15s)<br>Output: 54.72<br>Explanation: Wait until t=10, then travel for 44.72s</li></ul><h3>Constraints:</h3><ul><li>1 ≤ n ≤ 100 (number of lights)</li><li>Physics: distance = ½at², so time = √(2d/a) = √(2000) ≈ 44.72s</li><li>Return floating point result</li></ul>",
  "entry_function": "icarTrafficLights",
  "template": "def icarTrafficLights(lights):\n  ",
  "solution_text": "<h3>iCar Traffic Lights</h3><p><strong>Algorithm:</strong></p><ol><li>Calculate travel time per segment: √(2000) ≈ 44.72s</li><li>For each light, determine earliest green window</li><li>Wait if necessary to catch next green light</li><li>Accumulate total time</li></ol><p><strong>Time Complexity:</strong> O(n) - process each light</p><p><strong>Space Complexity:</strong> O(1) - constant space</p>",
  "solution_code": "import math\n\ndef icarTrafficLights(lights):\n    travel_time = math.sqrt(2000)  # ~44.72 seconds\n    current_time = 0\n    \n    for light in lights:\n        initial_green, green_duration, red_duration = light\n        cycle_time = green_duration + red_duration\n        \n        # Find when we arrive at this light\n        arrival_time = current_time + travel_time\n        \n        # Determine light status at arrival\n        # Lights start green at initial_green for green_duration\n        # Then alternate red/green\n        \n        if arrival_time < initial_green:\n            # Wait for first green\n            current_time = initial_green\n        else:\n            # Calculate position in cycle\n            time_since_first_green = arrival_time - initial_green\n            position_in_cycle = time_since_first_green % cycle_time\n            \n            if position_in_cycle < green_duration:\n                # Light is green, go through\n                current_time = arrival_time\n            else:\n                # Light is red, wait for next green\n                wait_time = cycle_time - position_in_cycle\n                current_time = arrival_time + wait_time\n    \n    return current_time",

  "prepare": "def prepare(test_case_input):\n    \"\"\"Prepare arguments for icarTrafficLights function\"\"\"\n    return (test_case_input['lights'],)",

  "verify": "def verify(actual_output, expected_output):\n    \"\"\"Verify the time result (allow small floating point error)\"\"\"\n    passed = abs(actual_output - expected_output) < 0.01\n    return [passed, f\"{actual_output:.2f}\"]",

  "test_cases": [
    {
      "id": 1,
      "input": {
        "lights": [[10, 20, 15]]
      },
      "output": 54.72
    },
    {
      "id": 2,
      "input": {
        "lights": [[0, 100, 10]]
      },
      "output": 44.72
    },
    {
      "id": 3,
      "input": {
        "lights": [[50, 10, 10]]
      },
      "output": 94.72
    },
    {
      "id": 4,
      "input": {
        "lights": [[0, 50, 10], [0, 50, 10]]
      },
      "output": 89.44
    },
    {
      "id": 5,
      "input": {
        "lights": [[100, 5, 100]]
      },
      "output": 149.72
    }
  ]
}
