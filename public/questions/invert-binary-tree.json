{
  "filename": "invert-binary-tree",
  "title": "Invert Binary Tree",
  "keywords": [
    "invert",
    "binary",
    "tree",
    "leetcode",
    "226",
    "given",
    "root",
    "return",
    "mirror",
    "recursive"
  ],
  "description": "<h2>Invert Binary Tree</h2><p>Leetcode 226. Invert Binary Tree</p><p></p><p>You are given the root of a binary tree `root`. Invert the binary tree and return its root.</p><h3>Examples:</h3><ul><li>Input: root = [4,2,7,1,3,6,9]<br><pre>      4              4\n     / \\            / \\\n    2   7    =>    7   2\n   / \\ / \\        / \\ / \\\n  1  3 6  9      9  6 3  1</pre>Output: [4,7,2,9,6,3,1]</li><li>Input: root = [2,1,3]<br><pre>  2       2\n / \\  => / \\\n1   3   3   1</pre>Output: [2,3,1]</li><li>Input: root = []<br><br>Output: []</li></ul><h3>Constraints:</h3><ul><li>0 <= The number of nodes in the tree <= 100</li><li>-100 <= Node.val <= 100</li></ul>",
  "entry_function": "invertBinaryTree",
  "template": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef invertBinaryTree(root):\n    ",
  "solution_text": "<h3>Invert Binary Tree</h3><p><strong>Algorithm:</strong></p><ol><li>If root is null, return null (base case)</li><li>Recursively invert the left subtree</li><li>Recursively invert the right subtree</li><li>Swap the left and right children of the current node</li><li>Return the root</li></ol><p><strong>Time Complexity:</strong> O(n) - visit each node once</p><p><strong>Space Complexity:</strong> O(h) - recursion stack depth where h is tree height</p><p><strong>Key Insights:</strong></p><ul><li>Tree inversion mirrors the tree horizontally</li><li>Can be solved recursively or iteratively with a queue</li><li>Each node's left and right children are swapped</li><li>The operation is done for every node in the tree</li></ul>",
  "solution_code": "def invertBinaryTree(root):\n    if not root:\n        return None\n    \n    # Recursively invert left and right subtrees\n    left = invertBinaryTree(root.left)\n    right = invertBinaryTree(root.right)\n    \n    # Swap left and right children\n    root.left = right\n    root.right = left\n    \n    return root",
  "prepare": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n    \n    def __repr__(self):\n        return f'TreeNode({self.val})'\n\ndef prepare(test_case_input):\n    \"\"\"Convert array representation to TreeNode structure\"\"\"\n    root_array = test_case_input['root']\n    if not root_array or root_array[0] is None:\n        return (None,)\n\n    def build_tree(arr):\n        from collections import deque\n        \n        root = TreeNode(arr[0])\n        queue = deque([root])\n        i = 1\n        \n        while queue and i < len(arr):\n            node = queue.popleft()\n            \n            # Add left child\n            if i < len(arr):\n                if arr[i] is not None:\n                    node.left = TreeNode(arr[i])\n                    queue.append(node.left)\n                i += 1\n            \n            # Add right child\n            if i < len(arr):\n                if arr[i] is not None:\n                    node.right = TreeNode(arr[i])\n                    queue.append(node.right)\n                i += 1\n        \n        return root\n\n    return (build_tree(root_array),)",
  "verify": "def verify(actual_output, expected_output):\n    \"\"\"Verify the inverted tree by converting to level-order array\"\"\"\n    def tree_to_array(root):\n        if not root:\n            return []\n        \n        from collections import deque\n        result = []\n        queue = deque([root])\n        \n        while queue:\n            node = queue.popleft()\n            if node:\n                result.append(node.val)\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                result.append(None)\n        \n        # Remove trailing None values\n        while result and result[-1] is None:\n            result.pop()\n        \n        return result\n    \n    actual_array = tree_to_array(actual_output)\n    \n    def list_to_string(lst):\n        if not lst:\n            return '[]'\n        return '[' + ', '.join('null' if x is None else str(x) for x in lst) + ']'\n    \n    passed = actual_array == expected_output\n    output_str = list_to_string(actual_array)\n    \n    return [passed, output_str]",
  "test_cases": [
    {
      "id": 1,
      "input": {
        "root": [4, 2, 7, 1, 3, 6, 9]
      },
      "output": [4, 7, 2, 9, 6, 3, 1]
    },
    {
      "id": 2,
      "input": {
        "root": [2, 1, 3]
      },
      "output": [2, 3, 1]
    },
    {
      "id": 3,
      "input": {
        "root": []
      },
      "output": []
    },
    {
      "id": 4,
      "input": {
        "root": [1]
      },
      "output": [1]
    },
    {
      "id": 5,
      "input": {
        "root": [1, 2]
      },
      "output": [1, null, 2]
    },
    {
      "id": 6,
      "input": {
        "root": [1, null, 2]
      },
      "output": [1, 2]
    },
    {
      "id": 7,
      "input": {
        "root": [5, 3, 8, 2, 4, 7, 10]
      },
      "output": [5, 8, 3, 10, 7, 4, 2]
    },
    {
      "id": 8,
      "input": {
        "root": [1, 2, 3, 4, 5, 6, 7]
      },
      "output": [1, 3, 2, 7, 6, 5, 4]
    },
    {
      "id": 9,
      "input": {
        "root": [10, 5, 15, null, 7, 12, 20]
      },
      "output": [10, 15, 5, 20, 12, 7]
    },
    {
      "id": 10,
      "input": {
        "root": [3, 9, 20, null, null, 15, 7]
      },
      "output": [3, 20, 9, 7, 15]
    }
  ]
}
