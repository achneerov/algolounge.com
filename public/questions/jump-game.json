{
  "filename": "jump-game",
  "title": "Jump Game",
  "keywords": [
    "jump",
    "game",
    "greedy",
    "array",
    "reach",
    "maximum"
  ],
  "description": "<h2>Jump Game</h2><p>You are given an integer array <code>nums</code>. You are initially positioned at the array's <strong>first index</strong>, and each element in the array represents your maximum jump length at that position.</p><p>Return <code>true</code> if you can reach the last index, or <code>false</code> otherwise.</p><h3>Examples:</h3><ul><li><strong>Example 1:</strong><br>Input: nums = [2,3,1,1,4]<br>Output: true<br>Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</li><li><strong>Example 2:</strong><br>Input: nums = [3,2,1,0,4]<br>Output: false<br>Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.</li></ul><h3>Constraints:</h3><ul><li>1 <= nums.length <= 10<sup>4</sup></li><li>0 <= nums[i] <= 10<sup>5</sup></li></ul>",
  "languages": {
    "python": {
      "template": "def canJump(nums):\n    ",
      "solution_text": "<h3>Approach</h3><p>This problem uses a <strong>greedy algorithm</strong> to determine if we can reach the last index. The key insight is to track the farthest position we can reach at any point.</p><h3>Algorithm</h3><ul><li>Maintain <code>maxReach</code> variable to track farthest reachable position</li><li>For each position <code>i</code>:</li><ul><li>If <code>i > maxReach</code>, we can't reach position i, return false</li><li>Update <code>maxReach = max(maxReach, i + nums[i])</code></li><li>If <code>maxReach >= n-1</code>, we can reach the end</li></ul></ul><h3>Key Insight</h3><p>At each position, we can jump anywhere from 1 to <code>nums[i]</code> steps. So from position i, the farthest we can reach is <code>i + nums[i]</code>.</p><h3>Time Complexity</h3><p>O(n) - single pass through the array</p><h3>Space Complexity</h3><p>O(1) - only using constant extra space</p>",
      "solution_code": "def canJump(nums):\n    max_reach = 0\n    \n    for i in range(len(nums)):\n        if i > max_reach:\n            return False\n        \n        max_reach = max(max_reach, i + nums[i])\n        \n        if max_reach >= len(nums) - 1:\n            return True\n    \n    return True"
    },
    "javascript": {
      "template": "function canJump(nums) {\n  \n}",
      "solution_text": "<h3>Approach</h3><p>This problem uses a <strong>greedy algorithm</strong> to determine if we can reach the last index. The key insight is to track the farthest position we can reach at any point.</p><h3>Algorithm</h3><ul><li>Maintain <code>maxReach</code> variable to track farthest reachable position</li><li>For each position <code>i</code>:</li><ul><li>If <code>i > maxReach</code>, we can't reach position i, return false</li><li>Update <code>maxReach = max(maxReach, i + nums[i])</code></li><li>If <code>maxReach >= n-1</code>, we can reach the end</li></ul></ul><h3>Key Insight</h3><p>At each position, we can jump anywhere from 1 to <code>nums[i]</code> steps. So from position i, the farthest we can reach is <code>i + nums[i]</code>.</p><h3>Time Complexity</h3><p>O(n) - single pass through the array</p><h3>Space Complexity</h3><p>O(1) - only using constant extra space</p>",
      "solution_code": "function canJump(nums) {\n    let maxReach = 0;\n    \n    for (let i = 0; i < nums.length; i++) {\n        if (i > maxReach) {\n            return false;\n        }\n        \n        maxReach = Math.max(maxReach, i + nums[i]);\n        \n        if (maxReach >= nums.length - 1) {\n            return true;\n        }\n    }\n    \n    return true;\n}"
    },
    "typescript": {
      "template": "function canJump(nums: number[]): boolean {\n  \n}",
      "solution_text": "<h3>Approach</h3><p>This problem uses a <strong>greedy algorithm</strong> to determine if we can reach the last index. The key insight is to track the farthest position we can reach at any point.</p><h3>Algorithm</h3><ul><li>Maintain <code>maxReach</code> variable to track farthest reachable position</li><li>For each position <code>i</code>:</li><ul><li>If <code>i > maxReach</code>, we can't reach position i, return false</li><li>Update <code>maxReach = max(maxReach, i + nums[i])</code></li><li>If <code>maxReach >= n-1</code>, we can reach the end</li></ul></ul><h3>Key Insight</h3><p>At each position, we can jump anywhere from 1 to <code>nums[i]</code> steps. So from position i, the farthest we can reach is <code>i + nums[i]</code>.</p><h3>Time Complexity</h3><p>O(n) - single pass through the array</p><h3>Space Complexity</h3><p>O(1) - only using constant extra space</p>",
      "solution_code": "function canJump(nums: number[]): boolean {\n    let maxReach = 0;\n    \n    for (let i = 0; i < nums.length; i++) {\n        if (i > maxReach) {\n            return false;\n        }\n        \n        maxReach = Math.max(maxReach, i + nums[i]);\n        \n        if (maxReach >= nums.length - 1) {\n            return true;\n        }\n    }\n    \n    return true;\n}"
    },
    "java": {
      "template": "class Solution {\n    public boolean canJump(int[] nums) {\n        \n    }\n}",
      "solution_text": "<h3>Approach</h3><p>This problem uses a <strong>greedy algorithm</strong> to determine if we can reach the last index. The key insight is to track the farthest position we can reach at any point.</p><h3>Algorithm</h3><ul><li>Maintain <code>maxReach</code> variable to track farthest reachable position</li><li>For each position <code>i</code>:</li><ul><li>If <code>i > maxReach</code>, we can't reach position i, return false</li><li>Update <code>maxReach = max(maxReach, i + nums[i])</code></li><li>If <code>maxReach >= n-1</code>, we can reach the end</li></ul></ul><h3>Key Insight</h3><p>At each position, we can jump anywhere from 1 to <code>nums[i]</code> steps. So from position i, the farthest we can reach is <code>i + nums[i]</code>.</p><h3>Time Complexity</h3><p>O(n) - single pass through the array</p><h3>Space Complexity</h3><p>O(1) - only using constant extra space</p>",
      "solution_code": "class Solution {\n    public boolean canJump(int[] nums) {\n        int maxReach = 0;\n        \n        for (int i = 0; i < nums.length; i++) {\n            if (i > maxReach) {\n                return false;\n            }\n            \n            maxReach = Math.max(maxReach, i + nums[i]);\n            \n            if (maxReach >= nums.length - 1) {\n                return true;\n            }\n        }\n        \n        return true;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "nums": [
          2,
          3,
          1,
          1,
          4
        ]
      },
      "output": true
    },
    {
      "id": 2,
      "input": {
        "nums": [
          3,
          2,
          1,
          0,
          4
        ]
      },
      "output": false
    },
    {
      "id": 3,
      "input": {
        "nums": [
          0
        ]
      },
      "output": true
    },
    {
      "id": 4,
      "input": {
        "nums": [
          1
        ]
      },
      "output": true
    },
    {
      "id": 5,
      "input": {
        "nums": [
          1,
          0
        ]
      },
      "output": true
    },
    {
      "id": 6,
      "input": {
        "nums": [
          0,
          1
        ]
      },
      "output": false
    },
    {
      "id": 7,
      "input": {
        "nums": [
          1,
          1,
          1,
          0
        ]
      },
      "output": true
    },
    {
      "id": 8,
      "input": {
        "nums": [
          1,
          0,
          1,
          0
        ]
      },
      "output": false
    },
    {
      "id": 9,
      "input": {
        "nums": [
          2,
          0,
          0
        ]
      },
      "output": true
    },
    {
      "id": 10,
      "input": {
        "nums": [
          1,
          2,
          3
        ]
      },
      "output": true
    },
    {
      "id": 11,
      "input": {
        "nums": [
          5,
          9,
          3,
          2,
          1,
          0,
          2,
          3,
          3,
          1,
          0,
          0
        ]
      },
      "output": true
    },
    {
      "id": 12,
      "input": {
        "nums": [
          1,
          1,
          0,
          1
        ]
      },
      "output": false
    }
  ]
}