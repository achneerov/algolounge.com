{
  "filename": "longest-substring-without-repeating-characters",
  "title": "Longest Substring Without Repeating Characters",
  "keywords": [
    "longest",
    "substring",
    "repeating",
    "characters",
    "sliding",
    "window",
    "hashmap"
  ],
  "description": "<h2>Longest Substring Without Repeating Characters</h2><p>Given a string <code>s</code>, find the length of the <strong>longest substring</strong> without repeating characters.</p><h3>Examples:</h3><ul><li><strong>Example 1:</strong><br>Input: s = \"abcabcbb\"<br>Output: 3<br>Explanation: The answer is \"abc\", with the length of 3.</li><li><strong>Example 2:</strong><br>Input: s = \"bbbbb\"<br>Output: 1<br>Explanation: The answer is \"b\", with the length of 1.</li><li><strong>Example 3:</strong><br>Input: s = \"pwwkew\"<br>Output: 3<br>Explanation: The answer is \"wke\", with the length of 3.<br>Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.</li></ul><h3>Constraints:</h3><ul><li>0 <= s.length <= 5 * 10<sup>4</sup></li><li>s consists of English letters, digits, symbols and spaces.</li></ul>",
  "template": "def lengthOfLongestSubstring(s):\n    ",
  "solution_text": "Use sliding window with hash map to track character positions. When duplicate found, move left pointer.",
  "solution_code": "def lengthOfLongestSubstring(s):\n    char_map = {}\n    left = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        if s[right] in char_map and char_map[s[right]] >= left:\n            left = char_map[s[right]] + 1\n        \n        char_map[s[right]] = right\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length",
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "s": "abcabcbb"
      },
      "output": 3
    },
    {
      "id": 2,
      "input": {
        "s": "bbbbb"
      },
      "output": 1
    },
    {
      "id": 3,
      "input": {
        "s": "pwwkew"
      },
      "output": 3
    }
  ]
}