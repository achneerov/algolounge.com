{
  "filename": "maximum-depth-of-binary-tree",
  "title": "Maximum Depth of Binary Tree",
  "keywords": [
    "maximum",
    "depth",
    "binary",
    "tree",
    "leetcode",
    "104",
    "given",
    "root",
    "return",
    "height"
  ],
  "description": "<h2>Maximum Depth of Binary Tree</h2><p>Leetcode 104. Maximum Depth of Binary Tree</p><p></p><p>Given the <code>root</code> of a binary tree, return its <strong>depth</strong>.</p><p></p><p>The <strong>depth</strong> of a binary tree is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.</p><h3>Examples:</h3><ul><li>Input: root = [3,9,20,null,null,15,7]<br><pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7</pre>Output: 3 (depth: 3 levels)</li><li>Input: root = [1,null,2]<br><pre>1\n \\\n  2</pre>Output: 2</li><li>Input: root = []<br><br>Output: 0</li></ul><h3>Constraints:</h3><ul><li>0 <= The number of nodes in the tree <= 100</li><li>-100 <= Node.val <= 100</li></ul>",
  "entry_function": "maximumDepthOfBinaryTree",
  "template": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef maximumDepthOfBinaryTree(root):\n    ",
  "solution_text": "<h3>Maximum Depth of Binary Tree</h3><p><strong>Algorithm:</strong></p><ol><li>Base case: if root is None, return 0 (empty tree has depth 0)</li><li>Recursively calculate depth of left subtree</li><li>Recursively calculate depth of right subtree</li><li>Return 1 + max(left_depth, right_depth)</li><li>The +1 accounts for the current node</li></ol><p><strong>Time Complexity:</strong> O(n) - visit each node once</p><p><strong>Space Complexity:</strong> O(h) - recursion stack depth where h is tree height</p><p><strong>Key Insights:</strong></p><ul><li>Depth is the longest path from root to any leaf</li><li>Use recursion to break problem into subproblems</li><li>Maximum depth = 1 + max depth of subtrees</li><li>Can also be solved iteratively using level-order traversal</li></ul>",
  "solution_code": "def maximumDepthOfBinaryTree(root):\n    # Base case: empty tree has depth 0\n    if not root:\n        return 0\n    \n    # Recursively calculate depth of left and right subtrees\n    left_depth = maximumDepthOfBinaryTree(root.left)\n    right_depth = maximumDepthOfBinaryTree(root.right)\n    \n    # Return 1 (current node) + maximum depth of subtrees\n    return 1 + max(left_depth, right_depth)",
  "prepare": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n    \n    def __repr__(self):\n        return f'TreeNode({self.val})'\n\ndef prepare(test_case_input):\n    \"\"\"Convert array representation to TreeNode structure\"\"\"\n    root_array = test_case_input['root']\n    if not root_array or root_array[0] is None:\n        return (None,)\n\n    def build_tree(arr):\n        from collections import deque\n        \n        root = TreeNode(arr[0])\n        queue = deque([root])\n        i = 1\n        \n        while queue and i < len(arr):\n            node = queue.popleft()\n            \n            # Add left child\n            if i < len(arr):\n                if arr[i] is not None:\n                    node.left = TreeNode(arr[i])\n                    queue.append(node.left)\n                i += 1\n            \n            # Add right child\n            if i < len(arr):\n                if arr[i] is not None:\n                    node.right = TreeNode(arr[i])\n                    queue.append(node.right)\n                i += 1\n        \n        return root\n\n    return (build_tree(root_array),)",
  "verify": "def verify(actual_output, expected_output):\n    \"\"\"Verify the depth calculation\"\"\"\n    passed = actual_output == expected_output\n    output_str = str(actual_output)\n    \n    return [passed, output_str]",
  "test_cases": [
    {
      "id": 1,
      "input": {
        "root": [3, 9, 20, null, null, 15, 7]
      },
      "output": 3
    },
    {
      "id": 2,
      "input": {
        "root": [1, null, 2]
      },
      "output": 2
    },
    {
      "id": 3,
      "input": {
        "root": []
      },
      "output": 0
    },
    {
      "id": 4,
      "input": {
        "root": [1]
      },
      "output": 1
    },
    {
      "id": 5,
      "input": {
        "root": [1, 2, 3, 4, 5]
      },
      "output": 3
    }
  ]
}
