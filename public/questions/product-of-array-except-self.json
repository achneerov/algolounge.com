{
  "filename": "product-of-array-except-self",
  "title": "Product of Array Except Self",
  "keywords": [
    "product",
    "array",
    "except",
    "self",
    "prefix",
    "suffix",
    "multiplication",
    "division",
    "algorithm",
    "optimization"
  ],
  "description": "<h2>Product of Array Except Self</h2><p>Given an integer array <code>nums</code>, return an array <code>answer</code> such that <code>answer[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</p><p>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</p><p>You must write an algorithm that runs in <code>O(n)</code> time and without using the division operation.</p><h3>Examples:</h3><ul><li>Input: nums = [1,2,3,4]<br>Output: [24,12,8,6]</li><li>Input: nums = [-1,1,0,-3,3]<br>Output: [0,0,9,0,0]</li></ul><h3>Constraints:</h3><ul><li><code>2 <= nums.length <= 10^5</code></li><li><code>-30 <= nums[i] <= 30</code></li><li>The product of any prefix or suffix of <code>nums</code> is guaranteed to fit in a 32-bit integer</li></ul><h3>Follow up:</h3><p>Can you solve the problem in <code>O(1)</code> extra space complexity? (The output array does not count as extra space for space complexity analysis.)</p>",
  "entry_function": "productExceptSelf",
  "template": "def productExceptSelf(nums):\n    ",
  "solution_text": "<h3>Product of Array Except Self</h3><p><strong>Algorithm:</strong></p><ol><li>Create result array to store left products</li><li>First pass: calculate prefix products (product of all elements to the left)</li><li>Second pass: multiply by suffix products (product of all elements to the right)</li><li>Use a running variable to avoid extra space for suffix products</li></ol><p><strong>Time Complexity:</strong> O(n) - two passes through the array</p><p><strong>Space Complexity:</strong> O(1) - only using the output array and constant variables</p><p><strong>Key Insights:</strong></p><ul><li>Split the problem into prefix and suffix products</li><li>Use the output array itself to store intermediate results</li><li>Running variable eliminates need for separate suffix array</li><li>No division operation required</li></ul>",
  "solution_code": "def productExceptSelf(nums):\n    n = len(nums)\n    result = [1] * n\n    \n    # First pass: calculate prefix products\n    # result[i] contains product of all elements to the left of i\n    for i in range(1, n):\n        result[i] = result[i-1] * nums[i-1]\n    \n    # Second pass: multiply by suffix products\n    # Use running variable to calculate product of all elements to the right\n    right_product = 1\n    for i in range(n-1, -1, -1):\n        result[i] *= right_product\n        right_product *= nums[i]\n    \n    return result",
  "prepare": "def prepare(test_case_input):\n    \"\"\"Prepare arguments for productExceptSelf function\"\"\"\n    return (test_case_input['nums'],)",
  "verify": "def verify(actual_output, expected_output):\n    \"\"\"Verify the product except self result\"\"\"\n    def list_to_string(lst):\n        if not lst:\n            return '[]'\n        return '[' + ', '.join(str(x) for x in lst) + ']'\n    \n    passed = actual_output == expected_output\n    output_str = list_to_string(actual_output)\n    \n    return [passed, output_str]",
  "order_matters": true,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "nums": [1, 2, 3, 4]
      },
      "output": [24, 12, 8, 6]
    },
    {
      "id": 2,
      "input": {
        "nums": [-1, 1, 0, -3, 3]
      },
      "output": [0, 0, 9, 0, 0]
    },
    {
      "id": 3,
      "input": {
        "nums": [2, 3]
      },
      "output": [3, 2]
    },
    {
      "id": 4,
      "input": {
        "nums": [1, 0]
      },
      "output": [0, 1]
    },
    {
      "id": 5,
      "input": {
        "nums": [0, 0]
      },
      "output": [0, 0]
    },
    {
      "id": 6,
      "input": {
        "nums": [5, 2, 3, 1]
      },
      "output": [6, 15, 10, 30]
    },
    {
      "id": 7,
      "input": {
        "nums": [1, 2, 0, 4]
      },
      "output": [0, 0, 8, 0]
    },
    {
      "id": 8,
      "input": {
        "nums": [-1, -2, -3]
      },
      "output": [6, 3, 2]
    },
    {
      "id": 9,
      "input": {
        "nums": [10, 3, 5, 6, 2]
      },
      "output": [180, 600, 360, 300, 900]
    },
    {
      "id": 10,
      "input": {
        "nums": [1, 1, 1, 1]
      },
      "output": [1, 1, 1, 1]
    }
  ]
}