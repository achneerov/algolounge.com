{
  "filename": "reorder-list",
  "title": "Reorder Linked List",
  "keywords": [
    "reorder",
    "linked",
    "list",
    "leetcode",
    "143",
    "given",
    "head",
    "singly",
    "positions",
    "length"
  ],
  "description": "<h2>Reorder Linked List</h2><p><em>Leetcode 143. Reorder List</em></p><p>You are given the head of a singly linked-list.</p><p>The positions of a linked list of <code>length = 7</code> for example, can initially be represented as:</p><p><code>[0, 1, 2, 3, 4, 5, 6]</code></p><p>Reorder the nodes of the linked list to be in the following order:</p><p><code>[0, 6, 1, 5, 2, 4, 3]</code></p><p>Notice that in the general case for a list of <code>length = n</code> the nodes are reordered to be in the following order:</p><p><code>[0, n-1, 1, n-2, 2, n-3, ...]</code></p><p>You may not modify the values in the list's nodes, but instead you must reorder the nodes themselves.</p><h3>Examples:</h3><ul><li><strong>Input:</strong> <code>head = [2,4,6,8]</code><br><strong>Output:</strong> <code>[2,8,4,6]</code></li><li><strong>Input:</strong> <code>head = [2,4,6,8,10]</code><br><strong>Output:</strong> <code>[2,10,4,8,6]</code></li></ul><h3>Constraints:</h3><ul><li><code>1 <= Length of the list <= 1000</code></li><li><code>1 <= Node.val <= 1000</code></li></ul>",
  "entry_function": "reorderList",
  "template": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef reorderList(head):\n    ",
  "solution_text": "<h3>Reorder Linked List - Three Step Approach</h3>\n\n<p><strong>Algorithm:</strong></p>\n<ol>\n<li>Find the middle of the linked list using slow/fast pointers</li>\n<li>Reverse the second half of the list</li>\n<li>Merge the two halves by alternating nodes</li>\n</ol>\n\n<p><strong>Time Complexity:</strong> O(n) - visit each node constant times</p>\n<p><strong>Space Complexity:</strong> O(1) - only using pointers</p>\n\n<p><strong>Key Insights:</strong></p>\n<ul>\n<li>Split list at midpoint to get two halves</li>\n<li>Reverse second half to get nodes from end</li>\n<li>Merge by taking alternately from each half</li>\n<li>Modify pointers in-place without extra space</li>\n</ul>",
  "solution_code": "def reorderList(head):\n    if not head or not head.next:\n        return head\n    \n    # Step 1: Find middle using slow/fast pointers\n    slow = head\n    fast = head\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n    \n    # Step 2: Reverse second half\n    second = slow.next\n    slow.next = None  # Split the list\n    \n    prev = None\n    while second:\n        temp = second.next\n        second.next = prev\n        prev = second\n        second = temp\n    second = prev\n    \n    # Step 3: Merge two halves\n    first = head\n    while second:\n        temp1 = first.next\n        temp2 = second.next\n        \n        first.next = second\n        second.next = temp1\n        \n        first = temp1\n        second = temp2\n    \n    return head",

  "prepare": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n    \n    def __repr__(self):\n        return f'ListNode({self.val})'\n\ndef prepare(test_case_input):\n    \"\"\"Convert array representation to ListNode structure\"\"\"\n    def build_list(arr):\n        if not arr:\n            return None\n        head = ListNode(arr[0])\n        current = head\n        for val in arr[1:]:\n            current.next = ListNode(val)\n            current = current.next\n        return head\n    \n    head = build_list(test_case_input['head'])\n    return (head,)",

  "verify": "def verify(actual_output, expected_output):\n    \"\"\"Verify the reordered linked list result\"\"\"\n    def list_to_array(node):\n        result = []\n        while node:\n            result.append(node.val)\n            node = node.next\n        return result\n    \n    def list_to_string(lst):\n        if not lst:\n            return '[]'\n        return '[' + ', '.join(str(x) for x in lst) + ']'\n    \n    # Note: reorderList modifies in-place and returns None\n    # So we need to check the modified list structure\n    actual_array = list_to_array(actual_output) if actual_output else []\n    passed = actual_array == expected_output\n    output_str = list_to_string(actual_array)\n    \n    return [passed, output_str]",

  "test_cases": [
    {
      "id": 1,
      "input": {
        "head": [2, 4, 6, 8]
      },
      "output": [2, 8, 4, 6]
    },
    {
      "id": 2,
      "input": {
        "head": [2, 4, 6, 8, 10]
      },
      "output": [2, 10, 4, 8, 6]
    },
    {
      "id": 3,
      "input": {
        "head": [1]
      },
      "output": [1]
    },
    {
      "id": 4,
      "input": {
        "head": [1, 2]
      },
      "output": [1, 2]
    },
    {
      "id": 5,
      "input": {
        "head": [1, 2, 3]
      },
      "output": [1, 3, 2]
    },
    {
      "id": 6,
      "input": {
        "head": [1, 2, 3, 4]
      },
      "output": [1, 4, 2, 3]
    },
    {
      "id": 7,
      "input": {
        "head": [1, 2, 3, 4, 5]
      },
      "output": [1, 5, 2, 4, 3]
    },
    {
      "id": 8,
      "input": {
        "head": [1, 2, 3, 4, 5, 6]
      },
      "output": [1, 6, 2, 5, 3, 4]
    },
    {
      "id": 9,
      "input": {
        "head": [10, 20, 30, 40, 50, 60, 70]
      },
      "output": [10, 70, 20, 60, 30, 50, 40]
    },
    {
      "id": 10,
      "input": {
        "head": [5, 10, 15, 20, 25, 30, 35, 40]
      },
      "output": [5, 40, 10, 35, 15, 30, 20, 25]
    }
  ]
}