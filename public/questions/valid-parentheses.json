{
  "filename": "valid-parentheses",
  "title": "Valid Parentheses",
  "keywords": [
    "valid",
    "parentheses",
    "stack",
    "brackets",
    "string",
    "matching",
    "pairs",
    "nested",
    "structure",
    "validation"
  ],
  "description": "<h2>Valid Parentheses</h2><p>Given a string <code>s</code> containing just the characters <code>'('</code>, <code>')'</code>, <code>'{'</code>, <code>'}'</code>, <code>'['</code> and <code>']'</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li><li>Every close bracket has a corresponding open bracket of the same type.</li></ol><h3>Examples:</h3><ul><li>Input: s = \"()\"<br>Output: true</li><li>Input: s = \"()[]{}\"<br>Output: true</li><li>Input: s = \"(]\"<br>Output: false</li><li>Input: s = \"([)]\"<br>Output: false</li><li>Input: s = \"{[]}\"<br>Output: true</li></ul><h3>Constraints:</h3><ul><li><code>1 <= s.length <= 10^4</code></li><li><code>s</code> consists of parentheses only <code>'()[]{}'</code></li></ul>",
  "entry_function": "isValid",
  "template": "def isValid(s):\n    ",
  "solution_text": "<h3>Valid Parentheses</h3><p><strong>Algorithm:</strong></p><ol><li>Use a stack to track opening brackets</li><li>For each character in the string:</li><ul><li>If it's an opening bracket, push it onto the stack</li><li>If it's a closing bracket, check if it matches the top of stack</li><li>If no match or stack is empty, return false</li></ul><li>Return true if stack is empty at the end</li></ol><p><strong>Time Complexity:</strong> O(n) - single pass through string</p><p><strong>Space Complexity:</strong> O(n) - stack storage in worst case</p><p><strong>Key Insights:</strong></p><ul><li>Stack naturally handles the nested structure of brackets</li><li>Early return false for unmatched closing brackets</li><li>Stack must be empty at end for valid string</li><li>Use mapping dictionary for efficient bracket matching</li></ul>",
  "solution_code": "def isValid(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping:\n            # Closing bracket\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            # Opening bracket\n            stack.append(char)\n    \n    return len(stack) == 0",
  "prepare": "def prepare(test_case_input):\n    \"\"\"Prepare arguments for isValid function\"\"\"\n    return (test_case_input['s'],)",
  "verify": "def verify(actual_output, expected_output):\n    \"\"\"Verify the parentheses validation result\"\"\"\n    def bool_to_string(val):\n        return 'true' if val else 'false'\n    \n    # Convert expected output string to boolean for comparison\n    expected_bool = expected_output == 'true' if isinstance(expected_output, str) else expected_output\n    \n    passed = actual_output == expected_bool\n    output_str = bool_to_string(actual_output)\n    \n    return [passed, output_str]",
  "test_cases": [
    {
      "id": 1,
      "input": {
        "s": "()"
      },
      "output": "true"
    },
    {
      "id": 2,
      "input": {
        "s": "()[]{}"
      },
      "output": "true"
    },
    {
      "id": 3,
      "input": {
        "s": "(]"
      },
      "output": "false"
    },
    {
      "id": 4,
      "input": {
        "s": "([)]"
      },
      "output": "false"
    },
    {
      "id": 5,
      "input": {
        "s": "{[]}"
      },
      "output": "true"
    },
    {
      "id": 6,
      "input": {
        "s": ""
      },
      "output": "true"
    },
    {
      "id": 7,
      "input": {
        "s": "((("
      },
      "output": "false"
    },
    {
      "id": 8,
      "input": {
        "s": ")))"
      },
      "output": "false"
    },
    {
      "id": 9,
      "input": {
        "s": "({[]})"
      },
      "output": "true"
    },
    {
      "id": 10,
      "input": {
        "s": "({[}])"
      },
      "output": "false"
    }
  ]
}