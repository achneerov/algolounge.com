{
  "index": 16,
  "filename": "binary-tree-from-preorder-and-inorder-traversal",
  "title": "Construct Binary Tree from Preorder and Inorder Traversal",
  "difficulty": "Medium",
  "tags": [],
  "keywords": [
    "construct",
    "binary",
    "tree",
    "preorder",
    "inorder",
    "traversal",
    "leetcode",
    "105",
    "given",
    "two"
  ],
  "description": "<h2>Construct Binary Tree from Preorder and Inorder Traversal</h2><p>Leetcode 105. Construct Binary Tree From Preorder And Inorder Traversal</p><p></p><p>You are given two integer arrays `preorder` and `inorder`.</p><p>        </p><p>* `preorder` is the preorder traversal of a binary tree</p><p>* `inorder` is the inorder traversal of the same tree</p><p>* Both arrays are of the same size and consist of unique values.</p><p></p><p>Rebuild the binary tree from the preorder and inorder traversals and return its root.</p><h3>Examples:</h3><ul><li>Input: preorder = [1], inorder = [1]<br><br>Output: [1]</li></ul><h3>Constraints:</h3><ul><li> `1 <= inorder.length <= 1000`.</li><li> `inorder.length == preorder.length`</li><li> `-1000 <= preorder[i], inorder[i] <= 1000`</li></ul>",
  "entry_function": "constructBinaryTreeFromPreorderAndInorderTraversal",
  "template": "def constructBinaryTreeFromPreorderAndInorderTraversal(preorder, inorder):\n    ",
  "solution_text": "<h3>Construct Binary Tree from Preorder and Inorder Traversal</h3><p><strong>Algorithm:</strong></p><ol><li>The first element in preorder is always the root</li><li>Find root position in inorder array to determine left/right subtrees</li><li>Recursively build left subtree using left portion of both arrays</li><li>Recursively build right subtree using right portion of both arrays</li></ol><p><strong>Time Complexity:</strong> O(n) - process each node once</p><p><strong>Space Complexity:</strong> O(n) - for hashmap and recursion stack</p><p><strong>Key Insights:</strong></p><ul><li>Preorder: Root -> Left -> Right</li><li>Inorder: Left -> Root -> Right</li><li>Use hashmap for O(1) root lookups in inorder array</li></ul>",
  "solution_code": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef constructBinaryTreeFromPreorderAndInorderTraversal(preorder, inorder):\n    if not preorder or not inorder:\n        return None\n    \n    # Create hashmap for O(1) lookups in inorder array\n    inorder_map = {val: i for i, val in enumerate(inorder)}\n    \n    def build(pre_start, pre_end, in_start, in_end):\n        if pre_start > pre_end:\n            return None\n        \n        # Root is always first element in preorder range\n        root_val = preorder[pre_start]\n        root = TreeNode(root_val)\n        \n        # Find root position in inorder array\n        root_idx = inorder_map[root_val]\n        left_size = root_idx - in_start\n        \n        # Build left and right subtrees\n        root.left = build(pre_start + 1, pre_start + left_size, in_start, root_idx - 1)\n        root.right = build(pre_start + left_size + 1, pre_end, root_idx + 1, in_end)\n        \n        return root\n    \n    return build(0, len(preorder) - 1, 0, len(inorder) - 1)",
  "prepare": "def prepare(test_case_input):\n    return (test_case_input['preorder'], test_case_input['inorder'])",
  "verify": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef verify(actual_output, expected_output):\n    from collections import deque\n\n    def tree_to_list(root):\n        if not root:\n            return []\n        result = []\n        queue = deque([root])\n        while queue:\n            node = queue.popleft()\n            if node:\n                result.append(node.val)\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                result.append(None)\n        while result and result[-1] is None:\n            result.pop()\n        return result\n\n    actual_list = tree_to_list(actual_output)\n    passed = actual_list == expected_output\n    output_str = str(actual_list)\n    return [passed, output_str]",
  "test_cases": [
    {
      "id": 1,
      "input": {
        "preorder": [
          1
        ],
        "inorder": [
          1
        ]
      },
      "output": [
        1
      ]
    },
    {
      "id": 2,
      "input": {
        "preorder": [
          3,
          9,
          20,
          15,
          7
        ],
        "inorder": [
          9,
          3,
          15,
          20,
          7
        ]
      },
      "output": [
        3,
        9,
        20,
        null,
        null,
        15,
        7
      ]
    },
    {
      "id": 3,
      "input": {
        "preorder": [
          1,
          2
        ],
        "inorder": [
          2,
          1
        ]
      },
      "output": [
        1,
        2
      ]
    },
    {
      "id": 4,
      "input": {
        "preorder": [
          1,
          2,
          3
        ],
        "inorder": [
          2,
          1,
          3
        ]
      },
      "output": [
        1,
        2,
        3
      ]
    },
    {
      "id": 5,
      "input": {
        "preorder": [
          1,
          2,
          4,
          5,
          3,
          6
        ],
        "inorder": [
          4,
          2,
          5,
          1,
          6,
          3
        ]
      },
      "output": [
        1,
        2,
        3,
        4,
        5,
        6
      ]
    },
    {
      "id": 6,
      "input": {
        "preorder": [
          3,
          9,
          20,
          15,
          7
        ],
        "inorder": [
          9,
          3,
          15,
          20,
          7
        ]
      },
      "output": [
        3,
        9,
        20,
        null,
        null,
        15,
        7
      ]
    },
    {
      "id": 7,
      "input": {
        "preorder": [
          1,
          2,
          4,
          3,
          5,
          6
        ],
        "inorder": [
          4,
          2,
          1,
          5,
          3,
          6
        ]
      },
      "output": [
        1,
        2,
        3,
        4,
        null,
        5,
        6
      ]
    },
    {
      "id": 8,
      "input": {
        "preorder": [
          5,
          3,
          2,
          4,
          7,
          6,
          8
        ],
        "inorder": [
          2,
          3,
          4,
          5,
          6,
          7,
          8
        ]
      },
      "output": [
        5,
        3,
        7,
        2,
        4,
        6,
        8
      ]
    },
    {
      "id": 9,
      "input": {
        "preorder": [
          10,
          5,
          1,
          7,
          15,
          12,
          20
        ],
        "inorder": [
          1,
          5,
          7,
          10,
          12,
          15,
          20
        ]
      },
      "output": [
        10,
        5,
        15,
        1,
        7,
        12,
        20
      ]
    },
    {
      "id": 10,
      "input": {
        "preorder": [
          8,
          4,
          2,
          1,
          3,
          6,
          5,
          7
        ],
        "inorder": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8
        ]
      },
      "output": [
        8,
        4,
        null,
        2,
        6,
        1,
        3,
        5,
        7
      ]
    }
  ]
}
