{
  "index": 89,
  "filename": "find-duplicate-integer",
  "title": "Find the Duplicate Number",
  "difficulty": "Medium",
  "tags": [],
  "keywords": [
    "find",
    "duplicate ",
    "number",
    "array",
    "cycle detection",
    "floyd",
    "tortoise and hare",
    "two pointers"
  ],
  "description": "<h2>Find the Duplicate Number</h2><p>You are given an array of integers <code>nums</code> containing <code>n + 1</code> integers. Each integer in <code>nums</code> is in the range <code>[1, n]</code> inclusive.</p><p>Every integer appears <strong>exactly once</strong>, except for one integer which appears <strong>two or more times</strong>. Return the integer that appears more than once.</p><h3>Examples:</h3><ul><li>Input: nums = [1,2,3,2,2]<br>Output: 2</li><li>Input: nums = [1,2,3,4,4]<br>Output: 4</li></ul><h3>Constraints:</h3><ul><li><code>1 &lt;= n &lt;= 10000</code></li><li><code>nums.length == n + 1</code></li><li><code>1 &lt;= nums[i] &lt;= n</code></li></ul>",
  "entry_function": "findTheDuplicateNumber",
  "template": "def findTheDuplicateNumber(nums):\n    ",
  "solution_text": "<h3>Find the Duplicate Number</h3><p><strong>Algorithm:</strong></p><ol><li>Treat the array as a linked list where nums[i] points to index nums[i]</li><li>Use two pointers (slow and fast) to detect the cycle</li><li>Move slow by 1 step and fast by 2 steps until they meet</li><li>Reset one pointer to start, move both by 1 step until they meet again</li><li>The meeting point is the duplicate number</li></ol><p><strong>Time Complexity:</strong> O(n) - linear scan with cycle detection</p><p><strong>Space Complexity:</strong> O(1) - only uses two pointers</p><p><strong>Key Insights:</strong></p><ul><li>Treats array indexing as linked list traversal</li><li>Cycle detection finds the duplicate without extra space</li><li>Works because duplicate creates a cycle in the linked list</li></ul>",
  "solution_code": "def findTheDuplicateNumber(nums):\n    # Floyd's Tortoise and Hare (Cycle Detection)\n    # Phase 1: Find intersection point in the cycle\n    slow = nums[0]\n    fast = nums[0]\n    \n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n    \n    # Phase 2: Find the entrance to the cycle (duplicate number)\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n    \n    return slow",
  "prepare": "def prepare(test_case_input):\n    \"\"\"Prepare arguments for findTheDuplicateNumber function\"\"\"\n    return (test_case_input['nums'],)",
  "verify": "def verify(actual_output, expected_output):\n    \"\"\"Verify the duplicate number result\"\"\"\n    passed = actual_output == expected_output\n    output_str = str(actual_output)\n    \n    return [passed, output_str]",
  "test_cases": [
    {
      "id": 1,
      "input": {
        "nums": [
          1,
          2,
          3,
          2,
          2
        ]
      },
      "output": 2
    },
    {
      "id": 2,
      "input": {
        "nums": [
          1,
          2,
          3,
          4,
          4
        ]
      },
      "output": 4
    },
    {
      "id": 3,
      "input": {
        "nums": [
          3,
          1,
          3,
          4,
          2
        ]
      },
      "output": 3
    },
    {
      "id": 4,
      "input": {
        "nums": [
          1,
          1
        ]
      },
      "output": 1
    },
    {
      "id": 5,
      "input": {
        "nums": [
          2,
          5,
          9,
          6,
          9,
          3,
          8,
          9,
          7,
          1,
          4
        ]
      },
      "output": 9
    }
  ]
}
