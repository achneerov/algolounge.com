{
  "index": 0,
  "filename": "reverse-nodes-in-k-group",
  "title": "Reverse Nodes in K-Group",
  "difficulty": "Hard",
  "tags": [
    "Linked List"
  ],
  "keywords": [
    "linked",
    "list",
    "reverse",
    "k-group",
    "group",
    "nodes",
    "head",
    "simulation"
  ],
  "description": "<h2>Reverse Nodes in K-Group</h2><p>Given the <code>head</code> of a linked list, reverse the nodes of the list <code>k</code> at a time, and return the modified list.</p><p><code>k</code> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <code>k</code> then left-out nodes, in the end, should remain as it is.</p><p>You may not alter the values in the list's nodes, only nodes themselves may be changed.</p><h3>Examples:</h3><ul><li><strong>Input:</strong> head = [1,2,3,4,5], k = 2<br><strong>Output:</strong> [2,1,4,3,5]<br><strong>Explanation:</strong><pre>1 → 2 → 3 → 4 → 5\n    ↓\n2 → 1 → 4 → 3 → 5</pre></li><li><strong>Input:</strong> head = [1,2,3,4,5], k = 3<br><strong>Output:</strong> [3,2,1,4,5]<br><strong>Explanation:</strong><pre>1 → 2 → 3 → 4 → 5\n    ↓\n3 → 2 → 1 → 4 → 5</pre>The last group has only 2 nodes, so it remains unchanged.</li></ul><h3>Constraints:</h3><ul><li>The number of nodes in the list is <code>n</code></li><li><code>1 <= k <= n <= 5000</code></li><li><code>0 <= Node.val <= 1000</code></li></ul>",
  "entry_function": "reverseKGroup",
  "template": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef reverseKGroup(head, k):\n    ",
  "solution_text": "<h3>Reverse Nodes in K-Group</h3>\n\n<p><strong>Algorithm:</strong></p>\n<ol>\n<li>Create a dummy node pointing to head to handle edge cases</li>\n<li>For each group of k nodes:</li>\n<ul>\n<li>First, check if there are k nodes remaining</li>\n<li>If yes, reverse those k nodes</li>\n<li>Reconnect the reversed segment to the rest of the list</li>\n</ul>\n<li>If fewer than k nodes remain, leave them as is</li>\n</ol>\n\n<p><strong>Helper function to reverse a segment:</strong></p>\n<p>Given a segment of nodes, reverse them by adjusting the <code>next</code> pointers.</p>\n\n<p><strong>Time Complexity:</strong> O(n) - each node is visited at most twice</p>\n<p><strong>Space Complexity:</strong> O(1) - only using pointers</p>\n\n<p><strong>Key Insights:</strong></p>\n<ul>\n<li>A dummy node simplifies handling the head of the list</li>\n<li>Track the node before each group to reconnect after reversal</li>\n<li>Count nodes first to know if we have a complete group</li>\n</ul>",
  "solution_code": "def reverseKGroup(head, k):\n    def reverse(head, tail):\n        prev = tail.next\n        curr = head\n        while prev != tail:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        return tail, head\n    \n    dummy = ListNode(0, head)\n    pre = dummy\n    \n    while head:\n        tail = pre\n        # Check if there are k nodes remaining\n        for _ in range(k):\n            tail = tail.next\n            if not tail:\n                return dummy.next\n        \n        next_group = tail.next\n        head, tail = reverse(head, tail)\n        \n        # Connect with previous part\n        pre.next = head\n        tail.next = next_group\n        \n        # Move to next group\n        pre = tail\n        head = next_group\n    \n    return dummy.next",
  "prepare": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef prepare(test_case_input):\n    \"\"\"Convert array to linked list\"\"\"\n    arr = test_case_input['head']\n    k = test_case_input['k']\n    \n    if not arr:\n        return (None, k)\n    \n    head = ListNode(arr[0])\n    current = head\n    \n    for val in arr[1:]:\n        new_node = ListNode(val)\n        current.next = new_node\n        current = new_node\n    \n    return (head, k)",
  "verify": "def verify(actual_output, expected_output):\n    \"\"\"Convert linked list back to array and compare\"\"\"\n    result = []\n    current = actual_output\n    while current:\n        result.append(current.val)\n        current = current.next\n    \n    passed = result == expected_output\n    return [passed, str(result)]",
  "test_cases": [
    {
      "id": 1,
      "input": {
        "head": [1, 2, 3, 4, 5],
        "k": 2
      },
      "output": [2, 1, 4, 3, 5]
    },
    {
      "id": 2,
      "input": {
        "head": [1, 2, 3, 4, 5],
        "k": 3
      },
      "output": [3, 2, 1, 4, 5]
    },
    {
      "id": 3,
      "input": {
        "head": [1, 2, 3, 4, 5],
        "k": 1
      },
      "output": [1, 2, 3, 4, 5]
    },
    {
      "id": 4,
      "input": {
        "head": [1, 2, 3, 4, 5],
        "k": 5
      },
      "output": [5, 4, 3, 2, 1]
    },
    {
      "id": 5,
      "input": {
        "head": [1],
        "k": 1
      },
      "output": [1]
    },
    {
      "id": 6,
      "input": {
        "head": [1, 2],
        "k": 2
      },
      "output": [2, 1]
    },
    {
      "id": 7,
      "input": {
        "head": [1, 2, 3, 4, 5, 6],
        "k": 2
      },
      "output": [2, 1, 4, 3, 6, 5]
    },
    {
      "id": 8,
      "input": {
        "head": [1, 2, 3, 4, 5, 6, 7, 8],
        "k": 3
      },
      "output": [3, 2, 1, 6, 5, 4, 7, 8]
    },
    {
      "id": 9,
      "input": {
        "head": [1, 2, 3, 4, 5, 6, 7, 8, 9],
        "k": 4
      },
      "output": [4, 3, 2, 1, 8, 7, 6, 5, 9]
    },
    {
      "id": 10,
      "input": {
        "head": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
        "k": 5
      },
      "output": [5, 4, 3, 2, 1, 10, 9, 8, 7, 6]
    }
  ]
}
